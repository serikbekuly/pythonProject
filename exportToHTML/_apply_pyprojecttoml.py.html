<html>
<head>
<title>_apply_pyprojecttoml.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_apply_pyprojecttoml.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Translation layer between pyproject config and setuptools distribution and 
metadata objects. 
 
The distribution and metadata objects are modeled after (an old version of) 
core metadata, therefore configs in the format specified for ``pyproject.toml`` 
need to be processed before being applied. 
 
**PRIVATE MODULE**: API reserved for setuptools internal usage only. 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">collections.abc </span><span class="s2">import </span><span class="s1">Mapping</span>
<span class="s2">from </span><span class="s1">email.headerregistry </span><span class="s2">import </span><span class="s1">Address</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">partial</span><span class="s2">, </span><span class="s1">reduce</span>
<span class="s2">from </span><span class="s1">itertools </span><span class="s2">import </span><span class="s1">chain</span>
<span class="s2">from </span><span class="s1">types </span><span class="s2">import </span><span class="s1">MappingProxyType</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(TYPE_CHECKING</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">, </span><span class="s1">Callable</span><span class="s2">, </span><span class="s1">Dict</span><span class="s2">, </span><span class="s1">List</span><span class="s2">, </span><span class="s1">Optional</span><span class="s2">, </span><span class="s1">Set</span><span class="s2">, </span><span class="s1">Tuple</span><span class="s2">,</span>
                    <span class="s1">Type</span><span class="s2">, </span><span class="s1">Union)</span>

<span class="s2">from </span><span class="s1">setuptools._deprecation_warning </span><span class="s2">import </span><span class="s1">SetuptoolsDeprecationWarning</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s2">from </span><span class="s1">setuptools._importlib </span><span class="s2">import </span><span class="s1">metadata  </span><span class="s3"># noqa</span>
    <span class="s2">from </span><span class="s1">setuptools.dist </span><span class="s2">import </span><span class="s1">Distribution  </span><span class="s3"># noqa</span>

<span class="s1">EMPTY: Mapping = MappingProxyType({})  </span><span class="s3"># Immutable dict-like</span>
<span class="s1">_Path = Union[os.PathLike</span><span class="s2">, </span><span class="s1">str]</span>
<span class="s1">_DictOrStr = Union[dict</span><span class="s2">, </span><span class="s1">str]</span>
<span class="s1">_CorrespFn = Callable[[</span><span class="s4">&quot;Distribution&quot;</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">, </span><span class="s1">_Path]</span><span class="s2">, None</span><span class="s1">]</span>
<span class="s1">_Correspondence = Union[str</span><span class="s2">, </span><span class="s1">_CorrespFn]</span>

<span class="s1">_logger = logging.getLogger(__name__)</span>


<span class="s2">def </span><span class="s1">apply(dist: </span><span class="s4">&quot;Distribution&quot;</span><span class="s2">, </span><span class="s1">config: dict</span><span class="s2">, </span><span class="s1">filename: _Path) -&gt; </span><span class="s4">&quot;Distribution&quot;</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot;Apply configuration dict read with :func:`read_configuration`&quot;&quot;&quot;</span>

    <span class="s2">if not </span><span class="s1">config:</span>
        <span class="s2">return </span><span class="s1">dist  </span><span class="s3"># short-circuit unrelated pyproject.toml file</span>

    <span class="s1">root_dir = os.path.dirname(filename) </span><span class="s2">or </span><span class="s4">&quot;.&quot;</span>

    <span class="s1">_apply_project_table(dist</span><span class="s2">, </span><span class="s1">config</span><span class="s2">, </span><span class="s1">root_dir)</span>
    <span class="s1">_apply_tool_table(dist</span><span class="s2">, </span><span class="s1">config</span><span class="s2">, </span><span class="s1">filename)</span>

    <span class="s1">current_directory = os.getcwd()</span>
    <span class="s1">os.chdir(root_dir)</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">dist._finalize_requires()</span>
        <span class="s1">dist._finalize_license_files()</span>
    <span class="s2">finally</span><span class="s1">:</span>
        <span class="s1">os.chdir(current_directory)</span>

    <span class="s2">return </span><span class="s1">dist</span>


<span class="s2">def </span><span class="s1">_apply_project_table(dist: </span><span class="s4">&quot;Distribution&quot;</span><span class="s2">, </span><span class="s1">config: dict</span><span class="s2">, </span><span class="s1">root_dir: _Path):</span>
    <span class="s1">project_table = config.get(</span><span class="s4">&quot;project&quot;</span><span class="s2">, </span><span class="s1">{}).copy()</span>
    <span class="s2">if not </span><span class="s1">project_table:</span>
        <span class="s2">return  </span><span class="s3"># short-circuit</span>

    <span class="s1">_handle_missing_dynamic(dist</span><span class="s2">, </span><span class="s1">project_table)</span>
    <span class="s1">_unify_entry_points(project_table)</span>

    <span class="s2">for </span><span class="s1">field</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">project_table.items():</span>
        <span class="s1">norm_key = json_compatible_key(field)</span>
        <span class="s1">corresp = PYPROJECT_CORRESPONDENCE.get(norm_key</span><span class="s2">, </span><span class="s1">norm_key)</span>
        <span class="s2">if </span><span class="s1">callable(corresp):</span>
            <span class="s1">corresp(dist</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">root_dir)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">_set_config(dist</span><span class="s2">, </span><span class="s1">corresp</span><span class="s2">, </span><span class="s1">value)</span>


<span class="s2">def </span><span class="s1">_apply_tool_table(dist: </span><span class="s4">&quot;Distribution&quot;</span><span class="s2">, </span><span class="s1">config: dict</span><span class="s2">, </span><span class="s1">filename: _Path):</span>
    <span class="s1">tool_table = config.get(</span><span class="s4">&quot;tool&quot;</span><span class="s2">, </span><span class="s1">{}).get(</span><span class="s4">&quot;setuptools&quot;</span><span class="s2">, </span><span class="s1">{})</span>
    <span class="s2">if not </span><span class="s1">tool_table:</span>
        <span class="s2">return  </span><span class="s3"># short-circuit</span>

    <span class="s2">for </span><span class="s1">field</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">tool_table.items():</span>
        <span class="s1">norm_key = json_compatible_key(field)</span>

        <span class="s2">if </span><span class="s1">norm_key </span><span class="s2">in </span><span class="s1">TOOL_TABLE_DEPRECATIONS:</span>
            <span class="s1">suggestion = TOOL_TABLE_DEPRECATIONS[norm_key]</span>
            <span class="s1">msg = </span><span class="s4">f&quot;The parameter `</span><span class="s2">{</span><span class="s1">norm_key</span><span class="s2">}</span><span class="s4">` is deprecated, </span><span class="s2">{</span><span class="s1">suggestion</span><span class="s2">}</span><span class="s4">&quot;</span>
            <span class="s1">warnings.warn(msg</span><span class="s2">, </span><span class="s1">SetuptoolsDeprecationWarning)</span>

        <span class="s1">norm_key = TOOL_TABLE_RENAMES.get(norm_key</span><span class="s2">, </span><span class="s1">norm_key)</span>
        <span class="s1">_set_config(dist</span><span class="s2">, </span><span class="s1">norm_key</span><span class="s2">, </span><span class="s1">value)</span>

    <span class="s1">_copy_command_options(config</span><span class="s2">, </span><span class="s1">dist</span><span class="s2">, </span><span class="s1">filename)</span>


<span class="s2">def </span><span class="s1">_handle_missing_dynamic(dist: </span><span class="s4">&quot;Distribution&quot;</span><span class="s2">, </span><span class="s1">project_table: dict):</span>
    <span class="s0">&quot;&quot;&quot;Be temporarily forgiving with ``dynamic`` fields not listed in ``dynamic``&quot;&quot;&quot;</span>
    <span class="s3"># TODO: Set fields back to `None` once the feature stabilizes</span>
    <span class="s1">dynamic = set(project_table.get(</span><span class="s4">&quot;dynamic&quot;</span><span class="s2">, </span><span class="s1">[]))</span>
    <span class="s2">for </span><span class="s1">field</span><span class="s2">, </span><span class="s1">getter </span><span class="s2">in </span><span class="s1">_PREVIOUSLY_DEFINED.items():</span>
        <span class="s2">if not </span><span class="s1">(field </span><span class="s2">in </span><span class="s1">project_table </span><span class="s2">or </span><span class="s1">field </span><span class="s2">in </span><span class="s1">dynamic):</span>
            <span class="s1">value = getter(dist)</span>
            <span class="s2">if </span><span class="s1">value:</span>
                <span class="s1">msg = _WouldIgnoreField.message(field</span><span class="s2">, </span><span class="s1">value)</span>
                <span class="s1">warnings.warn(msg</span><span class="s2">, </span><span class="s1">_WouldIgnoreField)</span>


<span class="s2">def </span><span class="s1">json_compatible_key(key: str) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;As defined in :pep:`566#json-compatible-metadata`&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">key.lower().replace(</span><span class="s4">&quot;-&quot;</span><span class="s2">, </span><span class="s4">&quot;_&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_set_config(dist: </span><span class="s4">&quot;Distribution&quot;</span><span class="s2">, </span><span class="s1">field: str</span><span class="s2">, </span><span class="s1">value: Any):</span>
    <span class="s1">setter = getattr(dist.metadata</span><span class="s2">, </span><span class="s4">f&quot;set_</span><span class="s2">{</span><span class="s1">field</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">setter:</span>
        <span class="s1">setter(value)</span>
    <span class="s2">elif </span><span class="s1">hasattr(dist.metadata</span><span class="s2">, </span><span class="s1">field) </span><span class="s2">or </span><span class="s1">field </span><span class="s2">in </span><span class="s1">SETUPTOOLS_PATCHES:</span>
        <span class="s1">setattr(dist.metadata</span><span class="s2">, </span><span class="s1">field</span><span class="s2">, </span><span class="s1">value)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">setattr(dist</span><span class="s2">, </span><span class="s1">field</span><span class="s2">, </span><span class="s1">value)</span>


<span class="s1">_CONTENT_TYPES = {</span>
    <span class="s4">&quot;.md&quot;</span><span class="s1">: </span><span class="s4">&quot;text/markdown&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;.rst&quot;</span><span class="s1">: </span><span class="s4">&quot;text/x-rst&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;.txt&quot;</span><span class="s1">: </span><span class="s4">&quot;text/plain&quot;</span><span class="s2">,</span>
<span class="s1">}</span>


<span class="s2">def </span><span class="s1">_guess_content_type(file: str) -&gt; Optional[str]:</span>
    <span class="s1">_</span><span class="s2">, </span><span class="s1">ext = os.path.splitext(file.lower())</span>
    <span class="s2">if not </span><span class="s1">ext:</span>
        <span class="s2">return None</span>

    <span class="s2">if </span><span class="s1">ext </span><span class="s2">in </span><span class="s1">_CONTENT_TYPES:</span>
        <span class="s2">return </span><span class="s1">_CONTENT_TYPES[ext]</span>

    <span class="s1">valid = </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">k</span><span class="s2">} </span><span class="s4">(</span><span class="s2">{</span><span class="s1">v</span><span class="s2">}</span><span class="s4">)&quot; </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">_CONTENT_TYPES.items())</span>
    <span class="s1">msg = </span><span class="s4">f&quot;only the following file extensions are recognized: </span><span class="s2">{</span><span class="s1">valid</span><span class="s2">}</span><span class="s4">.&quot;</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Undefined content type for </span><span class="s2">{</span><span class="s1">file</span><span class="s2">}</span><span class="s4">, </span><span class="s2">{</span><span class="s1">msg</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_long_description(dist: </span><span class="s4">&quot;Distribution&quot;</span><span class="s2">, </span><span class="s1">val: _DictOrStr</span><span class="s2">, </span><span class="s1">root_dir: _Path):</span>
    <span class="s2">from </span><span class="s1">setuptools.config </span><span class="s2">import </span><span class="s1">expand</span>

    <span class="s2">if </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s1">text = expand.read_files(val</span><span class="s2">, </span><span class="s1">root_dir)</span>
        <span class="s1">ctype = _guess_content_type(val)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">text = val.get(</span><span class="s4">&quot;text&quot;</span><span class="s1">) </span><span class="s2">or </span><span class="s1">expand.read_files(val.get(</span><span class="s4">&quot;file&quot;</span><span class="s2">, </span><span class="s1">[])</span><span class="s2">, </span><span class="s1">root_dir)</span>
        <span class="s1">ctype = val[</span><span class="s4">&quot;content-type&quot;</span><span class="s1">]</span>

    <span class="s1">_set_config(dist</span><span class="s2">, </span><span class="s4">&quot;long_description&quot;</span><span class="s2">, </span><span class="s1">text)</span>
    <span class="s2">if </span><span class="s1">ctype:</span>
        <span class="s1">_set_config(dist</span><span class="s2">, </span><span class="s4">&quot;long_description_content_type&quot;</span><span class="s2">, </span><span class="s1">ctype)</span>


<span class="s2">def </span><span class="s1">_license(dist: </span><span class="s4">&quot;Distribution&quot;</span><span class="s2">, </span><span class="s1">val: dict</span><span class="s2">, </span><span class="s1">root_dir: _Path):</span>
    <span class="s2">from </span><span class="s1">setuptools.config </span><span class="s2">import </span><span class="s1">expand</span>

    <span class="s2">if </span><span class="s4">&quot;file&quot; </span><span class="s2">in </span><span class="s1">val:</span>
        <span class="s1">_set_config(dist</span><span class="s2">, </span><span class="s4">&quot;license&quot;</span><span class="s2">, </span><span class="s1">expand.read_files([val[</span><span class="s4">&quot;file&quot;</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">root_dir))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">_set_config(dist</span><span class="s2">, </span><span class="s4">&quot;license&quot;</span><span class="s2">, </span><span class="s1">val[</span><span class="s4">&quot;text&quot;</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">_people(dist: </span><span class="s4">&quot;Distribution&quot;</span><span class="s2">, </span><span class="s1">val: List[dict]</span><span class="s2">, </span><span class="s1">_root_dir: _Path</span><span class="s2">, </span><span class="s1">kind: str):</span>
    <span class="s1">field = []</span>
    <span class="s1">email_field = []</span>
    <span class="s2">for </span><span class="s1">person </span><span class="s2">in </span><span class="s1">val:</span>
        <span class="s2">if </span><span class="s4">&quot;name&quot; </span><span class="s2">not in </span><span class="s1">person:</span>
            <span class="s1">email_field.append(person[</span><span class="s4">&quot;email&quot;</span><span class="s1">])</span>
        <span class="s2">elif </span><span class="s4">&quot;email&quot; </span><span class="s2">not in </span><span class="s1">person:</span>
            <span class="s1">field.append(person[</span><span class="s4">&quot;name&quot;</span><span class="s1">])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">addr = Address(display_name=person[</span><span class="s4">&quot;name&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">addr_spec=person[</span><span class="s4">&quot;email&quot;</span><span class="s1">])</span>
            <span class="s1">email_field.append(str(addr))</span>

    <span class="s2">if </span><span class="s1">field:</span>
        <span class="s1">_set_config(dist</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">, </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(field))</span>
    <span class="s2">if </span><span class="s1">email_field:</span>
        <span class="s1">_set_config(dist</span><span class="s2">, </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">kind</span><span class="s2">}</span><span class="s4">_email&quot;</span><span class="s2">, </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(email_field))</span>


<span class="s2">def </span><span class="s1">_project_urls(dist: </span><span class="s4">&quot;Distribution&quot;</span><span class="s2">, </span><span class="s1">val: dict</span><span class="s2">, </span><span class="s1">_root_dir):</span>
    <span class="s1">_set_config(dist</span><span class="s2">, </span><span class="s4">&quot;project_urls&quot;</span><span class="s2">, </span><span class="s1">val)</span>


<span class="s2">def </span><span class="s1">_python_requires(dist: </span><span class="s4">&quot;Distribution&quot;</span><span class="s2">, </span><span class="s1">val: dict</span><span class="s2">, </span><span class="s1">_root_dir):</span>
    <span class="s2">from </span><span class="s1">setuptools.extern.packaging.specifiers </span><span class="s2">import </span><span class="s1">SpecifierSet</span>

    <span class="s1">_set_config(dist</span><span class="s2">, </span><span class="s4">&quot;python_requires&quot;</span><span class="s2">, </span><span class="s1">SpecifierSet(val))</span>


<span class="s2">def </span><span class="s1">_dependencies(dist: </span><span class="s4">&quot;Distribution&quot;</span><span class="s2">, </span><span class="s1">val: list</span><span class="s2">, </span><span class="s1">_root_dir):</span>
    <span class="s2">if </span><span class="s1">getattr(dist</span><span class="s2">, </span><span class="s4">&quot;install_requires&quot;</span><span class="s2">, </span><span class="s1">[]):</span>
        <span class="s1">msg = </span><span class="s4">&quot;`install_requires` overwritten in `pyproject.toml` (dependencies)&quot;</span>
        <span class="s1">warnings.warn(msg)</span>
    <span class="s1">_set_config(dist</span><span class="s2">, </span><span class="s4">&quot;install_requires&quot;</span><span class="s2">, </span><span class="s1">val)</span>


<span class="s2">def </span><span class="s1">_optional_dependencies(dist: </span><span class="s4">&quot;Distribution&quot;</span><span class="s2">, </span><span class="s1">val: dict</span><span class="s2">, </span><span class="s1">_root_dir):</span>
    <span class="s1">existing = getattr(dist</span><span class="s2">, </span><span class="s4">&quot;extras_require&quot;</span><span class="s2">, </span><span class="s1">{})</span>
    <span class="s1">_set_config(dist</span><span class="s2">, </span><span class="s4">&quot;extras_require&quot;</span><span class="s2">, </span><span class="s1">{**existing</span><span class="s2">, </span><span class="s1">**val})</span>


<span class="s2">def </span><span class="s1">_unify_entry_points(project_table: dict):</span>
    <span class="s1">project = project_table</span>
    <span class="s1">entry_points = project.pop(</span><span class="s4">&quot;entry-points&quot;</span><span class="s2">, </span><span class="s1">project.pop(</span><span class="s4">&quot;entry_points&quot;</span><span class="s2">, </span><span class="s1">{}))</span>
    <span class="s1">renaming = {</span><span class="s4">&quot;scripts&quot;</span><span class="s1">: </span><span class="s4">&quot;console_scripts&quot;</span><span class="s2">, </span><span class="s4">&quot;gui_scripts&quot;</span><span class="s1">: </span><span class="s4">&quot;gui_scripts&quot;</span><span class="s1">}</span>
    <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">list(project.items()):  </span><span class="s3"># eager to allow modifications</span>
        <span class="s1">norm_key = json_compatible_key(key)</span>
        <span class="s2">if </span><span class="s1">norm_key </span><span class="s2">in </span><span class="s1">renaming </span><span class="s2">and </span><span class="s1">value:</span>
            <span class="s1">entry_points[renaming[norm_key]] = project.pop(key)</span>

    <span class="s2">if </span><span class="s1">entry_points:</span>
        <span class="s1">project[</span><span class="s4">&quot;entry-points&quot;</span><span class="s1">] = {</span>
            <span class="s1">name: [</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">k</span><span class="s2">} </span><span class="s4">= </span><span class="s2">{</span><span class="s1">v</span><span class="s2">}</span><span class="s4">&quot; </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">group.items()]</span>
            <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">group </span><span class="s2">in </span><span class="s1">entry_points.items()</span>
        <span class="s1">}</span>


<span class="s2">def </span><span class="s1">_copy_command_options(pyproject: dict</span><span class="s2">, </span><span class="s1">dist: </span><span class="s4">&quot;Distribution&quot;</span><span class="s2">, </span><span class="s1">filename: _Path):</span>
    <span class="s1">tool_table = pyproject.get(</span><span class="s4">&quot;tool&quot;</span><span class="s2">, </span><span class="s1">{})</span>
    <span class="s1">cmdclass = tool_table.get(</span><span class="s4">&quot;setuptools&quot;</span><span class="s2">, </span><span class="s1">{}).get(</span><span class="s4">&quot;cmdclass&quot;</span><span class="s2">, </span><span class="s1">{})</span>
    <span class="s1">valid_options = _valid_command_options(cmdclass)</span>

    <span class="s1">cmd_opts = dist.command_options</span>
    <span class="s2">for </span><span class="s1">cmd</span><span class="s2">, </span><span class="s1">config </span><span class="s2">in </span><span class="s1">pyproject.get(</span><span class="s4">&quot;tool&quot;</span><span class="s2">, </span><span class="s1">{}).get(</span><span class="s4">&quot;distutils&quot;</span><span class="s2">, </span><span class="s1">{}).items():</span>
        <span class="s1">cmd = json_compatible_key(cmd)</span>
        <span class="s1">valid = valid_options.get(cmd</span><span class="s2">, </span><span class="s1">set())</span>
        <span class="s1">cmd_opts.setdefault(cmd</span><span class="s2">, </span><span class="s1">{})</span>
        <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">config.items():</span>
            <span class="s1">key = json_compatible_key(key)</span>
            <span class="s1">cmd_opts[cmd][key] = (str(filename)</span><span class="s2">, </span><span class="s1">value)</span>
            <span class="s2">if </span><span class="s1">key </span><span class="s2">not in </span><span class="s1">valid:</span>
                <span class="s3"># To avoid removing options that are specified dynamically we</span>
                <span class="s3"># just log a warn...</span>
                <span class="s1">_logger.warning(</span><span class="s4">f&quot;Command option </span><span class="s2">{</span><span class="s1">cmd</span><span class="s2">}</span><span class="s4">.</span><span class="s2">{</span><span class="s1">key</span><span class="s2">} </span><span class="s4">is not defined&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_valid_command_options(cmdclass: Mapping = EMPTY) -&gt; Dict[str</span><span class="s2">, </span><span class="s1">Set[str]]:</span>
    <span class="s2">from </span><span class="s1">.._importlib </span><span class="s2">import </span><span class="s1">metadata</span>
    <span class="s2">from </span><span class="s1">setuptools.dist </span><span class="s2">import </span><span class="s1">Distribution</span>

    <span class="s1">valid_options = {</span><span class="s4">&quot;global&quot;</span><span class="s1">: _normalise_cmd_options(Distribution.global_options)}</span>

    <span class="s1">unloaded_entry_points = metadata.entry_points(group=</span><span class="s4">'distutils.commands'</span><span class="s1">)</span>
    <span class="s1">loaded_entry_points = (_load_ep(ep) </span><span class="s2">for </span><span class="s1">ep </span><span class="s2">in </span><span class="s1">unloaded_entry_points)</span>
    <span class="s1">entry_points = (ep </span><span class="s2">for </span><span class="s1">ep </span><span class="s2">in </span><span class="s1">loaded_entry_points </span><span class="s2">if </span><span class="s1">ep)</span>
    <span class="s2">for </span><span class="s1">cmd</span><span class="s2">, </span><span class="s1">cmd_class </span><span class="s2">in </span><span class="s1">chain(entry_points</span><span class="s2">, </span><span class="s1">cmdclass.items()):</span>
        <span class="s1">opts = valid_options.get(cmd</span><span class="s2">, </span><span class="s1">set())</span>
        <span class="s1">opts = opts | _normalise_cmd_options(getattr(cmd_class</span><span class="s2">, </span><span class="s4">&quot;user_options&quot;</span><span class="s2">, </span><span class="s1">[]))</span>
        <span class="s1">valid_options[cmd] = opts</span>

    <span class="s2">return </span><span class="s1">valid_options</span>


<span class="s2">def </span><span class="s1">_load_ep(ep: </span><span class="s4">&quot;metadata.EntryPoint&quot;</span><span class="s1">) -&gt; Optional[Tuple[str</span><span class="s2">, </span><span class="s1">Type]]:</span>
    <span class="s3"># Ignore all the errors</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">(ep.name</span><span class="s2">, </span><span class="s1">ep.load())</span>
    <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">ex:</span>
        <span class="s1">msg = </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">ex.__class__.__name__</span><span class="s2">} </span><span class="s4">while trying to load entry-point </span><span class="s2">{</span><span class="s1">ep.name</span><span class="s2">}</span><span class="s4">&quot;</span>
        <span class="s1">_logger.warning(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">msg</span><span class="s2">}</span><span class="s4">: </span><span class="s2">{</span><span class="s1">ex</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s2">return None</span>


<span class="s2">def </span><span class="s1">_normalise_cmd_option_key(name: str) -&gt; str:</span>
    <span class="s2">return </span><span class="s1">json_compatible_key(name).strip(</span><span class="s4">&quot;_=&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_normalise_cmd_options(desc: List[Tuple[str</span><span class="s2">, </span><span class="s1">Optional[str]</span><span class="s2">, </span><span class="s1">str]]) -&gt; Set[str]:</span>
    <span class="s2">return </span><span class="s1">{_normalise_cmd_option_key(fancy_option[</span><span class="s5">0</span><span class="s1">]) </span><span class="s2">for </span><span class="s1">fancy_option </span><span class="s2">in </span><span class="s1">desc}</span>


<span class="s2">def </span><span class="s1">_attrgetter(attr):</span>
    <span class="s0">&quot;&quot;&quot; 
    Similar to ``operator.attrgetter`` but returns None if ``attr`` is not found 
    &gt;&gt;&gt; from types import SimpleNamespace 
    &gt;&gt;&gt; obj = SimpleNamespace(a=42, b=SimpleNamespace(c=13)) 
    &gt;&gt;&gt; _attrgetter(&quot;a&quot;)(obj) 
    42 
    &gt;&gt;&gt; _attrgetter(&quot;b.c&quot;)(obj) 
    13 
    &gt;&gt;&gt; _attrgetter(&quot;d&quot;)(obj) is None 
    True 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">partial(reduce</span><span class="s2">, lambda </span><span class="s1">acc</span><span class="s2">, </span><span class="s1">x: getattr(acc</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">, </span><span class="s1">attr.split(</span><span class="s4">&quot;.&quot;</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">_some_attrgetter(*items):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the first &quot;truth-y&quot; attribute or None 
    &gt;&gt;&gt; from types import SimpleNamespace 
    &gt;&gt;&gt; obj = SimpleNamespace(a=42, b=SimpleNamespace(c=13)) 
    &gt;&gt;&gt; _some_attrgetter(&quot;d&quot;, &quot;a&quot;, &quot;b.c&quot;)(obj) 
    42 
    &gt;&gt;&gt; _some_attrgetter(&quot;d&quot;, &quot;e&quot;, &quot;b.c&quot;, &quot;a&quot;)(obj) 
    13 
    &gt;&gt;&gt; _some_attrgetter(&quot;d&quot;, &quot;e&quot;, &quot;f&quot;)(obj) is None 
    True 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">_acessor(obj):</span>
        <span class="s1">values = (_attrgetter(i)(obj) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">items)</span>
        <span class="s2">return </span><span class="s1">next((i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">values </span><span class="s2">if </span><span class="s1">i </span><span class="s2">is not None</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">_acessor</span>


<span class="s1">PYPROJECT_CORRESPONDENCE: Dict[str</span><span class="s2">, </span><span class="s1">_Correspondence] = {</span>
    <span class="s4">&quot;readme&quot;</span><span class="s1">: _long_description</span><span class="s2">,</span>
    <span class="s4">&quot;license&quot;</span><span class="s1">: _license</span><span class="s2">,</span>
    <span class="s4">&quot;authors&quot;</span><span class="s1">: partial(_people</span><span class="s2">, </span><span class="s1">kind=</span><span class="s4">&quot;author&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s4">&quot;maintainers&quot;</span><span class="s1">: partial(_people</span><span class="s2">, </span><span class="s1">kind=</span><span class="s4">&quot;maintainer&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s4">&quot;urls&quot;</span><span class="s1">: _project_urls</span><span class="s2">,</span>
    <span class="s4">&quot;dependencies&quot;</span><span class="s1">: _dependencies</span><span class="s2">,</span>
    <span class="s4">&quot;optional_dependencies&quot;</span><span class="s1">: _optional_dependencies</span><span class="s2">,</span>
    <span class="s4">&quot;requires_python&quot;</span><span class="s1">: _python_requires</span><span class="s2">,</span>
<span class="s1">}</span>

<span class="s1">TOOL_TABLE_RENAMES = {</span><span class="s4">&quot;script_files&quot;</span><span class="s1">: </span><span class="s4">&quot;scripts&quot;</span><span class="s1">}</span>
<span class="s1">TOOL_TABLE_DEPRECATIONS = {</span>
    <span class="s4">&quot;namespace_packages&quot;</span><span class="s1">: </span><span class="s4">&quot;consider using implicit namespaces instead (PEP 420).&quot;</span>
<span class="s1">}</span>

<span class="s1">SETUPTOOLS_PATCHES = {</span><span class="s4">&quot;long_description_content_type&quot;</span><span class="s2">, </span><span class="s4">&quot;project_urls&quot;</span><span class="s2">,</span>
                      <span class="s4">&quot;provides_extras&quot;</span><span class="s2">, </span><span class="s4">&quot;license_file&quot;</span><span class="s2">, </span><span class="s4">&quot;license_files&quot;</span><span class="s1">}</span>

<span class="s1">_PREVIOUSLY_DEFINED = {</span>
    <span class="s4">&quot;name&quot;</span><span class="s1">: _attrgetter(</span><span class="s4">&quot;metadata.name&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s4">&quot;version&quot;</span><span class="s1">: _attrgetter(</span><span class="s4">&quot;metadata.version&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s4">&quot;description&quot;</span><span class="s1">: _attrgetter(</span><span class="s4">&quot;metadata.description&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s4">&quot;readme&quot;</span><span class="s1">: _attrgetter(</span><span class="s4">&quot;metadata.long_description&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s4">&quot;requires-python&quot;</span><span class="s1">: _some_attrgetter(</span><span class="s4">&quot;python_requires&quot;</span><span class="s2">, </span><span class="s4">&quot;metadata.python_requires&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s4">&quot;license&quot;</span><span class="s1">: _attrgetter(</span><span class="s4">&quot;metadata.license&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s4">&quot;authors&quot;</span><span class="s1">: _some_attrgetter(</span><span class="s4">&quot;metadata.author&quot;</span><span class="s2">, </span><span class="s4">&quot;metadata.author_email&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s4">&quot;maintainers&quot;</span><span class="s1">: _some_attrgetter(</span><span class="s4">&quot;metadata.maintainer&quot;</span><span class="s2">, </span><span class="s4">&quot;metadata.maintainer_email&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s4">&quot;keywords&quot;</span><span class="s1">: _attrgetter(</span><span class="s4">&quot;metadata.keywords&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s4">&quot;classifiers&quot;</span><span class="s1">: _attrgetter(</span><span class="s4">&quot;metadata.classifiers&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s4">&quot;urls&quot;</span><span class="s1">: _attrgetter(</span><span class="s4">&quot;metadata.project_urls&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s4">&quot;entry-points&quot;</span><span class="s1">: _attrgetter(</span><span class="s4">&quot;entry_points&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s4">&quot;dependencies&quot;</span><span class="s1">: _some_attrgetter(</span><span class="s4">&quot;_orig_install_requires&quot;</span><span class="s2">, </span><span class="s4">&quot;install_requires&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s4">&quot;optional-dependencies&quot;</span><span class="s1">: _some_attrgetter(</span><span class="s4">&quot;_orig_extras_require&quot;</span><span class="s2">, </span><span class="s4">&quot;extras_require&quot;</span><span class="s1">)</span><span class="s2">,</span>
<span class="s1">}</span>


<span class="s2">class </span><span class="s1">_WouldIgnoreField(UserWarning):</span>
    <span class="s0">&quot;&quot;&quot;Inform users that ``pyproject.toml`` would overwrite previous metadata.&quot;&quot;&quot;</span>

    <span class="s1">MESSAGE = </span><span class="s4">&quot;&quot;&quot;</span><span class="s2">\ 
    </span><span class="s4">{field!r} defined outside of `pyproject.toml` would be ignored. 
    !!</span><span class="s2">\n\n</span>
    <span class="s4">########################################################################## 
    # configuration would be ignored/result in error due to `pyproject.toml` # 
    ########################################################################## 
 
    The following seems to be defined outside of `pyproject.toml`: 
 
    `{field} = {value!r}` 
 
    According to the spec (see the link below), however, setuptools CANNOT 
    consider this value unless {field!r} is listed as `dynamic`. 
 
    https://packaging.python.org/en/latest/specifications/declaring-project-metadata/ 
 
    For the time being, `setuptools` will still consider the given value (as a 
    **transitional** measure), but please note that future releases of setuptools will 
    follow strictly the standard. 
 
    To prevent this warning, you can list {field!r} under `dynamic` or alternatively 
    remove the `[project]` table from your file and rely entirely on other means of 
    configuration. 
    </span><span class="s2">\n\n</span><span class="s4">!! 
    &quot;&quot;&quot;</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">message(cls</span><span class="s2">, </span><span class="s1">field</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s2">from </span><span class="s1">inspect </span><span class="s2">import </span><span class="s1">cleandoc</span>
        <span class="s2">return </span><span class="s1">cleandoc(cls.MESSAGE.format(field=field</span><span class="s2">, </span><span class="s1">value=value))</span>
</pre>
</body>
</html>