<html>
<head>
<title>core.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
core.py</font>
</center></td></tr></table>
<pre><span class="s0">#</span>
<span class="s0"># core.py</span>
<span class="s0">#</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">typing</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">NamedTuple</span><span class="s2">,</span>
    <span class="s1">Union</span><span class="s2">,</span>
    <span class="s1">Callable</span><span class="s2">,</span>
    <span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">Generator</span><span class="s2">,</span>
    <span class="s1">Tuple</span><span class="s2">,</span>
    <span class="s1">List</span><span class="s2">,</span>
    <span class="s1">TextIO</span><span class="s2">,</span>
    <span class="s1">Set</span><span class="s2">,</span>
    <span class="s1">Sequence</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">abc </span><span class="s2">import </span><span class="s1">ABC</span><span class="s2">, </span><span class="s1">abstractmethod</span>
<span class="s2">from </span><span class="s1">enum </span><span class="s2">import </span><span class="s1">Enum</span>
<span class="s2">import </span><span class="s1">string</span>
<span class="s2">import </span><span class="s1">copy</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">from </span><span class="s1">collections.abc </span><span class="s2">import </span><span class="s1">Iterable</span>
<span class="s2">import </span><span class="s1">traceback</span>
<span class="s2">import </span><span class="s1">types</span>
<span class="s2">from </span><span class="s1">operator </span><span class="s2">import </span><span class="s1">itemgetter</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">wraps</span>
<span class="s2">from </span><span class="s1">threading </span><span class="s2">import </span><span class="s1">RLock</span>
<span class="s2">from </span><span class="s1">pathlib </span><span class="s2">import </span><span class="s1">Path</span>

<span class="s2">from </span><span class="s1">.util </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">_FifoCache</span><span class="s2">,</span>
    <span class="s1">_UnboundedCache</span><span class="s2">,</span>
    <span class="s1">__config_flags</span><span class="s2">,</span>
    <span class="s1">_collapse_string_to_ranges</span><span class="s2">,</span>
    <span class="s1">_escape_regex_range_chars</span><span class="s2">,</span>
    <span class="s1">_bslash</span><span class="s2">,</span>
    <span class="s1">_flatten</span><span class="s2">,</span>
    <span class="s1">LRUMemo </span><span class="s2">as </span><span class="s1">_LRUMemo</span><span class="s2">,</span>
    <span class="s1">UnboundedMemo </span><span class="s2">as </span><span class="s1">_UnboundedMemo</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">.exceptions </span><span class="s2">import </span><span class="s1">*</span>
<span class="s2">from </span><span class="s1">.actions </span><span class="s2">import </span><span class="s1">*</span>
<span class="s2">from </span><span class="s1">.results </span><span class="s2">import </span><span class="s1">ParseResults</span><span class="s2">, </span><span class="s1">_ParseResultsWithOffset</span>
<span class="s2">from </span><span class="s1">.unicode </span><span class="s2">import </span><span class="s1">pyparsing_unicode</span>

<span class="s1">_MAX_INT = sys.maxsize</span>
<span class="s1">str_type: Tuple[type</span><span class="s2">, </span><span class="s1">...] = (str</span><span class="s2">, </span><span class="s1">bytes)</span>

<span class="s0">#</span>
<span class="s0"># Copyright (c) 2003-2022  Paul T. McGuire</span>
<span class="s0">#</span>
<span class="s0"># Permission is hereby granted, free of charge, to any person obtaining</span>
<span class="s0"># a copy of this software and associated documentation files (the</span>
<span class="s0"># &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="s0"># without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="s0"># distribute, sublicense, and/or sell copies of the Software, and to</span>
<span class="s0"># permit persons to whom the Software is furnished to do so, subject to</span>
<span class="s0"># the following conditions:</span>
<span class="s0">#</span>
<span class="s0"># The above copyright notice and this permission notice shall be</span>
<span class="s0"># included in all copies or substantial portions of the Software.</span>
<span class="s0">#</span>
<span class="s0"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="s0"># EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="s0"># MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.</span>
<span class="s0"># IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY</span>
<span class="s0"># CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,</span>
<span class="s0"># TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE</span>
<span class="s0"># SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="s0">#</span>


<span class="s2">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s3">3</span><span class="s2">, </span><span class="s3">8</span><span class="s1">):</span>
    <span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">cached_property</span>
<span class="s2">else</span><span class="s1">:</span>

    <span class="s2">class </span><span class="s1">cached_property:</span>
        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">func):</span>
            <span class="s1">self._func = func</span>

        <span class="s2">def </span><span class="s1">__get__(self</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">owner=</span><span class="s2">None</span><span class="s1">):</span>
            <span class="s1">ret = instance.__dict__[self._func.__name__] = self._func(instance)</span>
            <span class="s2">return </span><span class="s1">ret</span>


<span class="s2">class </span><span class="s1">__compat__(__config_flags):</span>
    <span class="s4">&quot;&quot;&quot; 
    A cross-version compatibility configuration for pyparsing features that will be 
    released in a future version. By setting values in this configuration to True, 
    those features can be enabled in prior versions for compatibility development 
    and testing. 
 
    - ``collect_all_And_tokens`` - flag to enable fix for Issue #63 that fixes erroneous grouping 
      of results names when an :class:`And` expression is nested within an :class:`Or` or :class:`MatchFirst`; 
      maintained for compatibility, but setting to ``False`` no longer restores pre-2.3.1 
      behavior 
    &quot;&quot;&quot;</span>

    <span class="s1">_type_desc = </span><span class="s5">&quot;compatibility&quot;</span>

    <span class="s1">collect_all_And_tokens = </span><span class="s2">True</span>

    <span class="s1">_all_names = [__ </span><span class="s2">for </span><span class="s1">__ </span><span class="s2">in </span><span class="s1">locals() </span><span class="s2">if not </span><span class="s1">__.startswith(</span><span class="s5">&quot;_&quot;</span><span class="s1">)]</span>
    <span class="s1">_fixed_names = </span><span class="s5">&quot;&quot;&quot; 
        collect_all_And_tokens 
        &quot;&quot;&quot;</span><span class="s1">.split()</span>


<span class="s2">class </span><span class="s1">__diag__(__config_flags):</span>
    <span class="s1">_type_desc = </span><span class="s5">&quot;diagnostic&quot;</span>

    <span class="s1">warn_multiple_tokens_in_named_alternation = </span><span class="s2">False</span>
    <span class="s1">warn_ungrouped_named_tokens_in_collection = </span><span class="s2">False</span>
    <span class="s1">warn_name_set_on_empty_Forward = </span><span class="s2">False</span>
    <span class="s1">warn_on_parse_using_empty_Forward = </span><span class="s2">False</span>
    <span class="s1">warn_on_assignment_to_Forward = </span><span class="s2">False</span>
    <span class="s1">warn_on_multiple_string_args_to_oneof = </span><span class="s2">False</span>
    <span class="s1">warn_on_match_first_with_lshift_operator = </span><span class="s2">False</span>
    <span class="s1">enable_debug_on_named_expressions = </span><span class="s2">False</span>

    <span class="s1">_all_names = [__ </span><span class="s2">for </span><span class="s1">__ </span><span class="s2">in </span><span class="s1">locals() </span><span class="s2">if not </span><span class="s1">__.startswith(</span><span class="s5">&quot;_&quot;</span><span class="s1">)]</span>
    <span class="s1">_warning_names = [name </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">_all_names </span><span class="s2">if </span><span class="s1">name.startswith(</span><span class="s5">&quot;warn&quot;</span><span class="s1">)]</span>
    <span class="s1">_debug_names = [name </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">_all_names </span><span class="s2">if </span><span class="s1">name.startswith(</span><span class="s5">&quot;enable_debug&quot;</span><span class="s1">)]</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">enable_all_warnings(cls) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">cls._warning_names:</span>
            <span class="s1">cls.enable(name)</span>


<span class="s2">class </span><span class="s1">Diagnostics(Enum):</span>
    <span class="s4">&quot;&quot;&quot; 
    Diagnostic configuration (all default to disabled) 
    - ``warn_multiple_tokens_in_named_alternation`` - flag to enable warnings when a results 
      name is defined on a :class:`MatchFirst` or :class:`Or` expression with one or more :class:`And` subexpressions 
    - ``warn_ungrouped_named_tokens_in_collection`` - flag to enable warnings when a results 
      name is defined on a containing expression with ungrouped subexpressions that also 
      have results names 
    - ``warn_name_set_on_empty_Forward`` - flag to enable warnings when a :class:`Forward` is defined 
      with a results name, but has no contents defined 
    - ``warn_on_parse_using_empty_Forward`` - flag to enable warnings when a :class:`Forward` is 
      defined in a grammar but has never had an expression attached to it 
    - ``warn_on_assignment_to_Forward`` - flag to enable warnings when a :class:`Forward` is defined 
      but is overwritten by assigning using ``'='`` instead of ``'&lt;&lt;='`` or ``'&lt;&lt;'`` 
    - ``warn_on_multiple_string_args_to_oneof`` - flag to enable warnings when :class:`one_of` is 
      incorrectly called with multiple str arguments 
    - ``enable_debug_on_named_expressions`` - flag to auto-enable debug on all subsequent 
      calls to :class:`ParserElement.set_name` 
 
    Diagnostics are enabled/disabled by calling :class:`enable_diag` and :class:`disable_diag`. 
    All warnings can be enabled by calling :class:`enable_all_warnings`. 
    &quot;&quot;&quot;</span>

    <span class="s1">warn_multiple_tokens_in_named_alternation = </span><span class="s3">0</span>
    <span class="s1">warn_ungrouped_named_tokens_in_collection = </span><span class="s3">1</span>
    <span class="s1">warn_name_set_on_empty_Forward = </span><span class="s3">2</span>
    <span class="s1">warn_on_parse_using_empty_Forward = </span><span class="s3">3</span>
    <span class="s1">warn_on_assignment_to_Forward = </span><span class="s3">4</span>
    <span class="s1">warn_on_multiple_string_args_to_oneof = </span><span class="s3">5</span>
    <span class="s1">warn_on_match_first_with_lshift_operator = </span><span class="s3">6</span>
    <span class="s1">enable_debug_on_named_expressions = </span><span class="s3">7</span>


<span class="s2">def </span><span class="s1">enable_diag(diag_enum: Diagnostics) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Enable a global pyparsing diagnostic flag (see :class:`Diagnostics`). 
    &quot;&quot;&quot;</span>
    <span class="s1">__diag__.enable(diag_enum.name)</span>


<span class="s2">def </span><span class="s1">disable_diag(diag_enum: Diagnostics) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Disable a global pyparsing diagnostic flag (see :class:`Diagnostics`). 
    &quot;&quot;&quot;</span>
    <span class="s1">__diag__.disable(diag_enum.name)</span>


<span class="s2">def </span><span class="s1">enable_all_warnings() -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Enable all global pyparsing diagnostic warnings (see :class:`Diagnostics`). 
    &quot;&quot;&quot;</span>
    <span class="s1">__diag__.enable_all_warnings()</span>


<span class="s0"># hide abstract class</span>
<span class="s2">del </span><span class="s1">__config_flags</span>


<span class="s2">def </span><span class="s1">_should_enable_warnings(</span>
    <span class="s1">cmd_line_warn_options: typing.Iterable[str]</span><span class="s2">, </span><span class="s1">warn_env_var: typing.Optional[str]</span>
<span class="s1">) -&gt; bool:</span>
    <span class="s1">enable = bool(warn_env_var)</span>
    <span class="s2">for </span><span class="s1">warn_opt </span><span class="s2">in </span><span class="s1">cmd_line_warn_options:</span>
        <span class="s1">w_action</span><span class="s2">, </span><span class="s1">w_message</span><span class="s2">, </span><span class="s1">w_category</span><span class="s2">, </span><span class="s1">w_module</span><span class="s2">, </span><span class="s1">w_line = (warn_opt + </span><span class="s5">&quot;::::&quot;</span><span class="s1">).split(</span>
            <span class="s5">&quot;:&quot;</span>
        <span class="s1">)[:</span><span class="s3">5</span><span class="s1">]</span>
        <span class="s2">if not </span><span class="s1">w_action.lower().startswith(</span><span class="s5">&quot;i&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">(</span>
            <span class="s2">not </span><span class="s1">(w_message </span><span class="s2">or </span><span class="s1">w_category </span><span class="s2">or </span><span class="s1">w_module) </span><span class="s2">or </span><span class="s1">w_module == </span><span class="s5">&quot;pyparsing&quot;</span>
        <span class="s1">):</span>
            <span class="s1">enable = </span><span class="s2">True</span>
        <span class="s2">elif </span><span class="s1">w_action.lower().startswith(</span><span class="s5">&quot;i&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">w_module </span><span class="s2">in </span><span class="s1">(</span><span class="s5">&quot;pyparsing&quot;</span><span class="s2">, </span><span class="s5">&quot;&quot;</span><span class="s1">):</span>
            <span class="s1">enable = </span><span class="s2">False</span>
    <span class="s2">return </span><span class="s1">enable</span>


<span class="s2">if </span><span class="s1">_should_enable_warnings(</span>
    <span class="s1">sys.warnoptions</span><span class="s2">, </span><span class="s1">os.environ.get(</span><span class="s5">&quot;PYPARSINGENABLEALLWARNINGS&quot;</span><span class="s1">)</span>
<span class="s1">):</span>
    <span class="s1">enable_all_warnings()</span>


<span class="s0"># build list of single arg builtins, that can be used as parse actions</span>
<span class="s1">_single_arg_builtins = {</span>
    <span class="s1">sum</span><span class="s2">,</span>
    <span class="s1">len</span><span class="s2">,</span>
    <span class="s1">sorted</span><span class="s2">,</span>
    <span class="s1">reversed</span><span class="s2">,</span>
    <span class="s1">list</span><span class="s2">,</span>
    <span class="s1">tuple</span><span class="s2">,</span>
    <span class="s1">set</span><span class="s2">,</span>
    <span class="s1">any</span><span class="s2">,</span>
    <span class="s1">all</span><span class="s2">,</span>
    <span class="s1">min</span><span class="s2">,</span>
    <span class="s1">max</span><span class="s2">,</span>
<span class="s1">}</span>

<span class="s1">_generatorType = types.GeneratorType</span>
<span class="s1">ParseAction = Union[</span>
    <span class="s1">Callable[[]</span><span class="s2">, </span><span class="s1">Any]</span><span class="s2">,</span>
    <span class="s1">Callable[[ParseResults]</span><span class="s2">, </span><span class="s1">Any]</span><span class="s2">,</span>
    <span class="s1">Callable[[int</span><span class="s2">, </span><span class="s1">ParseResults]</span><span class="s2">, </span><span class="s1">Any]</span><span class="s2">,</span>
    <span class="s1">Callable[[str</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">ParseResults]</span><span class="s2">, </span><span class="s1">Any]</span><span class="s2">,</span>
<span class="s1">]</span>
<span class="s1">ParseCondition = Union[</span>
    <span class="s1">Callable[[]</span><span class="s2">, </span><span class="s1">bool]</span><span class="s2">,</span>
    <span class="s1">Callable[[ParseResults]</span><span class="s2">, </span><span class="s1">bool]</span><span class="s2">,</span>
    <span class="s1">Callable[[int</span><span class="s2">, </span><span class="s1">ParseResults]</span><span class="s2">, </span><span class="s1">bool]</span><span class="s2">,</span>
    <span class="s1">Callable[[str</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">ParseResults]</span><span class="s2">, </span><span class="s1">bool]</span><span class="s2">,</span>
<span class="s1">]</span>
<span class="s1">ParseFailAction = Callable[[str</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s5">&quot;ParserElement&quot;</span><span class="s2">, </span><span class="s1">Exception]</span><span class="s2">, None</span><span class="s1">]</span>
<span class="s1">DebugStartAction = Callable[[str</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s5">&quot;ParserElement&quot;</span><span class="s2">, </span><span class="s1">bool]</span><span class="s2">, None</span><span class="s1">]</span>
<span class="s1">DebugSuccessAction = Callable[</span>
    <span class="s1">[str</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s5">&quot;ParserElement&quot;</span><span class="s2">, </span><span class="s1">ParseResults</span><span class="s2">, </span><span class="s1">bool]</span><span class="s2">, None</span>
<span class="s1">]</span>
<span class="s1">DebugExceptionAction = Callable[[str</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s5">&quot;ParserElement&quot;</span><span class="s2">, </span><span class="s1">Exception</span><span class="s2">, </span><span class="s1">bool]</span><span class="s2">, None</span><span class="s1">]</span>


<span class="s1">alphas = string.ascii_uppercase + string.ascii_lowercase</span>
<span class="s1">identchars = pyparsing_unicode.Latin1.identchars</span>
<span class="s1">identbodychars = pyparsing_unicode.Latin1.identbodychars</span>
<span class="s1">nums = </span><span class="s5">&quot;0123456789&quot;</span>
<span class="s1">hexnums = nums + </span><span class="s5">&quot;ABCDEFabcdef&quot;</span>
<span class="s1">alphanums = alphas + nums</span>
<span class="s1">printables = </span><span class="s5">&quot;&quot;</span><span class="s1">.join([c </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">string.printable </span><span class="s2">if </span><span class="s1">c </span><span class="s2">not in </span><span class="s1">string.whitespace])</span>

<span class="s1">_trim_arity_call_line: traceback.StackSummary = </span><span class="s2">None</span>


<span class="s2">def </span><span class="s1">_trim_arity(func</span><span class="s2">, </span><span class="s1">max_limit=</span><span class="s3">3</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;decorator to trim function calls to match the arity of the target&quot;&quot;&quot;</span>
    <span class="s2">global </span><span class="s1">_trim_arity_call_line</span>

    <span class="s2">if </span><span class="s1">func </span><span class="s2">in </span><span class="s1">_single_arg_builtins:</span>
        <span class="s2">return lambda </span><span class="s1">s</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">t: func(t)</span>

    <span class="s1">limit = </span><span class="s3">0</span>
    <span class="s1">found_arity = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">extract_tb(tb</span><span class="s2">, </span><span class="s1">limit=</span><span class="s3">0</span><span class="s1">):</span>
        <span class="s1">frames = traceback.extract_tb(tb</span><span class="s2">, </span><span class="s1">limit=limit)</span>
        <span class="s1">frame_summary = frames[-</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">[frame_summary[:</span><span class="s3">2</span><span class="s1">]]</span>

    <span class="s0"># synthesize what would be returned by traceback.extract_stack at the call to</span>
    <span class="s0"># user's parse action 'func', so that we don't incur call penalty at parse time</span>

    <span class="s0"># fmt: off</span>
    <span class="s1">LINE_DIFF = </span><span class="s3">7</span>
    <span class="s0"># IF ANY CODE CHANGES, EVEN JUST COMMENTS OR BLANK LINES, BETWEEN THE NEXT LINE AND</span>
    <span class="s0"># THE CALL TO FUNC INSIDE WRAPPER, LINE_DIFF MUST BE MODIFIED!!!!</span>
    <span class="s1">_trim_arity_call_line = (_trim_arity_call_line </span><span class="s2">or </span><span class="s1">traceback.extract_stack(limit=</span><span class="s3">2</span><span class="s1">)[-</span><span class="s3">1</span><span class="s1">])</span>
    <span class="s1">pa_call_line_synth = (_trim_arity_call_line[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">_trim_arity_call_line[</span><span class="s3">1</span><span class="s1">] + LINE_DIFF)</span>

    <span class="s2">def </span><span class="s1">wrapper(*args):</span>
        <span class="s2">nonlocal </span><span class="s1">found_arity</span><span class="s2">, </span><span class="s1">limit</span>
        <span class="s2">while </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">ret = func(*args[limit:])</span>
                <span class="s1">found_arity = </span><span class="s2">True</span>
                <span class="s2">return </span><span class="s1">ret</span>
            <span class="s2">except </span><span class="s1">TypeError </span><span class="s2">as </span><span class="s1">te:</span>
                <span class="s0"># re-raise TypeErrors if they did not come from our arity testing</span>
                <span class="s2">if </span><span class="s1">found_arity:</span>
                    <span class="s2">raise</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">tb = te.__traceback__</span>
                    <span class="s1">trim_arity_type_error = (</span>
                        <span class="s1">extract_tb(tb</span><span class="s2">, </span><span class="s1">limit=</span><span class="s3">2</span><span class="s1">)[-</span><span class="s3">1</span><span class="s1">][:</span><span class="s3">2</span><span class="s1">] == pa_call_line_synth</span>
                    <span class="s1">)</span>
                    <span class="s2">del </span><span class="s1">tb</span>

                    <span class="s2">if </span><span class="s1">trim_arity_type_error:</span>
                        <span class="s2">if </span><span class="s1">limit &lt; max_limit:</span>
                            <span class="s1">limit += </span><span class="s3">1</span>
                            <span class="s2">continue</span>

                    <span class="s2">raise</span>
    <span class="s0"># fmt: on</span>

    <span class="s0"># copy func name to wrapper for sensible debug output</span>
    <span class="s0"># (can't use functools.wraps, since that messes with function signature)</span>
    <span class="s1">func_name = getattr(func</span><span class="s2">, </span><span class="s5">&quot;__name__&quot;</span><span class="s2">, </span><span class="s1">getattr(func</span><span class="s2">, </span><span class="s5">&quot;__class__&quot;</span><span class="s1">).__name__)</span>
    <span class="s1">wrapper.__name__ = func_name</span>
    <span class="s1">wrapper.__doc__ = func.__doc__</span>

    <span class="s2">return </span><span class="s1">wrapper</span>


<span class="s2">def </span><span class="s1">condition_as_parse_action(</span>
    <span class="s1">fn: ParseCondition</span><span class="s2">, </span><span class="s1">message: str = </span><span class="s2">None, </span><span class="s1">fatal: bool = </span><span class="s2">False</span>
<span class="s1">) -&gt; ParseAction:</span>
    <span class="s4">&quot;&quot;&quot; 
    Function to convert a simple predicate function that returns ``True`` or ``False`` 
    into a parse action. Can be used in places when a parse action is required 
    and :class:`ParserElement.add_condition` cannot be used (such as when adding a condition 
    to an operator level in :class:`infix_notation`). 
 
    Optional keyword arguments: 
 
    - ``message`` - define a custom message to be used in the raised exception 
    - ``fatal`` - if True, will raise :class:`ParseFatalException` to stop parsing immediately; 
      otherwise will raise :class:`ParseException` 
 
    &quot;&quot;&quot;</span>
    <span class="s1">msg = message </span><span class="s2">if </span><span class="s1">message </span><span class="s2">is not None else </span><span class="s5">&quot;failed user-defined condition&quot;</span>
    <span class="s1">exc_type = ParseFatalException </span><span class="s2">if </span><span class="s1">fatal </span><span class="s2">else </span><span class="s1">ParseException</span>
    <span class="s1">fn = _trim_arity(fn)</span>

    <span class="s1">@wraps(fn)</span>
    <span class="s2">def </span><span class="s1">pa(s</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s2">if not </span><span class="s1">bool(fn(s</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">t)):</span>
            <span class="s2">raise </span><span class="s1">exc_type(s</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">msg)</span>

    <span class="s2">return </span><span class="s1">pa</span>


<span class="s2">def </span><span class="s1">_default_start_debug_action(</span>
    <span class="s1">instring: str</span><span class="s2">, </span><span class="s1">loc: int</span><span class="s2">, </span><span class="s1">expr: </span><span class="s5">&quot;ParserElement&quot;</span><span class="s2">, </span><span class="s1">cache_hit: bool = </span><span class="s2">False</span>
<span class="s1">):</span>
    <span class="s1">cache_hit_str = </span><span class="s5">&quot;*&quot; </span><span class="s2">if </span><span class="s1">cache_hit </span><span class="s2">else </span><span class="s5">&quot;&quot;</span>
    <span class="s1">print(</span>
        <span class="s1">(</span>
            <span class="s5">&quot;{}Match {} at loc {}({},{})</span><span class="s2">\n  </span><span class="s5">{}</span><span class="s2">\n  </span><span class="s5">{}^&quot;</span><span class="s1">.format(</span>
                <span class="s1">cache_hit_str</span><span class="s2">,</span>
                <span class="s1">expr</span><span class="s2">,</span>
                <span class="s1">loc</span><span class="s2">,</span>
                <span class="s1">lineno(loc</span><span class="s2">, </span><span class="s1">instring)</span><span class="s2">,</span>
                <span class="s1">col(loc</span><span class="s2">, </span><span class="s1">instring)</span><span class="s2">,</span>
                <span class="s1">line(loc</span><span class="s2">, </span><span class="s1">instring)</span><span class="s2">,</span>
                <span class="s5">&quot; &quot; </span><span class="s1">* (col(loc</span><span class="s2">, </span><span class="s1">instring) - </span><span class="s3">1</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">_default_success_debug_action(</span>
    <span class="s1">instring: str</span><span class="s2">,</span>
    <span class="s1">startloc: int</span><span class="s2">,</span>
    <span class="s1">endloc: int</span><span class="s2">,</span>
    <span class="s1">expr: </span><span class="s5">&quot;ParserElement&quot;</span><span class="s2">,</span>
    <span class="s1">toks: ParseResults</span><span class="s2">,</span>
    <span class="s1">cache_hit: bool = </span><span class="s2">False,</span>
<span class="s1">):</span>
    <span class="s1">cache_hit_str = </span><span class="s5">&quot;*&quot; </span><span class="s2">if </span><span class="s1">cache_hit </span><span class="s2">else </span><span class="s5">&quot;&quot;</span>
    <span class="s1">print(</span><span class="s5">&quot;{}Matched {} -&gt; {}&quot;</span><span class="s1">.format(cache_hit_str</span><span class="s2">, </span><span class="s1">expr</span><span class="s2">, </span><span class="s1">toks.as_list()))</span>


<span class="s2">def </span><span class="s1">_default_exception_debug_action(</span>
    <span class="s1">instring: str</span><span class="s2">,</span>
    <span class="s1">loc: int</span><span class="s2">,</span>
    <span class="s1">expr: </span><span class="s5">&quot;ParserElement&quot;</span><span class="s2">,</span>
    <span class="s1">exc: Exception</span><span class="s2">,</span>
    <span class="s1">cache_hit: bool = </span><span class="s2">False,</span>
<span class="s1">):</span>
    <span class="s1">cache_hit_str = </span><span class="s5">&quot;*&quot; </span><span class="s2">if </span><span class="s1">cache_hit </span><span class="s2">else </span><span class="s5">&quot;&quot;</span>
    <span class="s1">print(</span>
        <span class="s5">&quot;{}Match {} failed, {} raised: {}&quot;</span><span class="s1">.format(</span>
            <span class="s1">cache_hit_str</span><span class="s2">, </span><span class="s1">expr</span><span class="s2">, </span><span class="s1">type(exc).__name__</span><span class="s2">, </span><span class="s1">exc</span>
        <span class="s1">)</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">null_debug_action(*args):</span>
    <span class="s4">&quot;&quot;&quot;'Do-nothing' debug action, to suppress debugging output during parsing.&quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">ParserElement(ABC):</span>
    <span class="s4">&quot;&quot;&quot;Abstract base level parser element class.&quot;&quot;&quot;</span>

    <span class="s1">DEFAULT_WHITE_CHARS: str = </span><span class="s5">&quot; </span><span class="s2">\n\t\r</span><span class="s5">&quot;</span>
    <span class="s1">verbose_stacktrace: bool = </span><span class="s2">False</span>
    <span class="s1">_literalStringClass: typing.Optional[type] = </span><span class="s2">None</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">set_default_whitespace_chars(chars: str) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s4">r&quot;&quot;&quot; 
        Overrides the default whitespace chars 
 
        Example:: 
 
            # default whitespace chars are space, &lt;TAB&gt; and newline 
            Word(alphas)[1, ...].parse_string(&quot;abc def\nghi jkl&quot;)  # -&gt; ['abc', 'def', 'ghi', 'jkl'] 
 
            # change to just treat newline as significant 
            ParserElement.set_default_whitespace_chars(&quot; \t&quot;) 
            Word(alphas)[1, ...].parse_string(&quot;abc def\nghi jkl&quot;)  # -&gt; ['abc', 'def'] 
        &quot;&quot;&quot;</span>
        <span class="s1">ParserElement.DEFAULT_WHITE_CHARS = chars</span>

        <span class="s0"># update whitespace all parse expressions defined in this module</span>
        <span class="s2">for </span><span class="s1">expr </span><span class="s2">in </span><span class="s1">_builtin_exprs:</span>
            <span class="s2">if </span><span class="s1">expr.copyDefaultWhiteChars:</span>
                <span class="s1">expr.whiteChars = set(chars)</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">inline_literals_using(cls: type) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Set class to be used for inclusion of string literals into a parser. 
 
        Example:: 
 
            # default literal class used is Literal 
            integer = Word(nums) 
            date_str = integer(&quot;year&quot;) + '/' + integer(&quot;month&quot;) + '/' + integer(&quot;day&quot;) 
 
            date_str.parse_string(&quot;1999/12/31&quot;)  # -&gt; ['1999', '/', '12', '/', '31'] 
 
 
            # change to Suppress 
            ParserElement.inline_literals_using(Suppress) 
            date_str = integer(&quot;year&quot;) + '/' + integer(&quot;month&quot;) + '/' + integer(&quot;day&quot;) 
 
            date_str.parse_string(&quot;1999/12/31&quot;)  # -&gt; ['1999', '12', '31'] 
        &quot;&quot;&quot;</span>
        <span class="s1">ParserElement._literalStringClass = cls</span>

    <span class="s2">class </span><span class="s1">DebugActions(NamedTuple):</span>
        <span class="s1">debug_try: typing.Optional[DebugStartAction]</span>
        <span class="s1">debug_match: typing.Optional[DebugSuccessAction]</span>
        <span class="s1">debug_fail: typing.Optional[DebugExceptionAction]</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">savelist: bool = </span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">self.parseAction: List[ParseAction] = list()</span>
        <span class="s1">self.failAction: typing.Optional[ParseFailAction] = </span><span class="s2">None</span>
        <span class="s1">self.customName = </span><span class="s2">None</span>
        <span class="s1">self._defaultName = </span><span class="s2">None</span>
        <span class="s1">self.resultsName = </span><span class="s2">None</span>
        <span class="s1">self.saveAsList = savelist</span>
        <span class="s1">self.skipWhitespace = </span><span class="s2">True</span>
        <span class="s1">self.whiteChars = set(ParserElement.DEFAULT_WHITE_CHARS)</span>
        <span class="s1">self.copyDefaultWhiteChars = </span><span class="s2">True</span>
        <span class="s0"># used when checking for left-recursion</span>
        <span class="s1">self.mayReturnEmpty = </span><span class="s2">False</span>
        <span class="s1">self.keepTabs = </span><span class="s2">False</span>
        <span class="s1">self.ignoreExprs: List[</span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">] = list()</span>
        <span class="s1">self.debug = </span><span class="s2">False</span>
        <span class="s1">self.streamlined = </span><span class="s2">False</span>
        <span class="s0"># optimize exception handling for subclasses that don't advance parse index</span>
        <span class="s1">self.mayIndexError = </span><span class="s2">True</span>
        <span class="s1">self.errmsg = </span><span class="s5">&quot;&quot;</span>
        <span class="s0"># mark results names as modal (report only last) or cumulative (list all)</span>
        <span class="s1">self.modalResults = </span><span class="s2">True</span>
        <span class="s0"># custom debug actions</span>
        <span class="s1">self.debugActions = self.DebugActions(</span><span class="s2">None, None, None</span><span class="s1">)</span>
        <span class="s0"># avoid redundant calls to preParse</span>
        <span class="s1">self.callPreparse = </span><span class="s2">True</span>
        <span class="s1">self.callDuringTry = </span><span class="s2">False</span>
        <span class="s1">self.suppress_warnings_: List[Diagnostics] = []</span>

    <span class="s2">def </span><span class="s1">suppress_warning(self</span><span class="s2">, </span><span class="s1">warning_type: Diagnostics) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Suppress warnings emitted for a particular diagnostic on this expression. 
 
        Example:: 
 
            base = pp.Forward() 
            base.suppress_warning(Diagnostics.warn_on_parse_using_empty_Forward) 
 
            # statement would normally raise a warning, but is now suppressed 
            print(base.parseString(&quot;x&quot;)) 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.suppress_warnings_.append(warning_type)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">copy(self) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Make a copy of this :class:`ParserElement`.  Useful for defining 
        different parse actions for the same parsing pattern, using copies of 
        the original parse element. 
 
        Example:: 
 
            integer = Word(nums).set_parse_action(lambda toks: int(toks[0])) 
            integerK = integer.copy().add_parse_action(lambda toks: toks[0] * 1024) + Suppress(&quot;K&quot;) 
            integerM = integer.copy().add_parse_action(lambda toks: toks[0] * 1024 * 1024) + Suppress(&quot;M&quot;) 
 
            print((integerK | integerM | integer)[1, ...].parse_string(&quot;5K 100 640K 256M&quot;)) 
 
        prints:: 
 
            [5120, 100, 655360, 268435456] 
 
        Equivalent form of ``expr.copy()`` is just ``expr()``:: 
 
            integerM = integer().add_parse_action(lambda toks: toks[0] * 1024 * 1024) + Suppress(&quot;M&quot;) 
        &quot;&quot;&quot;</span>
        <span class="s1">cpy = copy.copy(self)</span>
        <span class="s1">cpy.parseAction = self.parseAction[:]</span>
        <span class="s1">cpy.ignoreExprs = self.ignoreExprs[:]</span>
        <span class="s2">if </span><span class="s1">self.copyDefaultWhiteChars:</span>
            <span class="s1">cpy.whiteChars = set(ParserElement.DEFAULT_WHITE_CHARS)</span>
        <span class="s2">return </span><span class="s1">cpy</span>

    <span class="s2">def </span><span class="s1">set_results_name(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">name: str</span><span class="s2">, </span><span class="s1">list_all_matches: bool = </span><span class="s2">False, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">listAllMatches: bool = </span><span class="s2">False</span>
    <span class="s1">) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Define name for referencing matching tokens as a nested attribute 
        of the returned parse results. 
 
        Normally, results names are assigned as you would assign keys in a dict: 
        any existing value is overwritten by later values. If it is necessary to 
        keep all values captured for a particular results name, call ``set_results_name`` 
        with ``list_all_matches`` = True. 
 
        NOTE: ``set_results_name`` returns a *copy* of the original :class:`ParserElement` object; 
        this is so that the client can define a basic element, such as an 
        integer, and reference it in multiple places with different names. 
 
        You can also set results names using the abbreviated syntax, 
        ``expr(&quot;name&quot;)`` in place of ``expr.set_results_name(&quot;name&quot;)`` 
        - see :class:`__call__`. If ``list_all_matches`` is required, use 
        ``expr(&quot;name*&quot;)``. 
 
        Example:: 
 
            date_str = (integer.set_results_name(&quot;year&quot;) + '/' 
                        + integer.set_results_name(&quot;month&quot;) + '/' 
                        + integer.set_results_name(&quot;day&quot;)) 
 
            # equivalent form: 
            date_str = integer(&quot;year&quot;) + '/' + integer(&quot;month&quot;) + '/' + integer(&quot;day&quot;) 
        &quot;&quot;&quot;</span>
        <span class="s1">listAllMatches = listAllMatches </span><span class="s2">or </span><span class="s1">list_all_matches</span>
        <span class="s2">return </span><span class="s1">self._setResultsName(name</span><span class="s2">, </span><span class="s1">listAllMatches)</span>

    <span class="s2">def </span><span class="s1">_setResultsName(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">listAllMatches=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self</span>
        <span class="s1">newself = self.copy()</span>
        <span class="s2">if </span><span class="s1">name.endswith(</span><span class="s5">&quot;*&quot;</span><span class="s1">):</span>
            <span class="s1">name = name[:-</span><span class="s3">1</span><span class="s1">]</span>
            <span class="s1">listAllMatches = </span><span class="s2">True</span>
        <span class="s1">newself.resultsName = name</span>
        <span class="s1">newself.modalResults = </span><span class="s2">not </span><span class="s1">listAllMatches</span>
        <span class="s2">return </span><span class="s1">newself</span>

    <span class="s2">def </span><span class="s1">set_break(self</span><span class="s2">, </span><span class="s1">break_flag: bool = </span><span class="s2">True</span><span class="s1">) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Method to invoke the Python pdb debugger when this element is 
        about to be parsed. Set ``break_flag`` to ``True`` to enable, ``False`` to 
        disable. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">break_flag:</span>
            <span class="s1">_parseMethod = self._parse</span>

            <span class="s2">def </span><span class="s1">breaker(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True, </span><span class="s1">callPreParse=</span><span class="s2">True</span><span class="s1">):</span>
                <span class="s2">import </span><span class="s1">pdb</span>

                <span class="s0"># this call to pdb.set_trace() is intentional, not a checkin error</span>
                <span class="s1">pdb.set_trace()</span>
                <span class="s2">return </span><span class="s1">_parseMethod(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions</span><span class="s2">, </span><span class="s1">callPreParse)</span>

            <span class="s1">breaker._originalParseMethod = _parseMethod</span>
            <span class="s1">self._parse = breaker</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">hasattr(self._parse</span><span class="s2">, </span><span class="s5">&quot;_originalParseMethod&quot;</span><span class="s1">):</span>
                <span class="s1">self._parse = self._parse._originalParseMethod</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">set_parse_action(self</span><span class="s2">, </span><span class="s1">*fns: ParseAction</span><span class="s2">, </span><span class="s1">**kwargs) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Define one or more actions to perform when successfully matching parse element definition. 
 
        Parse actions can be called to perform data conversions, do extra validation, 
        update external data structures, or enhance or replace the parsed tokens. 
        Each parse action ``fn`` is a callable method with 0-3 arguments, called as 
        ``fn(s, loc, toks)`` , ``fn(loc, toks)`` , ``fn(toks)`` , or just ``fn()`` , where: 
 
        - s   = the original string being parsed (see note below) 
        - loc = the location of the matching substring 
        - toks = a list of the matched tokens, packaged as a :class:`ParseResults` object 
 
        The parsed tokens are passed to the parse action as ParseResults. They can be 
        modified in place using list-style append, extend, and pop operations to update 
        the parsed list elements; and with dictionary-style item set and del operations 
        to add, update, or remove any named results. If the tokens are modified in place, 
        it is not necessary to return them with a return statement. 
 
        Parse actions can also completely replace the given tokens, with another ``ParseResults`` 
        object, or with some entirely different object (common for parse actions that perform data 
        conversions). A convenient way to build a new parse result is to define the values 
        using a dict, and then create the return value using :class:`ParseResults.from_dict`. 
 
        If None is passed as the ``fn`` parse action, all previously added parse actions for this 
        expression are cleared. 
 
        Optional keyword arguments: 
 
        - call_during_try = (default= ``False``) indicate if parse action should be run during 
          lookaheads and alternate testing. For parse actions that have side effects, it is 
          important to only call the parse action once it is determined that it is being 
          called as part of a successful parse. For parse actions that perform additional 
          validation, then call_during_try should be passed as True, so that the validation 
          code is included in the preliminary &quot;try&quot; parses. 
 
        Note: the default parsing behavior is to expand tabs in the input string 
        before starting the parsing process.  See :class:`parse_string` for more 
        information on parsing strings containing ``&lt;TAB&gt;`` s, and suggested 
        methods to maintain a consistent view of the parsed string, the parse 
        location, and line and column positions within the parsed string. 
 
        Example:: 
 
            # parse dates in the form YYYY/MM/DD 
 
            # use parse action to convert toks from str to int at parse time 
            def convert_to_int(toks): 
                return int(toks[0]) 
 
            # use a parse action to verify that the date is a valid date 
            def is_valid_date(instring, loc, toks): 
                from datetime import date 
                year, month, day = toks[::2] 
                try: 
                    date(year, month, day) 
                except ValueError: 
                    raise ParseException(instring, loc, &quot;invalid date given&quot;) 
 
            integer = Word(nums) 
            date_str = integer + '/' + integer + '/' + integer 
 
            # add parse actions 
            integer.set_parse_action(convert_to_int) 
            date_str.set_parse_action(is_valid_date) 
 
            # note that integer fields are now ints, not strings 
            date_str.run_tests(''' 
                # successful parse - note that integer fields were converted to ints 
                1999/12/31 
 
                # fail - invalid date 
                1999/13/31 
                ''') 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">list(fns) == [</span><span class="s2">None</span><span class="s1">]:</span>
            <span class="s1">self.parseAction = []</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">all(callable(fn) </span><span class="s2">for </span><span class="s1">fn </span><span class="s2">in </span><span class="s1">fns):</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s5">&quot;parse actions must be callable&quot;</span><span class="s1">)</span>
            <span class="s1">self.parseAction = [_trim_arity(fn) </span><span class="s2">for </span><span class="s1">fn </span><span class="s2">in </span><span class="s1">fns]</span>
            <span class="s1">self.callDuringTry = kwargs.get(</span>
                <span class="s5">&quot;call_during_try&quot;</span><span class="s2">, </span><span class="s1">kwargs.get(</span><span class="s5">&quot;callDuringTry&quot;</span><span class="s2">, False</span><span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">add_parse_action(self</span><span class="s2">, </span><span class="s1">*fns: ParseAction</span><span class="s2">, </span><span class="s1">**kwargs) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Add one or more parse actions to expression's list of parse actions. See :class:`set_parse_action`. 
 
        See examples in :class:`copy`. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.parseAction += [_trim_arity(fn) </span><span class="s2">for </span><span class="s1">fn </span><span class="s2">in </span><span class="s1">fns]</span>
        <span class="s1">self.callDuringTry = self.callDuringTry </span><span class="s2">or </span><span class="s1">kwargs.get(</span>
            <span class="s5">&quot;call_during_try&quot;</span><span class="s2">, </span><span class="s1">kwargs.get(</span><span class="s5">&quot;callDuringTry&quot;</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">add_condition(self</span><span class="s2">, </span><span class="s1">*fns: ParseCondition</span><span class="s2">, </span><span class="s1">**kwargs) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Add a boolean predicate function to expression's list of parse actions. See 
        :class:`set_parse_action` for function call signatures. Unlike ``set_parse_action``, 
        functions passed to ``add_condition`` need to return boolean success/fail of the condition. 
 
        Optional keyword arguments: 
 
        - message = define a custom message to be used in the raised exception 
        - fatal = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise 
          ParseException 
        - call_during_try = boolean to indicate if this method should be called during internal tryParse calls, 
          default=False 
 
        Example:: 
 
            integer = Word(nums).set_parse_action(lambda toks: int(toks[0])) 
            year_int = integer.copy() 
            year_int.add_condition(lambda toks: toks[0] &gt;= 2000, message=&quot;Only support years 2000 and later&quot;) 
            date_str = year_int + '/' + integer + '/' + integer 
 
            result = date_str.parse_string(&quot;1999/12/31&quot;)  # -&gt; Exception: Only support years 2000 and later (at char 0), 
                                                                         (line:1, col:1) 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">fn </span><span class="s2">in </span><span class="s1">fns:</span>
            <span class="s1">self.parseAction.append(</span>
                <span class="s1">condition_as_parse_action(</span>
                    <span class="s1">fn</span><span class="s2">, </span><span class="s1">message=kwargs.get(</span><span class="s5">&quot;message&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">fatal=kwargs.get(</span><span class="s5">&quot;fatal&quot;</span><span class="s2">, False</span><span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s1">self.callDuringTry = self.callDuringTry </span><span class="s2">or </span><span class="s1">kwargs.get(</span>
            <span class="s5">&quot;call_during_try&quot;</span><span class="s2">, </span><span class="s1">kwargs.get(</span><span class="s5">&quot;callDuringTry&quot;</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">set_fail_action(self</span><span class="s2">, </span><span class="s1">fn: ParseFailAction) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Define action to perform if parsing fails at this expression. 
        Fail acton fn is a callable function that takes the arguments 
        ``fn(s, loc, expr, err)`` where: 
 
        - s = string being parsed 
        - loc = location where expression match was attempted and failed 
        - expr = the parse expression that failed 
        - err = the exception thrown 
 
        The function returns no value.  It may throw :class:`ParseFatalException` 
        if it is desired to stop parsing immediately.&quot;&quot;&quot;</span>
        <span class="s1">self.failAction = fn</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">_skipIgnorables(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc):</span>
        <span class="s1">exprsFound = </span><span class="s2">True</span>
        <span class="s2">while </span><span class="s1">exprsFound:</span>
            <span class="s1">exprsFound = </span><span class="s2">False</span>
            <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.ignoreExprs:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s2">while </span><span class="s3">1</span><span class="s1">:</span>
                        <span class="s1">loc</span><span class="s2">, </span><span class="s1">dummy = e._parse(instring</span><span class="s2">, </span><span class="s1">loc)</span>
                        <span class="s1">exprsFound = </span><span class="s2">True</span>
                <span class="s2">except </span><span class="s1">ParseException:</span>
                    <span class="s2">pass</span>
        <span class="s2">return </span><span class="s1">loc</span>

    <span class="s2">def </span><span class="s1">preParse(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc):</span>
        <span class="s2">if </span><span class="s1">self.ignoreExprs:</span>
            <span class="s1">loc = self._skipIgnorables(instring</span><span class="s2">, </span><span class="s1">loc)</span>

        <span class="s2">if </span><span class="s1">self.skipWhitespace:</span>
            <span class="s1">instrlen = len(instring)</span>
            <span class="s1">white_chars = self.whiteChars</span>
            <span class="s2">while </span><span class="s1">loc &lt; instrlen </span><span class="s2">and </span><span class="s1">instring[loc] </span><span class="s2">in </span><span class="s1">white_chars:</span>
                <span class="s1">loc += </span><span class="s3">1</span>

        <span class="s2">return </span><span class="s1">loc</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">postParse(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">tokenlist):</span>
        <span class="s2">return </span><span class="s1">tokenlist</span>

    <span class="s0"># @profile</span>
    <span class="s2">def </span><span class="s1">_parseNoCache(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True, </span><span class="s1">callPreParse=</span><span class="s2">True</span>
    <span class="s1">) -&gt; Tuple[int</span><span class="s2">, </span><span class="s1">ParseResults]:</span>
        <span class="s1">TRY</span><span class="s2">, </span><span class="s1">MATCH</span><span class="s2">, </span><span class="s1">FAIL = </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span>
        <span class="s1">debugging = self.debug  </span><span class="s0"># and doActions)</span>
        <span class="s1">len_instring = len(instring)</span>

        <span class="s2">if </span><span class="s1">debugging </span><span class="s2">or </span><span class="s1">self.failAction:</span>
            <span class="s0"># print(&quot;Match {} at loc {}({}, {})&quot;.format(self, loc, lineno(loc, instring), col(loc, instring)))</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">callPreParse </span><span class="s2">and </span><span class="s1">self.callPreparse:</span>
                    <span class="s1">pre_loc = self.preParse(instring</span><span class="s2">, </span><span class="s1">loc)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">pre_loc = loc</span>
                <span class="s1">tokens_start = pre_loc</span>
                <span class="s2">if </span><span class="s1">self.debugActions.debug_try:</span>
                    <span class="s1">self.debugActions.debug_try(instring</span><span class="s2">, </span><span class="s1">tokens_start</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, False</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">self.mayIndexError </span><span class="s2">or </span><span class="s1">pre_loc &gt;= len_instring:</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s1">loc</span><span class="s2">, </span><span class="s1">tokens = self.parseImpl(instring</span><span class="s2">, </span><span class="s1">pre_loc</span><span class="s2">, </span><span class="s1">doActions)</span>
                    <span class="s2">except </span><span class="s1">IndexError:</span>
                        <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">len_instring</span><span class="s2">, </span><span class="s1">self.errmsg</span><span class="s2">, </span><span class="s1">self)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">loc</span><span class="s2">, </span><span class="s1">tokens = self.parseImpl(instring</span><span class="s2">, </span><span class="s1">pre_loc</span><span class="s2">, </span><span class="s1">doActions)</span>
            <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">err:</span>
                <span class="s0"># print(&quot;Exception raised:&quot;, err)</span>
                <span class="s2">if </span><span class="s1">self.debugActions.debug_fail:</span>
                    <span class="s1">self.debugActions.debug_fail(</span>
                        <span class="s1">instring</span><span class="s2">, </span><span class="s1">tokens_start</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">err</span><span class="s2">, False</span>
                    <span class="s1">)</span>
                <span class="s2">if </span><span class="s1">self.failAction:</span>
                    <span class="s1">self.failAction(instring</span><span class="s2">, </span><span class="s1">tokens_start</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">err)</span>
                <span class="s2">raise</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">callPreParse </span><span class="s2">and </span><span class="s1">self.callPreparse:</span>
                <span class="s1">pre_loc = self.preParse(instring</span><span class="s2">, </span><span class="s1">loc)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">pre_loc = loc</span>
            <span class="s1">tokens_start = pre_loc</span>
            <span class="s2">if </span><span class="s1">self.mayIndexError </span><span class="s2">or </span><span class="s1">pre_loc &gt;= len_instring:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">loc</span><span class="s2">, </span><span class="s1">tokens = self.parseImpl(instring</span><span class="s2">, </span><span class="s1">pre_loc</span><span class="s2">, </span><span class="s1">doActions)</span>
                <span class="s2">except </span><span class="s1">IndexError:</span>
                    <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">len_instring</span><span class="s2">, </span><span class="s1">self.errmsg</span><span class="s2">, </span><span class="s1">self)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">loc</span><span class="s2">, </span><span class="s1">tokens = self.parseImpl(instring</span><span class="s2">, </span><span class="s1">pre_loc</span><span class="s2">, </span><span class="s1">doActions)</span>

        <span class="s1">tokens = self.postParse(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">tokens)</span>

        <span class="s1">ret_tokens = ParseResults(</span>
            <span class="s1">tokens</span><span class="s2">, </span><span class="s1">self.resultsName</span><span class="s2">, </span><span class="s1">asList=self.saveAsList</span><span class="s2">, </span><span class="s1">modal=self.modalResults</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.parseAction </span><span class="s2">and </span><span class="s1">(doActions </span><span class="s2">or </span><span class="s1">self.callDuringTry):</span>
            <span class="s2">if </span><span class="s1">debugging:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s2">for </span><span class="s1">fn </span><span class="s2">in </span><span class="s1">self.parseAction:</span>
                        <span class="s2">try</span><span class="s1">:</span>
                            <span class="s1">tokens = fn(instring</span><span class="s2">, </span><span class="s1">tokens_start</span><span class="s2">, </span><span class="s1">ret_tokens)</span>
                        <span class="s2">except </span><span class="s1">IndexError </span><span class="s2">as </span><span class="s1">parse_action_exc:</span>
                            <span class="s1">exc = ParseException(</span><span class="s5">&quot;exception raised in parse action&quot;</span><span class="s1">)</span>
                            <span class="s2">raise </span><span class="s1">exc </span><span class="s2">from </span><span class="s1">parse_action_exc</span>

                        <span class="s2">if </span><span class="s1">tokens </span><span class="s2">is not None and </span><span class="s1">tokens </span><span class="s2">is not </span><span class="s1">ret_tokens:</span>
                            <span class="s1">ret_tokens = ParseResults(</span>
                                <span class="s1">tokens</span><span class="s2">,</span>
                                <span class="s1">self.resultsName</span><span class="s2">,</span>
                                <span class="s1">asList=self.saveAsList</span>
                                <span class="s2">and </span><span class="s1">isinstance(tokens</span><span class="s2">, </span><span class="s1">(ParseResults</span><span class="s2">, </span><span class="s1">list))</span><span class="s2">,</span>
                                <span class="s1">modal=self.modalResults</span><span class="s2">,</span>
                            <span class="s1">)</span>
                <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">err:</span>
                    <span class="s0"># print &quot;Exception raised in user parse action:&quot;, err</span>
                    <span class="s2">if </span><span class="s1">self.debugActions.debug_fail:</span>
                        <span class="s1">self.debugActions.debug_fail(</span>
                            <span class="s1">instring</span><span class="s2">, </span><span class="s1">tokens_start</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">err</span><span class="s2">, False</span>
                        <span class="s1">)</span>
                    <span class="s2">raise</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">for </span><span class="s1">fn </span><span class="s2">in </span><span class="s1">self.parseAction:</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s1">tokens = fn(instring</span><span class="s2">, </span><span class="s1">tokens_start</span><span class="s2">, </span><span class="s1">ret_tokens)</span>
                    <span class="s2">except </span><span class="s1">IndexError </span><span class="s2">as </span><span class="s1">parse_action_exc:</span>
                        <span class="s1">exc = ParseException(</span><span class="s5">&quot;exception raised in parse action&quot;</span><span class="s1">)</span>
                        <span class="s2">raise </span><span class="s1">exc </span><span class="s2">from </span><span class="s1">parse_action_exc</span>

                    <span class="s2">if </span><span class="s1">tokens </span><span class="s2">is not None and </span><span class="s1">tokens </span><span class="s2">is not </span><span class="s1">ret_tokens:</span>
                        <span class="s1">ret_tokens = ParseResults(</span>
                            <span class="s1">tokens</span><span class="s2">,</span>
                            <span class="s1">self.resultsName</span><span class="s2">,</span>
                            <span class="s1">asList=self.saveAsList</span>
                            <span class="s2">and </span><span class="s1">isinstance(tokens</span><span class="s2">, </span><span class="s1">(ParseResults</span><span class="s2">, </span><span class="s1">list))</span><span class="s2">,</span>
                            <span class="s1">modal=self.modalResults</span><span class="s2">,</span>
                        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">debugging:</span>
            <span class="s0"># print(&quot;Matched&quot;, self, &quot;-&gt;&quot;, ret_tokens.as_list())</span>
            <span class="s2">if </span><span class="s1">self.debugActions.debug_match:</span>
                <span class="s1">self.debugActions.debug_match(</span>
                    <span class="s1">instring</span><span class="s2">, </span><span class="s1">tokens_start</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">ret_tokens</span><span class="s2">, False</span>
                <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">ret_tokens</span>

    <span class="s2">def </span><span class="s1">try_parse(self</span><span class="s2">, </span><span class="s1">instring: str</span><span class="s2">, </span><span class="s1">loc: int</span><span class="s2">, </span><span class="s1">raise_fatal: bool = </span><span class="s2">False</span><span class="s1">) -&gt; int:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._parse(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">False</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s2">except </span><span class="s1">ParseFatalException:</span>
            <span class="s2">if </span><span class="s1">raise_fatal:</span>
                <span class="s2">raise</span>
            <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">self.errmsg</span><span class="s2">, </span><span class="s1">self)</span>

    <span class="s2">def </span><span class="s1">can_parse_next(self</span><span class="s2">, </span><span class="s1">instring: str</span><span class="s2">, </span><span class="s1">loc: int) -&gt; bool:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self.try_parse(instring</span><span class="s2">, </span><span class="s1">loc)</span>
        <span class="s2">except </span><span class="s1">(ParseException</span><span class="s2">, </span><span class="s1">IndexError):</span>
            <span class="s2">return False</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return True</span>

    <span class="s0"># cache for left-recursion in Forward references</span>
    <span class="s1">recursion_lock = RLock()</span>
    <span class="s1">recursion_memos: typing.Dict[</span>
        <span class="s1">Tuple[int</span><span class="s2">, </span><span class="s5">&quot;Forward&quot;</span><span class="s2">, </span><span class="s1">bool]</span><span class="s2">, </span><span class="s1">Tuple[int</span><span class="s2">, </span><span class="s1">Union[ParseResults</span><span class="s2">, </span><span class="s1">Exception]]</span>
    <span class="s1">] = {}</span>

    <span class="s0"># argument cache for optimizing repeated calls when backtracking through recursive expressions</span>
    <span class="s1">packrat_cache = (</span>
        <span class="s1">{}</span>
    <span class="s1">)  </span><span class="s0"># this is set later by enabled_packrat(); this is here so that reset_cache() doesn't fail</span>
    <span class="s1">packrat_cache_lock = RLock()</span>
    <span class="s1">packrat_cache_stats = [</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span>

    <span class="s0"># this method gets repeatedly called during backtracking with the same arguments -</span>
    <span class="s0"># we can cache these arguments and save ourselves the trouble of re-parsing the contained expression</span>
    <span class="s2">def </span><span class="s1">_parseCache(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True, </span><span class="s1">callPreParse=</span><span class="s2">True</span>
    <span class="s1">) -&gt; Tuple[int</span><span class="s2">, </span><span class="s1">ParseResults]:</span>
        <span class="s1">HIT</span><span class="s2">, </span><span class="s1">MISS = </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span>
        <span class="s1">TRY</span><span class="s2">, </span><span class="s1">MATCH</span><span class="s2">, </span><span class="s1">FAIL = </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span>
        <span class="s1">lookup = (self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">callPreParse</span><span class="s2">, </span><span class="s1">doActions)</span>
        <span class="s2">with </span><span class="s1">ParserElement.packrat_cache_lock:</span>
            <span class="s1">cache = ParserElement.packrat_cache</span>
            <span class="s1">value = cache.get(lookup)</span>
            <span class="s2">if </span><span class="s1">value </span><span class="s2">is </span><span class="s1">cache.not_in_cache:</span>
                <span class="s1">ParserElement.packrat_cache_stats[MISS] += </span><span class="s3">1</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">value = self._parseNoCache(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions</span><span class="s2">, </span><span class="s1">callPreParse)</span>
                <span class="s2">except </span><span class="s1">ParseBaseException </span><span class="s2">as </span><span class="s1">pe:</span>
                    <span class="s0"># cache a copy of the exception, without the traceback</span>
                    <span class="s1">cache.set(lookup</span><span class="s2">, </span><span class="s1">pe.__class__(*pe.args))</span>
                    <span class="s2">raise</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">cache.set(lookup</span><span class="s2">, </span><span class="s1">(value[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">value[</span><span class="s3">1</span><span class="s1">].copy()</span><span class="s2">, </span><span class="s1">loc))</span>
                    <span class="s2">return </span><span class="s1">value</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">ParserElement.packrat_cache_stats[HIT] += </span><span class="s3">1</span>
                <span class="s2">if </span><span class="s1">self.debug </span><span class="s2">and </span><span class="s1">self.debugActions.debug_try:</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s1">self.debugActions.debug_try(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">cache_hit=</span><span class="s2">True</span><span class="s1">)</span>
                    <span class="s2">except </span><span class="s1">TypeError:</span>
                        <span class="s2">pass</span>
                <span class="s2">if </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">Exception):</span>
                    <span class="s2">if </span><span class="s1">self.debug </span><span class="s2">and </span><span class="s1">self.debugActions.debug_fail:</span>
                        <span class="s2">try</span><span class="s1">:</span>
                            <span class="s1">self.debugActions.debug_fail(</span>
                                <span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">cache_hit=</span><span class="s2">True</span>
                            <span class="s1">)</span>
                        <span class="s2">except </span><span class="s1">TypeError:</span>
                            <span class="s2">pass</span>
                    <span class="s2">raise </span><span class="s1">value</span>

                <span class="s1">loc_</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, </span><span class="s1">endloc = value[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">value[</span><span class="s3">1</span><span class="s1">].copy()</span><span class="s2">, </span><span class="s1">value[</span><span class="s3">2</span><span class="s1">]</span>
                <span class="s2">if </span><span class="s1">self.debug </span><span class="s2">and </span><span class="s1">self.debugActions.debug_match:</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s1">self.debugActions.debug_match(</span>
                            <span class="s1">instring</span><span class="s2">, </span><span class="s1">loc_</span><span class="s2">, </span><span class="s1">endloc</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, </span><span class="s1">cache_hit=</span><span class="s2">True</span>
                        <span class="s1">)</span>
                    <span class="s2">except </span><span class="s1">TypeError:</span>
                        <span class="s2">pass</span>

                <span class="s2">return </span><span class="s1">loc_</span><span class="s2">, </span><span class="s1">result</span>

    <span class="s1">_parse = _parseNoCache</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">reset_cache() -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">ParserElement.packrat_cache.clear()</span>
        <span class="s1">ParserElement.packrat_cache_stats[:] = [</span><span class="s3">0</span><span class="s1">] * len(</span>
            <span class="s1">ParserElement.packrat_cache_stats</span>
        <span class="s1">)</span>
        <span class="s1">ParserElement.recursion_memos.clear()</span>

    <span class="s1">_packratEnabled = </span><span class="s2">False</span>
    <span class="s1">_left_recursion_enabled = </span><span class="s2">False</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">disable_memoization() -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Disables active Packrat or Left Recursion parsing and their memoization 
 
        This method also works if neither Packrat nor Left Recursion are enabled. 
        This makes it safe to call before activating Packrat nor Left Recursion 
        to clear any previous settings. 
        &quot;&quot;&quot;</span>
        <span class="s1">ParserElement.reset_cache()</span>
        <span class="s1">ParserElement._left_recursion_enabled = </span><span class="s2">False</span>
        <span class="s1">ParserElement._packratEnabled = </span><span class="s2">False</span>
        <span class="s1">ParserElement._parse = ParserElement._parseNoCache</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">enable_left_recursion(</span>
        <span class="s1">cache_size_limit: typing.Optional[int] = </span><span class="s2">None, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">force=</span><span class="s2">False</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Enables &quot;bounded recursion&quot; parsing, which allows for both direct and indirect 
        left-recursion. During parsing, left-recursive :class:`Forward` elements are 
        repeatedly matched with a fixed recursion depth that is gradually increased 
        until finding the longest match. 
 
        Example:: 
 
            import pyparsing as pp 
            pp.ParserElement.enable_left_recursion() 
 
            E = pp.Forward(&quot;E&quot;) 
            num = pp.Word(pp.nums) 
            # match `num`, or `num '+' num`, or `num '+' num '+' num`, ... 
            E &lt;&lt;= E + '+' - num | num 
 
            print(E.parse_string(&quot;1+2+3&quot;)) 
 
        Recursion search naturally memoizes matches of ``Forward`` elements and may 
        thus skip reevaluation of parse actions during backtracking. This may break 
        programs with parse actions which rely on strict ordering of side-effects. 
 
        Parameters: 
 
        - cache_size_limit - (default=``None``) - memoize at most this many 
          ``Forward`` elements during matching; if ``None`` (the default), 
          memoize all ``Forward`` elements. 
 
        Bounded Recursion parsing works similar but not identical to Packrat parsing, 
        thus the two cannot be used together. Use ``force=True`` to disable any 
        previous, conflicting settings. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">force:</span>
            <span class="s1">ParserElement.disable_memoization()</span>
        <span class="s2">elif </span><span class="s1">ParserElement._packratEnabled:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s5">&quot;Packrat and Bounded Recursion are not compatible&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">cache_size_limit </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">ParserElement.recursion_memos = _UnboundedMemo()</span>
        <span class="s2">elif </span><span class="s1">cache_size_limit &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">ParserElement.recursion_memos = _LRUMemo(capacity=cache_size_limit)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s5">&quot;Memo size of %s&quot; </span><span class="s1">% cache_size_limit)</span>
        <span class="s1">ParserElement._left_recursion_enabled = </span><span class="s2">True</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">enable_packrat(cache_size_limit: int = </span><span class="s3">128</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">force: bool = </span><span class="s2">False</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Enables &quot;packrat&quot; parsing, which adds memoizing to the parsing logic. 
        Repeated parse attempts at the same string location (which happens 
        often in many complex grammars) can immediately return a cached value, 
        instead of re-executing parsing/validating code.  Memoizing is done of 
        both valid results and parsing exceptions. 
 
        Parameters: 
 
        - cache_size_limit - (default= ``128``) - if an integer value is provided 
          will limit the size of the packrat cache; if None is passed, then 
          the cache size will be unbounded; if 0 is passed, the cache will 
          be effectively disabled. 
 
        This speedup may break existing programs that use parse actions that 
        have side-effects.  For this reason, packrat parsing is disabled when 
        you first import pyparsing.  To activate the packrat feature, your 
        program must call the class method :class:`ParserElement.enable_packrat`. 
        For best results, call ``enable_packrat()`` immediately after 
        importing pyparsing. 
 
        Example:: 
 
            import pyparsing 
            pyparsing.ParserElement.enable_packrat() 
 
        Packrat parsing works similar but not identical to Bounded Recursion parsing, 
        thus the two cannot be used together. Use ``force=True`` to disable any 
        previous, conflicting settings. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">force:</span>
            <span class="s1">ParserElement.disable_memoization()</span>
        <span class="s2">elif </span><span class="s1">ParserElement._left_recursion_enabled:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s5">&quot;Packrat and Bounded Recursion are not compatible&quot;</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">ParserElement._packratEnabled:</span>
            <span class="s1">ParserElement._packratEnabled = </span><span class="s2">True</span>
            <span class="s2">if </span><span class="s1">cache_size_limit </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">ParserElement.packrat_cache = _UnboundedCache()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">ParserElement.packrat_cache = _FifoCache(cache_size_limit)</span>
            <span class="s1">ParserElement._parse = ParserElement._parseCache</span>

    <span class="s2">def </span><span class="s1">parse_string(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">instring: str</span><span class="s2">, </span><span class="s1">parse_all: bool = </span><span class="s2">False, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">parseAll: bool = </span><span class="s2">False</span>
    <span class="s1">) -&gt; ParseResults:</span>
        <span class="s4">&quot;&quot;&quot; 
        Parse a string with respect to the parser definition. This function is intended as the primary interface to the 
        client code. 
 
        :param instring: The input string to be parsed. 
        :param parse_all: If set, the entire input string must match the grammar. 
        :param parseAll: retained for pre-PEP8 compatibility, will be removed in a future release. 
        :raises ParseException: Raised if ``parse_all`` is set and the input string does not match the whole grammar. 
        :returns: the parsed data as a :class:`ParseResults` object, which may be accessed as a `list`, a `dict`, or 
          an object with attributes if the given parser includes results names. 
 
        If the input string is required to match the entire grammar, ``parse_all`` flag must be set to ``True``. This 
        is also equivalent to ending the grammar with :class:`StringEnd`(). 
 
        To report proper column numbers, ``parse_string`` operates on a copy of the input string where all tabs are 
        converted to spaces (8 spaces per tab, as per the default in ``string.expandtabs``). If the input string 
        contains tabs and the grammar uses parse actions that use the ``loc`` argument to index into the string 
        being parsed, one can ensure a consistent view of the input string by doing one of the following: 
 
        - calling ``parse_with_tabs`` on your grammar before calling ``parse_string`` (see :class:`parse_with_tabs`), 
        - define your parse action using the full ``(s,loc,toks)`` signature, and reference the input string using the 
          parse action's ``s`` argument, or 
        - explicitly expand the tabs in your input string before calling ``parse_string``. 
 
        Examples: 
 
        By default, partial matches are OK. 
 
        &gt;&gt;&gt; res = Word('a').parse_string('aaaaabaaa') 
        &gt;&gt;&gt; print(res) 
        ['aaaaa'] 
 
        The parsing behavior varies by the inheriting class of this abstract class. Please refer to the children 
        directly to see more examples. 
 
        It raises an exception if parse_all flag is set and instring does not match the whole grammar. 
 
        &gt;&gt;&gt; res = Word('a').parse_string('aaaaabaaa', parse_all=True) 
        Traceback (most recent call last): 
        ... 
        pyparsing.ParseException: Expected end of text, found 'b'  (at char 5), (line:1, col:6) 
        &quot;&quot;&quot;</span>
        <span class="s1">parseAll = parse_all </span><span class="s2">or </span><span class="s1">parseAll</span>

        <span class="s1">ParserElement.reset_cache()</span>
        <span class="s2">if not </span><span class="s1">self.streamlined:</span>
            <span class="s1">self.streamline()</span>
        <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.ignoreExprs:</span>
            <span class="s1">e.streamline()</span>
        <span class="s2">if not </span><span class="s1">self.keepTabs:</span>
            <span class="s1">instring = instring.expandtabs()</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">loc</span><span class="s2">, </span><span class="s1">tokens = self._parse(instring</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">parseAll:</span>
                <span class="s1">loc = self.preParse(instring</span><span class="s2">, </span><span class="s1">loc)</span>
                <span class="s1">se = Empty() + StringEnd()</span>
                <span class="s1">se._parse(instring</span><span class="s2">, </span><span class="s1">loc)</span>
        <span class="s2">except </span><span class="s1">ParseBaseException </span><span class="s2">as </span><span class="s1">exc:</span>
            <span class="s2">if </span><span class="s1">ParserElement.verbose_stacktrace:</span>
                <span class="s2">raise</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s0"># catch and re-raise exception from here, clearing out pyparsing internal stack trace</span>
                <span class="s2">raise </span><span class="s1">exc.with_traceback(</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">tokens</span>

    <span class="s2">def </span><span class="s1">scan_string(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">instring: str</span><span class="s2">,</span>
        <span class="s1">max_matches: int = _MAX_INT</span><span class="s2">,</span>
        <span class="s1">overlap: bool = </span><span class="s2">False,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">debug: bool = </span><span class="s2">False,</span>
        <span class="s1">maxMatches: int = _MAX_INT</span><span class="s2">,</span>
    <span class="s1">) -&gt; Generator[Tuple[ParseResults</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">int]</span><span class="s2">, None, None</span><span class="s1">]:</span>
        <span class="s4">&quot;&quot;&quot; 
        Scan the input string for expression matches.  Each match will return the 
        matching tokens, start location, and end location.  May be called with optional 
        ``max_matches`` argument, to clip scanning after 'n' matches are found.  If 
        ``overlap`` is specified, then overlapping matches will be reported. 
 
        Note that the start and end locations are reported relative to the string 
        being parsed.  See :class:`parse_string` for more information on parsing 
        strings with embedded tabs. 
 
        Example:: 
 
            source = &quot;sldjf123lsdjjkf345sldkjf879lkjsfd987&quot; 
            print(source) 
            for tokens, start, end in Word(alphas).scan_string(source): 
                print(' '*start + '^'*(end-start)) 
                print(' '*start + tokens[0]) 
 
        prints:: 
 
            sldjf123lsdjjkf345sldkjf879lkjsfd987 
            ^^^^^ 
            sldjf 
                    ^^^^^^^ 
                    lsdjjkf 
                              ^^^^^^ 
                              sldkjf 
                                       ^^^^^^ 
                                       lkjsfd 
        &quot;&quot;&quot;</span>
        <span class="s1">maxMatches = min(maxMatches</span><span class="s2">, </span><span class="s1">max_matches)</span>
        <span class="s2">if not </span><span class="s1">self.streamlined:</span>
            <span class="s1">self.streamline()</span>
        <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.ignoreExprs:</span>
            <span class="s1">e.streamline()</span>

        <span class="s2">if not </span><span class="s1">self.keepTabs:</span>
            <span class="s1">instring = str(instring).expandtabs()</span>
        <span class="s1">instrlen = len(instring)</span>
        <span class="s1">loc = </span><span class="s3">0</span>
        <span class="s1">preparseFn = self.preParse</span>
        <span class="s1">parseFn = self._parse</span>
        <span class="s1">ParserElement.resetCache()</span>
        <span class="s1">matches = </span><span class="s3">0</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">while </span><span class="s1">loc &lt;= instrlen </span><span class="s2">and </span><span class="s1">matches &lt; maxMatches:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">preloc = preparseFn(instring</span><span class="s2">, </span><span class="s1">loc)</span>
                    <span class="s1">nextLoc</span><span class="s2">, </span><span class="s1">tokens = parseFn(instring</span><span class="s2">, </span><span class="s1">preloc</span><span class="s2">, </span><span class="s1">callPreParse=</span><span class="s2">False</span><span class="s1">)</span>
                <span class="s2">except </span><span class="s1">ParseException:</span>
                    <span class="s1">loc = preloc + </span><span class="s3">1</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">nextLoc &gt; loc:</span>
                        <span class="s1">matches += </span><span class="s3">1</span>
                        <span class="s2">if </span><span class="s1">debug:</span>
                            <span class="s1">print(</span>
                                <span class="s1">{</span>
                                    <span class="s5">&quot;tokens&quot;</span><span class="s1">: tokens.asList()</span><span class="s2">,</span>
                                    <span class="s5">&quot;start&quot;</span><span class="s1">: preloc</span><span class="s2">,</span>
                                    <span class="s5">&quot;end&quot;</span><span class="s1">: nextLoc</span><span class="s2">,</span>
                                <span class="s1">}</span>
                            <span class="s1">)</span>
                        <span class="s2">yield </span><span class="s1">tokens</span><span class="s2">, </span><span class="s1">preloc</span><span class="s2">, </span><span class="s1">nextLoc</span>
                        <span class="s2">if </span><span class="s1">overlap:</span>
                            <span class="s1">nextloc = preparseFn(instring</span><span class="s2">, </span><span class="s1">loc)</span>
                            <span class="s2">if </span><span class="s1">nextloc &gt; loc:</span>
                                <span class="s1">loc = nextLoc</span>
                            <span class="s2">else</span><span class="s1">:</span>
                                <span class="s1">loc += </span><span class="s3">1</span>
                        <span class="s2">else</span><span class="s1">:</span>
                            <span class="s1">loc = nextLoc</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">loc = preloc + </span><span class="s3">1</span>
        <span class="s2">except </span><span class="s1">ParseBaseException </span><span class="s2">as </span><span class="s1">exc:</span>
            <span class="s2">if </span><span class="s1">ParserElement.verbose_stacktrace:</span>
                <span class="s2">raise</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s0"># catch and re-raise exception from here, clears out pyparsing internal stack trace</span>
                <span class="s2">raise </span><span class="s1">exc.with_traceback(</span><span class="s2">None</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">transform_string(self</span><span class="s2">, </span><span class="s1">instring: str</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">debug: bool = </span><span class="s2">False</span><span class="s1">) -&gt; str:</span>
        <span class="s4">&quot;&quot;&quot; 
        Extension to :class:`scan_string`, to modify matching text with modified tokens that may 
        be returned from a parse action.  To use ``transform_string``, define a grammar and 
        attach a parse action to it that modifies the returned token list. 
        Invoking ``transform_string()`` on a target string will then scan for matches, 
        and replace the matched text patterns according to the logic in the parse 
        action.  ``transform_string()`` returns the resulting transformed string. 
 
        Example:: 
 
            wd = Word(alphas) 
            wd.set_parse_action(lambda toks: toks[0].title()) 
 
            print(wd.transform_string(&quot;now is the winter of our discontent made glorious summer by this sun of york.&quot;)) 
 
        prints:: 
 
            Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York. 
        &quot;&quot;&quot;</span>
        <span class="s1">out: List[str] = []</span>
        <span class="s1">lastE = </span><span class="s3">0</span>
        <span class="s0"># force preservation of &lt;TAB&gt;s, to minimize unwanted transformation of string, and to</span>
        <span class="s0"># keep string locs straight between transform_string and scan_string</span>
        <span class="s1">self.keepTabs = </span><span class="s2">True</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">t</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.scan_string(instring</span><span class="s2">, </span><span class="s1">debug=debug):</span>
                <span class="s1">out.append(instring[lastE:s])</span>
                <span class="s2">if </span><span class="s1">t:</span>
                    <span class="s2">if </span><span class="s1">isinstance(t</span><span class="s2">, </span><span class="s1">ParseResults):</span>
                        <span class="s1">out += t.as_list()</span>
                    <span class="s2">elif </span><span class="s1">isinstance(t</span><span class="s2">, </span><span class="s1">Iterable) </span><span class="s2">and not </span><span class="s1">isinstance(t</span><span class="s2">, </span><span class="s1">str_type):</span>
                        <span class="s1">out.extend(t)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">out.append(t)</span>
                <span class="s1">lastE = e</span>
            <span class="s1">out.append(instring[lastE:])</span>
            <span class="s1">out = [o </span><span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">out </span><span class="s2">if </span><span class="s1">o]</span>
            <span class="s2">return </span><span class="s5">&quot;&quot;</span><span class="s1">.join([str(s) </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">_flatten(out)])</span>
        <span class="s2">except </span><span class="s1">ParseBaseException </span><span class="s2">as </span><span class="s1">exc:</span>
            <span class="s2">if </span><span class="s1">ParserElement.verbose_stacktrace:</span>
                <span class="s2">raise</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s0"># catch and re-raise exception from here, clears out pyparsing internal stack trace</span>
                <span class="s2">raise </span><span class="s1">exc.with_traceback(</span><span class="s2">None</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">search_string(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">instring: str</span><span class="s2">,</span>
        <span class="s1">max_matches: int = _MAX_INT</span><span class="s2">,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">debug: bool = </span><span class="s2">False,</span>
        <span class="s1">maxMatches: int = _MAX_INT</span><span class="s2">,</span>
    <span class="s1">) -&gt; ParseResults:</span>
        <span class="s4">&quot;&quot;&quot; 
        Another extension to :class:`scan_string`, simplifying the access to the tokens found 
        to match the given parse expression.  May be called with optional 
        ``max_matches`` argument, to clip searching after 'n' matches are found. 
 
        Example:: 
 
            # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters 
            cap_word = Word(alphas.upper(), alphas.lower()) 
 
            print(cap_word.search_string(&quot;More than Iron, more than Lead, more than Gold I need Electricity&quot;)) 
 
            # the sum() builtin can be used to merge results into a single ParseResults object 
            print(sum(cap_word.search_string(&quot;More than Iron, more than Lead, more than Gold I need Electricity&quot;))) 
 
        prints:: 
 
            [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']] 
            ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity'] 
        &quot;&quot;&quot;</span>
        <span class="s1">maxMatches = min(maxMatches</span><span class="s2">, </span><span class="s1">max_matches)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">ParseResults(</span>
                <span class="s1">[t </span><span class="s2">for </span><span class="s1">t</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.scan_string(instring</span><span class="s2">, </span><span class="s1">maxMatches</span><span class="s2">, </span><span class="s1">debug=debug)]</span>
            <span class="s1">)</span>
        <span class="s2">except </span><span class="s1">ParseBaseException </span><span class="s2">as </span><span class="s1">exc:</span>
            <span class="s2">if </span><span class="s1">ParserElement.verbose_stacktrace:</span>
                <span class="s2">raise</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s0"># catch and re-raise exception from here, clears out pyparsing internal stack trace</span>
                <span class="s2">raise </span><span class="s1">exc.with_traceback(</span><span class="s2">None</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">split(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">instring: str</span><span class="s2">,</span>
        <span class="s1">maxsplit: int = _MAX_INT</span><span class="s2">,</span>
        <span class="s1">include_separators: bool = </span><span class="s2">False,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">includeSeparators=</span><span class="s2">False,</span>
    <span class="s1">) -&gt; Generator[str</span><span class="s2">, None, None</span><span class="s1">]:</span>
        <span class="s4">&quot;&quot;&quot; 
        Generator method to split a string using the given expression as a separator. 
        May be called with optional ``maxsplit`` argument, to limit the number of splits; 
        and the optional ``include_separators`` argument (default= ``False``), if the separating 
        matching text should be included in the split results. 
 
        Example:: 
 
            punc = one_of(list(&quot;.,;:/-!?&quot;)) 
            print(list(punc.split(&quot;This, this?, this sentence, is badly punctuated!&quot;))) 
 
        prints:: 
 
            ['This', ' this', '', ' this sentence', ' is badly punctuated', ''] 
        &quot;&quot;&quot;</span>
        <span class="s1">includeSeparators = includeSeparators </span><span class="s2">or </span><span class="s1">include_separators</span>
        <span class="s1">last = </span><span class="s3">0</span>
        <span class="s2">for </span><span class="s1">t</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.scan_string(instring</span><span class="s2">, </span><span class="s1">max_matches=maxsplit):</span>
            <span class="s2">yield </span><span class="s1">instring[last:s]</span>
            <span class="s2">if </span><span class="s1">includeSeparators:</span>
                <span class="s2">yield </span><span class="s1">t[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">last = e</span>
        <span class="s2">yield </span><span class="s1">instring[last:]</span>

    <span class="s2">def </span><span class="s1">__add__(self</span><span class="s2">, </span><span class="s1">other) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Implementation of ``+`` operator - returns :class:`And`. Adding strings to a :class:`ParserElement` 
        converts them to :class:`Literal`s by default. 
 
        Example:: 
 
            greet = Word(alphas) + &quot;,&quot; + Word(alphas) + &quot;!&quot; 
            hello = &quot;Hello, World!&quot; 
            print(hello, &quot;-&gt;&quot;, greet.parse_string(hello)) 
 
        prints:: 
 
            Hello, World! -&gt; ['Hello', ',', 'World', '!'] 
 
        ``...`` may be used as a parse expression as a short form of :class:`SkipTo`. 
 
            Literal('start') + ... + Literal('end') 
 
        is equivalent to: 
 
            Literal('start') + SkipTo('end')(&quot;_skipped*&quot;) + Literal('end') 
 
        Note that the skipped text is returned with '_skipped' as a results name, 
        and to support having multiple skips in the same parser, the value returned is 
        a list of all skipped text. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">Ellipsis:</span>
            <span class="s2">return </span><span class="s1">_PendingSkip(self)</span>

        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">str_type):</span>
            <span class="s1">other = self._literalStringClass(other)</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">ParserElement):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s5">&quot;Cannot combine element of type {} with ParserElement&quot;</span><span class="s1">.format(</span>
                    <span class="s1">type(other).__name__</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">And([self</span><span class="s2">, </span><span class="s1">other])</span>

    <span class="s2">def </span><span class="s1">__radd__(self</span><span class="s2">, </span><span class="s1">other) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Implementation of ``+`` operator when left operand is not a :class:`ParserElement` 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">Ellipsis:</span>
            <span class="s2">return </span><span class="s1">SkipTo(self)(</span><span class="s5">&quot;_skipped*&quot;</span><span class="s1">) + self</span>

        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">str_type):</span>
            <span class="s1">other = self._literalStringClass(other)</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">ParserElement):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s5">&quot;Cannot combine element of type {} with ParserElement&quot;</span><span class="s1">.format(</span>
                    <span class="s1">type(other).__name__</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">other + self</span>

    <span class="s2">def </span><span class="s1">__sub__(self</span><span class="s2">, </span><span class="s1">other) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Implementation of ``-`` operator, returns :class:`And` with error stop 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">str_type):</span>
            <span class="s1">other = self._literalStringClass(other)</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">ParserElement):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s5">&quot;Cannot combine element of type {} with ParserElement&quot;</span><span class="s1">.format(</span>
                    <span class="s1">type(other).__name__</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self + And._ErrorStop() + other</span>

    <span class="s2">def </span><span class="s1">__rsub__(self</span><span class="s2">, </span><span class="s1">other) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Implementation of ``-`` operator when left operand is not a :class:`ParserElement` 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">str_type):</span>
            <span class="s1">other = self._literalStringClass(other)</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">ParserElement):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s5">&quot;Cannot combine element of type {} with ParserElement&quot;</span><span class="s1">.format(</span>
                    <span class="s1">type(other).__name__</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">other - self</span>

    <span class="s2">def </span><span class="s1">__mul__(self</span><span class="s2">, </span><span class="s1">other) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Implementation of ``*`` operator, allows use of ``expr * 3`` in place of 
        ``expr + expr + expr``.  Expressions may also be multiplied by a 2-integer 
        tuple, similar to ``{min, max}`` multipliers in regular expressions.  Tuples 
        may also include ``None`` as in: 
        - ``expr*(n, None)`` or ``expr*(n, )`` is equivalent 
             to ``expr*n + ZeroOrMore(expr)`` 
             (read as &quot;at least n instances of ``expr``&quot;) 
        - ``expr*(None, n)`` is equivalent to ``expr*(0, n)`` 
             (read as &quot;0 to n instances of ``expr``&quot;) 
        - ``expr*(None, None)`` is equivalent to ``ZeroOrMore(expr)`` 
        - ``expr*(1, None)`` is equivalent to ``OneOrMore(expr)`` 
 
        Note that ``expr*(None, n)`` does not raise an exception if 
        more than n exprs exist in the input stream; that is, 
        ``expr*(None, n)`` does not enforce a maximum number of expr 
        occurrences.  If this behavior is desired, then write 
        ``expr*(None, n) + ~expr`` 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">Ellipsis:</span>
            <span class="s1">other = (</span><span class="s3">0</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">tuple) </span><span class="s2">and </span><span class="s1">other[:</span><span class="s3">1</span><span class="s1">] == (Ellipsis</span><span class="s2">,</span><span class="s1">):</span>
            <span class="s1">other = ((</span><span class="s3">0</span><span class="s2">,</span><span class="s1">) + other[</span><span class="s3">1</span><span class="s1">:] + (</span><span class="s2">None,</span><span class="s1">))[:</span><span class="s3">2</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">int):</span>
            <span class="s1">minElements</span><span class="s2">, </span><span class="s1">optElements = other</span><span class="s2">, </span><span class="s3">0</span>
        <span class="s2">elif </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">tuple):</span>
            <span class="s1">other = tuple(o </span><span class="s2">if </span><span class="s1">o </span><span class="s2">is not </span><span class="s1">Ellipsis </span><span class="s2">else None for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">other)</span>
            <span class="s1">other = (other + (</span><span class="s2">None, None</span><span class="s1">))[:</span><span class="s3">2</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">other[</span><span class="s3">0</span><span class="s1">] </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">other = (</span><span class="s3">0</span><span class="s2">, </span><span class="s1">other[</span><span class="s3">1</span><span class="s1">])</span>
            <span class="s2">if </span><span class="s1">isinstance(other[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">int) </span><span class="s2">and </span><span class="s1">other[</span><span class="s3">1</span><span class="s1">] </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">other[</span><span class="s3">0</span><span class="s1">] == </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">ZeroOrMore(self)</span>
                <span class="s2">if </span><span class="s1">other[</span><span class="s3">0</span><span class="s1">] == </span><span class="s3">1</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">OneOrMore(self)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">self * other[</span><span class="s3">0</span><span class="s1">] + ZeroOrMore(self)</span>
            <span class="s2">elif </span><span class="s1">isinstance(other[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">int) </span><span class="s2">and </span><span class="s1">isinstance(other[</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">int):</span>
                <span class="s1">minElements</span><span class="s2">, </span><span class="s1">optElements = other</span>
                <span class="s1">optElements -= minElements</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span>
                    <span class="s5">&quot;cannot multiply ParserElement and ({}) objects&quot;</span><span class="s1">.format(</span>
                        <span class="s5">&quot;,&quot;</span><span class="s1">.join(type(item).__name__ </span><span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">other)</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s5">&quot;cannot multiply ParserElement and {} objects&quot;</span><span class="s1">.format(</span>
                    <span class="s1">type(other).__name__</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">minElements &lt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;cannot multiply ParserElement by negative value&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">optElements &lt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s5">&quot;second tuple value must be greater or equal to first tuple value&quot;</span>
            <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">minElements == optElements == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">And([])</span>

        <span class="s2">if </span><span class="s1">optElements:</span>

            <span class="s2">def </span><span class="s1">makeOptionalList(n):</span>
                <span class="s2">if </span><span class="s1">n &gt; </span><span class="s3">1</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">Opt(self + makeOptionalList(n - </span><span class="s3">1</span><span class="s1">))</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">Opt(self)</span>

            <span class="s2">if </span><span class="s1">minElements:</span>
                <span class="s2">if </span><span class="s1">minElements == </span><span class="s3">1</span><span class="s1">:</span>
                    <span class="s1">ret = self + makeOptionalList(optElements)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">ret = And([self] * minElements) + makeOptionalList(optElements)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">ret = makeOptionalList(optElements)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">minElements == </span><span class="s3">1</span><span class="s1">:</span>
                <span class="s1">ret = self</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">ret = And([self] * minElements)</span>
        <span class="s2">return </span><span class="s1">ret</span>

    <span class="s2">def </span><span class="s1">__rmul__(self</span><span class="s2">, </span><span class="s1">other) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">self.__mul__(other)</span>

    <span class="s2">def </span><span class="s1">__or__(self</span><span class="s2">, </span><span class="s1">other) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Implementation of ``|`` operator - returns :class:`MatchFirst` 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">Ellipsis:</span>
            <span class="s2">return </span><span class="s1">_PendingSkip(self</span><span class="s2">, </span><span class="s1">must_skip=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">str_type):</span>
            <span class="s1">other = self._literalStringClass(other)</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">ParserElement):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s5">&quot;Cannot combine element of type {} with ParserElement&quot;</span><span class="s1">.format(</span>
                    <span class="s1">type(other).__name__</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">MatchFirst([self</span><span class="s2">, </span><span class="s1">other])</span>

    <span class="s2">def </span><span class="s1">__ror__(self</span><span class="s2">, </span><span class="s1">other) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Implementation of ``|`` operator when left operand is not a :class:`ParserElement` 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">str_type):</span>
            <span class="s1">other = self._literalStringClass(other)</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">ParserElement):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s5">&quot;Cannot combine element of type {} with ParserElement&quot;</span><span class="s1">.format(</span>
                    <span class="s1">type(other).__name__</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">other | self</span>

    <span class="s2">def </span><span class="s1">__xor__(self</span><span class="s2">, </span><span class="s1">other) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Implementation of ``^`` operator - returns :class:`Or` 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">str_type):</span>
            <span class="s1">other = self._literalStringClass(other)</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">ParserElement):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s5">&quot;Cannot combine element of type {} with ParserElement&quot;</span><span class="s1">.format(</span>
                    <span class="s1">type(other).__name__</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">Or([self</span><span class="s2">, </span><span class="s1">other])</span>

    <span class="s2">def </span><span class="s1">__rxor__(self</span><span class="s2">, </span><span class="s1">other) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Implementation of ``^`` operator when left operand is not a :class:`ParserElement` 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">str_type):</span>
            <span class="s1">other = self._literalStringClass(other)</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">ParserElement):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s5">&quot;Cannot combine element of type {} with ParserElement&quot;</span><span class="s1">.format(</span>
                    <span class="s1">type(other).__name__</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">other ^ self</span>

    <span class="s2">def </span><span class="s1">__and__(self</span><span class="s2">, </span><span class="s1">other) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Implementation of ``&amp;`` operator - returns :class:`Each` 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">str_type):</span>
            <span class="s1">other = self._literalStringClass(other)</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">ParserElement):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s5">&quot;Cannot combine element of type {} with ParserElement&quot;</span><span class="s1">.format(</span>
                    <span class="s1">type(other).__name__</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">Each([self</span><span class="s2">, </span><span class="s1">other])</span>

    <span class="s2">def </span><span class="s1">__rand__(self</span><span class="s2">, </span><span class="s1">other) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Implementation of ``&amp;`` operator when left operand is not a :class:`ParserElement` 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">str_type):</span>
            <span class="s1">other = self._literalStringClass(other)</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">ParserElement):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s5">&quot;Cannot combine element of type {} with ParserElement&quot;</span><span class="s1">.format(</span>
                    <span class="s1">type(other).__name__</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">other &amp; self</span>

    <span class="s2">def </span><span class="s1">__invert__(self) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Implementation of ``~`` operator - returns :class:`NotAny` 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">NotAny(self)</span>

    <span class="s0"># disable __iter__ to override legacy use of sequential access to __getitem__ to</span>
    <span class="s0"># iterate over a sequence</span>
    <span class="s1">__iter__ = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__getitem__(self</span><span class="s2">, </span><span class="s1">key):</span>
        <span class="s4">&quot;&quot;&quot; 
        use ``[]`` indexing notation as a short form for expression repetition: 
 
        - ``expr[n]`` is equivalent to ``expr*n`` 
        - ``expr[m, n]`` is equivalent to ``expr*(m, n)`` 
        - ``expr[n, ...]`` or ``expr[n,]`` is equivalent 
             to ``expr*n + ZeroOrMore(expr)`` 
             (read as &quot;at least n instances of ``expr``&quot;) 
        - ``expr[..., n]`` is equivalent to ``expr*(0, n)`` 
             (read as &quot;0 to n instances of ``expr``&quot;) 
        - ``expr[...]`` and ``expr[0, ...]`` are equivalent to ``ZeroOrMore(expr)`` 
        - ``expr[1, ...]`` is equivalent to ``OneOrMore(expr)`` 
 
        ``None`` may be used in place of ``...``. 
 
        Note that ``expr[..., n]`` and ``expr[m, n]``do not raise an exception 
        if more than ``n`` ``expr``s exist in the input stream.  If this behavior is 
        desired, then write ``expr[..., n] + ~expr``. 
        &quot;&quot;&quot;</span>

        <span class="s0"># convert single arg keys to tuples</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">isinstance(key</span><span class="s2">, </span><span class="s1">str_type):</span>
                <span class="s1">key = (key</span><span class="s2">,</span><span class="s1">)</span>
            <span class="s1">iter(key)</span>
        <span class="s2">except </span><span class="s1">TypeError:</span>
            <span class="s1">key = (key</span><span class="s2">, </span><span class="s1">key)</span>

        <span class="s2">if </span><span class="s1">len(key) &gt; </span><span class="s3">2</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s5">&quot;only 1 or 2 index arguments supported ({}{})&quot;</span><span class="s1">.format(</span>
                    <span class="s1">key[:</span><span class="s3">5</span><span class="s1">]</span><span class="s2">, </span><span class="s5">&quot;... [{}]&quot;</span><span class="s1">.format(len(key)) </span><span class="s2">if </span><span class="s1">len(key) &gt; </span><span class="s3">5 </span><span class="s2">else </span><span class="s5">&quot;&quot;</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s0"># clip to 2 elements</span>
        <span class="s1">ret = self * tuple(key[:</span><span class="s3">2</span><span class="s1">])</span>
        <span class="s2">return </span><span class="s1">ret</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">name: str = </span><span class="s2">None</span><span class="s1">) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Shortcut for :class:`set_results_name`, with ``list_all_matches=False``. 
 
        If ``name`` is given with a trailing ``'*'`` character, then ``list_all_matches`` will be 
        passed as ``True``. 
 
        If ``name` is omitted, same as calling :class:`copy`. 
 
        Example:: 
 
            # these are equivalent 
            userdata = Word(alphas).set_results_name(&quot;name&quot;) + Word(nums + &quot;-&quot;).set_results_name(&quot;socsecno&quot;) 
            userdata = Word(alphas)(&quot;name&quot;) + Word(nums + &quot;-&quot;)(&quot;socsecno&quot;) 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._setResultsName(name)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.copy()</span>

    <span class="s2">def </span><span class="s1">suppress(self) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Suppresses the output of this :class:`ParserElement`; useful to keep punctuation from 
        cluttering up returned output. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">Suppress(self)</span>

    <span class="s2">def </span><span class="s1">ignore_whitespace(self</span><span class="s2">, </span><span class="s1">recursive: bool = </span><span class="s2">True</span><span class="s1">) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Enables the skipping of whitespace before matching the characters in the 
        :class:`ParserElement`'s defined pattern. 
 
        :param recursive: If ``True`` (the default), also enable whitespace skipping in child elements (if any) 
        &quot;&quot;&quot;</span>
        <span class="s1">self.skipWhitespace = </span><span class="s2">True</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">leave_whitespace(self</span><span class="s2">, </span><span class="s1">recursive: bool = </span><span class="s2">True</span><span class="s1">) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Disables the skipping of whitespace before matching the characters in the 
        :class:`ParserElement`'s defined pattern.  This is normally only used internally by 
        the pyparsing module, but may be needed in some whitespace-sensitive grammars. 
 
        :param recursive: If true (the default), also disable whitespace skipping in child elements (if any) 
        &quot;&quot;&quot;</span>
        <span class="s1">self.skipWhitespace = </span><span class="s2">False</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">set_whitespace_chars(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">chars: Union[Set[str]</span><span class="s2">, </span><span class="s1">str]</span><span class="s2">, </span><span class="s1">copy_defaults: bool = </span><span class="s2">False</span>
    <span class="s1">) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Overrides the default whitespace chars 
        &quot;&quot;&quot;</span>
        <span class="s1">self.skipWhitespace = </span><span class="s2">True</span>
        <span class="s1">self.whiteChars = set(chars)</span>
        <span class="s1">self.copyDefaultWhiteChars = copy_defaults</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">parse_with_tabs(self) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Overrides default behavior to expand ``&lt;TAB&gt;`` s to spaces before parsing the input string. 
        Must be called before ``parse_string`` when the input grammar contains elements that 
        match ``&lt;TAB&gt;`` characters. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.keepTabs = </span><span class="s2">True</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">ignore(self</span><span class="s2">, </span><span class="s1">other: </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Define expression to be ignored (e.g., comments) while doing pattern 
        matching; may be called repeatedly, to define multiple comment or other 
        ignorable patterns. 
 
        Example:: 
 
            patt = Word(alphas)[1, ...] 
            patt.parse_string('ablaj /* comment */ lskjd') 
            # -&gt; ['ablaj'] 
 
            patt.ignore(c_style_comment) 
            patt.parse_string('ablaj /* comment */ lskjd') 
            # -&gt; ['ablaj', 'lskjd'] 
        &quot;&quot;&quot;</span>
        <span class="s2">import </span><span class="s1">typing</span>

        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">str_type):</span>
            <span class="s1">other = Suppress(other)</span>

        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">Suppress):</span>
            <span class="s2">if </span><span class="s1">other </span><span class="s2">not in </span><span class="s1">self.ignoreExprs:</span>
                <span class="s1">self.ignoreExprs.append(other)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.ignoreExprs.append(Suppress(other.copy()))</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">set_debug_actions(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">start_action: DebugStartAction</span><span class="s2">,</span>
        <span class="s1">success_action: DebugSuccessAction</span><span class="s2">,</span>
        <span class="s1">exception_action: DebugExceptionAction</span><span class="s2">,</span>
    <span class="s1">) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Customize display of debugging messages while doing pattern matching: 
 
        - ``start_action`` - method to be called when an expression is about to be parsed; 
          should have the signature ``fn(input_string: str, location: int, expression: ParserElement, cache_hit: bool)`` 
 
        - ``success_action`` - method to be called when an expression has successfully parsed; 
          should have the signature ``fn(input_string: str, start_location: int, end_location: int, expression: ParserELement, parsed_tokens: ParseResults, cache_hit: bool)`` 
 
        - ``exception_action`` - method to be called when expression fails to parse; 
          should have the signature ``fn(input_string: str, location: int, expression: ParserElement, exception: Exception, cache_hit: bool)`` 
        &quot;&quot;&quot;</span>
        <span class="s1">self.debugActions = self.DebugActions(</span>
            <span class="s1">start_action </span><span class="s2">or </span><span class="s1">_default_start_debug_action</span><span class="s2">,</span>
            <span class="s1">success_action </span><span class="s2">or </span><span class="s1">_default_success_debug_action</span><span class="s2">,</span>
            <span class="s1">exception_action </span><span class="s2">or </span><span class="s1">_default_exception_debug_action</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">self.debug = </span><span class="s2">True</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">set_debug(self</span><span class="s2">, </span><span class="s1">flag: bool = </span><span class="s2">True</span><span class="s1">) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Enable display of debugging messages while doing pattern matching. 
        Set ``flag`` to ``True`` to enable, ``False`` to disable. 
 
        Example:: 
 
            wd = Word(alphas).set_name(&quot;alphaword&quot;) 
            integer = Word(nums).set_name(&quot;numword&quot;) 
            term = wd | integer 
 
            # turn on debugging for wd 
            wd.set_debug() 
 
            term[1, ...].parse_string(&quot;abc 123 xyz 890&quot;) 
 
        prints:: 
 
            Match alphaword at loc 0(1,1) 
            Matched alphaword -&gt; ['abc'] 
            Match alphaword at loc 3(1,4) 
            Exception raised:Expected alphaword (at char 4), (line:1, col:5) 
            Match alphaword at loc 7(1,8) 
            Matched alphaword -&gt; ['xyz'] 
            Match alphaword at loc 11(1,12) 
            Exception raised:Expected alphaword (at char 12), (line:1, col:13) 
            Match alphaword at loc 15(1,16) 
            Exception raised:Expected alphaword (at char 15), (line:1, col:16) 
 
        The output shown is that produced by the default debug actions - custom debug actions can be 
        specified using :class:`set_debug_actions`. Prior to attempting 
        to match the ``wd`` expression, the debugging message ``&quot;Match &lt;exprname&gt; at loc &lt;n&gt;(&lt;line&gt;,&lt;col&gt;)&quot;`` 
        is shown. Then if the parse succeeds, a ``&quot;Matched&quot;`` message is shown, or an ``&quot;Exception raised&quot;`` 
        message is shown. Also note the use of :class:`set_name` to assign a human-readable name to the expression, 
        which makes debugging and exception messages easier to understand - for instance, the default 
        name created for the :class:`Word` expression without calling ``set_name`` is ``&quot;W:(A-Za-z)&quot;``. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">flag:</span>
            <span class="s1">self.set_debug_actions(</span>
                <span class="s1">_default_start_debug_action</span><span class="s2">,</span>
                <span class="s1">_default_success_debug_action</span><span class="s2">,</span>
                <span class="s1">_default_exception_debug_action</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.debug = </span><span class="s2">False</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">default_name(self) -&gt; str:</span>
        <span class="s2">if </span><span class="s1">self._defaultName </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._defaultName = self._generateDefaultName()</span>
        <span class="s2">return </span><span class="s1">self._defaultName</span>

    <span class="s1">@abstractmethod</span>
    <span class="s2">def </span><span class="s1">_generateDefaultName(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Child classes must define this method, which defines how the ``default_name`` is set. 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">set_name(self</span><span class="s2">, </span><span class="s1">name: str) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Define name for this expression, makes debugging and exception messages clearer. 
        Example:: 
            Word(nums).parse_string(&quot;ABC&quot;)  # -&gt; Exception: Expected W:(0-9) (at char 0), (line:1, col:1) 
            Word(nums).set_name(&quot;integer&quot;).parse_string(&quot;ABC&quot;)  # -&gt; Exception: Expected integer (at char 0), (line:1, col:1) 
        &quot;&quot;&quot;</span>
        <span class="s1">self.customName = name</span>
        <span class="s1">self.errmsg = </span><span class="s5">&quot;Expected &quot; </span><span class="s1">+ self.name</span>
        <span class="s2">if </span><span class="s1">__diag__.enable_debug_on_named_expressions:</span>
            <span class="s1">self.set_debug()</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">name(self) -&gt; str:</span>
        <span class="s0"># This will use a user-defined name if available, but otherwise defaults back to the auto-generated name</span>
        <span class="s2">return </span><span class="s1">self.customName </span><span class="s2">if </span><span class="s1">self.customName </span><span class="s2">is not None else </span><span class="s1">self.default_name</span>

    <span class="s2">def </span><span class="s1">__str__(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">self.name</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">str(self)</span>

    <span class="s2">def </span><span class="s1">streamline(self) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s1">self.streamlined = </span><span class="s2">True</span>
        <span class="s1">self._defaultName = </span><span class="s2">None</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">recurse(self) -&gt; Sequence[</span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">]:</span>
        <span class="s2">return </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">_checkRecursion(self</span><span class="s2">, </span><span class="s1">parseElementList):</span>
        <span class="s1">subRecCheckList = parseElementList[:] + [self]</span>
        <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.recurse():</span>
            <span class="s1">e._checkRecursion(subRecCheckList)</span>

    <span class="s2">def </span><span class="s1">validate(self</span><span class="s2">, </span><span class="s1">validateTrace=</span><span class="s2">None</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Check defined expressions for valid structure, check for infinite recursive definitions. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._checkRecursion([])</span>

    <span class="s2">def </span><span class="s1">parse_file(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">file_or_filename: Union[str</span><span class="s2">, </span><span class="s1">Path</span><span class="s2">, </span><span class="s1">TextIO]</span><span class="s2">,</span>
        <span class="s1">encoding: str = </span><span class="s5">&quot;utf-8&quot;</span><span class="s2">,</span>
        <span class="s1">parse_all: bool = </span><span class="s2">False,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">parseAll: bool = </span><span class="s2">False,</span>
    <span class="s1">) -&gt; ParseResults:</span>
        <span class="s4">&quot;&quot;&quot; 
        Execute the parse expression on the given file or filename. 
        If a filename is specified (instead of a file object), 
        the entire file is opened, read, and closed before parsing. 
        &quot;&quot;&quot;</span>
        <span class="s1">parseAll = parseAll </span><span class="s2">or </span><span class="s1">parse_all</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">file_contents = file_or_filename.read()</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s2">with </span><span class="s1">open(file_or_filename</span><span class="s2">, </span><span class="s5">&quot;r&quot;</span><span class="s2">, </span><span class="s1">encoding=encoding) </span><span class="s2">as </span><span class="s1">f:</span>
                <span class="s1">file_contents = f.read()</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.parse_string(file_contents</span><span class="s2">, </span><span class="s1">parseAll)</span>
        <span class="s2">except </span><span class="s1">ParseBaseException </span><span class="s2">as </span><span class="s1">exc:</span>
            <span class="s2">if </span><span class="s1">ParserElement.verbose_stacktrace:</span>
                <span class="s2">raise</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s0"># catch and re-raise exception from here, clears out pyparsing internal stack trace</span>
                <span class="s2">raise </span><span class="s1">exc.with_traceback(</span><span class="s2">None</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if </span><span class="s1">self </span><span class="s2">is </span><span class="s1">other:</span>
            <span class="s2">return True</span>
        <span class="s2">elif </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">str_type):</span>
            <span class="s2">return </span><span class="s1">self.matches(other</span><span class="s2">, </span><span class="s1">parse_all=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">ParserElement):</span>
            <span class="s2">return </span><span class="s1">vars(self) == vars(other)</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">id(self)</span>

    <span class="s2">def </span><span class="s1">matches(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">test_string: str</span><span class="s2">, </span><span class="s1">parse_all: bool = </span><span class="s2">True, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">parseAll: bool = </span><span class="s2">True</span>
    <span class="s1">) -&gt; bool:</span>
        <span class="s4">&quot;&quot;&quot; 
        Method for quick testing of a parser against a test string. Good for simple 
        inline microtests of sub expressions while building up larger parser. 
 
        Parameters: 
        - ``test_string`` - to test against this expression for a match 
        - ``parse_all`` - (default= ``True``) - flag to pass to :class:`parse_string` when running tests 
 
        Example:: 
 
            expr = Word(nums) 
            assert expr.matches(&quot;100&quot;) 
        &quot;&quot;&quot;</span>
        <span class="s1">parseAll = parseAll </span><span class="s2">and </span><span class="s1">parse_all</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self.parse_string(str(test_string)</span><span class="s2">, </span><span class="s1">parse_all=parseAll)</span>
            <span class="s2">return True</span>
        <span class="s2">except </span><span class="s1">ParseBaseException:</span>
            <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">run_tests(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">tests: Union[str</span><span class="s2">, </span><span class="s1">List[str]]</span><span class="s2">,</span>
        <span class="s1">parse_all: bool = </span><span class="s2">True,</span>
        <span class="s1">comment: typing.Optional[Union[</span><span class="s5">&quot;ParserElement&quot;</span><span class="s2">, </span><span class="s1">str]] = </span><span class="s5">&quot;#&quot;</span><span class="s2">,</span>
        <span class="s1">full_dump: bool = </span><span class="s2">True,</span>
        <span class="s1">print_results: bool = </span><span class="s2">True,</span>
        <span class="s1">failure_tests: bool = </span><span class="s2">False,</span>
        <span class="s1">post_parse: Callable[[str</span><span class="s2">, </span><span class="s1">ParseResults]</span><span class="s2">, </span><span class="s1">str] = </span><span class="s2">None,</span>
        <span class="s1">file: typing.Optional[TextIO] = </span><span class="s2">None,</span>
        <span class="s1">with_line_numbers: bool = </span><span class="s2">False,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">parseAll: bool = </span><span class="s2">True,</span>
        <span class="s1">fullDump: bool = </span><span class="s2">True,</span>
        <span class="s1">printResults: bool = </span><span class="s2">True,</span>
        <span class="s1">failureTests: bool = </span><span class="s2">False,</span>
        <span class="s1">postParse: Callable[[str</span><span class="s2">, </span><span class="s1">ParseResults]</span><span class="s2">, </span><span class="s1">str] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; Tuple[bool</span><span class="s2">, </span><span class="s1">List[Tuple[str</span><span class="s2">, </span><span class="s1">Union[ParseResults</span><span class="s2">, </span><span class="s1">Exception]]]]:</span>
        <span class="s4">&quot;&quot;&quot; 
        Execute the parse expression on a series of test strings, showing each 
        test, the parsed results or where the parse failed. Quick and easy way to 
        run a parse expression against a list of sample strings. 
 
        Parameters: 
        - ``tests`` - a list of separate test strings, or a multiline string of test strings 
        - ``parse_all`` - (default= ``True``) - flag to pass to :class:`parse_string` when running tests 
        - ``comment`` - (default= ``'#'``) - expression for indicating embedded comments in the test 
          string; pass None to disable comment filtering 
        - ``full_dump`` - (default= ``True``) - dump results as list followed by results names in nested outline; 
          if False, only dump nested list 
        - ``print_results`` - (default= ``True``) prints test output to stdout 
        - ``failure_tests`` - (default= ``False``) indicates if these tests are expected to fail parsing 
        - ``post_parse`` - (default= ``None``) optional callback for successful parse results; called as 
          `fn(test_string, parse_results)` and returns a string to be added to the test output 
        - ``file`` - (default= ``None``) optional file-like object to which test output will be written; 
          if None, will default to ``sys.stdout`` 
        - ``with_line_numbers`` - default= ``False``) show test strings with line and column numbers 
 
        Returns: a (success, results) tuple, where success indicates that all tests succeeded 
        (or failed if ``failure_tests`` is True), and the results contain a list of lines of each 
        test's output 
 
        Example:: 
 
            number_expr = pyparsing_common.number.copy() 
 
            result = number_expr.run_tests(''' 
                # unsigned integer 
                100 
                # negative integer 
                -100 
                # float with scientific notation 
                6.02e23 
                # integer with scientific notation 
                1e-12 
                ''') 
            print(&quot;Success&quot; if result[0] else &quot;Failed!&quot;) 
 
            result = number_expr.run_tests(''' 
                # stray character 
                100Z 
                # missing leading digit before '.' 
                -.100 
                # too many '.' 
                3.14.159 
                ''', failure_tests=True) 
            print(&quot;Success&quot; if result[0] else &quot;Failed!&quot;) 
 
        prints:: 
 
            # unsigned integer 
            100 
            [100] 
 
            # negative integer 
            -100 
            [-100] 
 
            # float with scientific notation 
            6.02e23 
            [6.02e+23] 
 
            # integer with scientific notation 
            1e-12 
            [1e-12] 
 
            Success 
 
            # stray character 
            100Z 
               ^ 
            FAIL: Expected end of text (at char 3), (line:1, col:4) 
 
            # missing leading digit before '.' 
            -.100 
            ^ 
            FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1) 
 
            # too many '.' 
            3.14.159 
                ^ 
            FAIL: Expected end of text (at char 4), (line:1, col:5) 
 
            Success 
 
        Each test string must be on a single line. If you want to test a string that spans multiple 
        lines, create a test like this:: 
 
            expr.run_tests(r&quot;this is a test\\n of strings that spans \\n 3 lines&quot;) 
 
        (Note that this is a raw string literal, you must include the leading ``'r'``.) 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">.testing </span><span class="s2">import </span><span class="s1">pyparsing_test</span>

        <span class="s1">parseAll = parseAll </span><span class="s2">and </span><span class="s1">parse_all</span>
        <span class="s1">fullDump = fullDump </span><span class="s2">and </span><span class="s1">full_dump</span>
        <span class="s1">printResults = printResults </span><span class="s2">and </span><span class="s1">print_results</span>
        <span class="s1">failureTests = failureTests </span><span class="s2">or </span><span class="s1">failure_tests</span>
        <span class="s1">postParse = postParse </span><span class="s2">or </span><span class="s1">post_parse</span>
        <span class="s2">if </span><span class="s1">isinstance(tests</span><span class="s2">, </span><span class="s1">str_type):</span>
            <span class="s1">line_strip = type(tests).strip</span>
            <span class="s1">tests = [line_strip(test_line) </span><span class="s2">for </span><span class="s1">test_line </span><span class="s2">in </span><span class="s1">tests.rstrip().splitlines()]</span>
        <span class="s2">if </span><span class="s1">isinstance(comment</span><span class="s2">, </span><span class="s1">str_type):</span>
            <span class="s1">comment = Literal(comment)</span>
        <span class="s2">if </span><span class="s1">file </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">file = sys.stdout</span>
        <span class="s1">print_ = file.write</span>

        <span class="s1">result: Union[ParseResults</span><span class="s2">, </span><span class="s1">Exception]</span>
        <span class="s1">allResults = []</span>
        <span class="s1">comments = []</span>
        <span class="s1">success = </span><span class="s2">True</span>
        <span class="s1">NL = Literal(</span><span class="s5">r&quot;\n&quot;</span><span class="s1">).add_parse_action(replace_with(</span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s1">)).ignore(quoted_string)</span>
        <span class="s1">BOM = </span><span class="s5">&quot;</span><span class="s2">\ufeff</span><span class="s5">&quot;</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">tests:</span>
            <span class="s2">if </span><span class="s1">comment </span><span class="s2">is not None and </span><span class="s1">comment.matches(t</span><span class="s2">, False</span><span class="s1">) </span><span class="s2">or </span><span class="s1">comments </span><span class="s2">and not </span><span class="s1">t:</span>
                <span class="s1">comments.append(</span>
                    <span class="s1">pyparsing_test.with_line_numbers(t) </span><span class="s2">if </span><span class="s1">with_line_numbers </span><span class="s2">else </span><span class="s1">t</span>
                <span class="s1">)</span>
                <span class="s2">continue</span>
            <span class="s2">if not </span><span class="s1">t:</span>
                <span class="s2">continue</span>
            <span class="s1">out = [</span>
                <span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot; </span><span class="s1">+ </span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s1">.join(comments) </span><span class="s2">if </span><span class="s1">comments </span><span class="s2">else </span><span class="s5">&quot;&quot;</span><span class="s2">,</span>
                <span class="s1">pyparsing_test.with_line_numbers(t) </span><span class="s2">if </span><span class="s1">with_line_numbers </span><span class="s2">else </span><span class="s1">t</span><span class="s2">,</span>
            <span class="s1">]</span>
            <span class="s1">comments = []</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s0"># convert newline marks to actual newlines, and strip leading BOM if present</span>
                <span class="s1">t = NL.transform_string(t.lstrip(BOM))</span>
                <span class="s1">result = self.parse_string(t</span><span class="s2">, </span><span class="s1">parse_all=parseAll)</span>
            <span class="s2">except </span><span class="s1">ParseBaseException </span><span class="s2">as </span><span class="s1">pe:</span>
                <span class="s1">fatal = </span><span class="s5">&quot;(FATAL)&quot; </span><span class="s2">if </span><span class="s1">isinstance(pe</span><span class="s2">, </span><span class="s1">ParseFatalException) </span><span class="s2">else </span><span class="s5">&quot;&quot;</span>
                <span class="s1">out.append(pe.explain())</span>
                <span class="s1">out.append(</span><span class="s5">&quot;FAIL: &quot; </span><span class="s1">+ str(pe))</span>
                <span class="s2">if </span><span class="s1">ParserElement.verbose_stacktrace:</span>
                    <span class="s1">out.extend(traceback.format_tb(pe.__traceback__))</span>
                <span class="s1">success = success </span><span class="s2">and </span><span class="s1">failureTests</span>
                <span class="s1">result = pe</span>
            <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">exc:</span>
                <span class="s1">out.append(</span><span class="s5">&quot;FAIL-EXCEPTION: {}: {}&quot;</span><span class="s1">.format(type(exc).__name__</span><span class="s2">, </span><span class="s1">exc))</span>
                <span class="s2">if </span><span class="s1">ParserElement.verbose_stacktrace:</span>
                    <span class="s1">out.extend(traceback.format_tb(exc.__traceback__))</span>
                <span class="s1">success = success </span><span class="s2">and </span><span class="s1">failureTests</span>
                <span class="s1">result = exc</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">success = success </span><span class="s2">and not </span><span class="s1">failureTests</span>
                <span class="s2">if </span><span class="s1">postParse </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s1">pp_value = postParse(t</span><span class="s2">, </span><span class="s1">result)</span>
                        <span class="s2">if </span><span class="s1">pp_value </span><span class="s2">is not None</span><span class="s1">:</span>
                            <span class="s2">if </span><span class="s1">isinstance(pp_value</span><span class="s2">, </span><span class="s1">ParseResults):</span>
                                <span class="s1">out.append(pp_value.dump())</span>
                            <span class="s2">else</span><span class="s1">:</span>
                                <span class="s1">out.append(str(pp_value))</span>
                        <span class="s2">else</span><span class="s1">:</span>
                            <span class="s1">out.append(result.dump())</span>
                    <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
                        <span class="s1">out.append(result.dump(full=fullDump))</span>
                        <span class="s1">out.append(</span>
                            <span class="s5">&quot;{} failed: {}: {}&quot;</span><span class="s1">.format(</span>
                                <span class="s1">postParse.__name__</span><span class="s2">, </span><span class="s1">type(e).__name__</span><span class="s2">, </span><span class="s1">e</span>
                            <span class="s1">)</span>
                        <span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">out.append(result.dump(full=fullDump))</span>
            <span class="s1">out.append(</span><span class="s5">&quot;&quot;</span><span class="s1">)</span>

            <span class="s2">if </span><span class="s1">printResults:</span>
                <span class="s1">print_(</span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s1">.join(out))</span>

            <span class="s1">allResults.append((t</span><span class="s2">, </span><span class="s1">result))</span>

        <span class="s2">return </span><span class="s1">success</span><span class="s2">, </span><span class="s1">allResults</span>

    <span class="s2">def </span><span class="s1">create_diagram(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">output_html: Union[TextIO</span><span class="s2">, </span><span class="s1">Path</span><span class="s2">, </span><span class="s1">str]</span><span class="s2">,</span>
        <span class="s1">vertical: int = </span><span class="s3">3</span><span class="s2">,</span>
        <span class="s1">show_results_names: bool = </span><span class="s2">False,</span>
        <span class="s1">show_groups: bool = </span><span class="s2">False,</span>
        <span class="s1">**kwargs</span><span class="s2">,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Create a railroad diagram for the parser. 
 
        Parameters: 
        - output_html (str or file-like object) - output target for generated 
          diagram HTML 
        - vertical (int) - threshold for formatting multiple alternatives vertically 
          instead of horizontally (default=3) 
        - show_results_names - bool flag whether diagram should show annotations for 
          defined results names 
        - show_groups - bool flag whether groups should be highlighted with an unlabeled surrounding box 
        Additional diagram-formatting keyword arguments can also be included; 
        see railroad.Diagram class. 
        &quot;&quot;&quot;</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">from </span><span class="s1">.diagram </span><span class="s2">import </span><span class="s1">to_railroad</span><span class="s2">, </span><span class="s1">railroad_to_html</span>
        <span class="s2">except </span><span class="s1">ImportError </span><span class="s2">as </span><span class="s1">ie:</span>
            <span class="s2">raise </span><span class="s1">Exception(</span>
                <span class="s5">&quot;must ``pip install pyparsing[diagrams]`` to generate parser railroad diagrams&quot;</span>
            <span class="s1">) </span><span class="s2">from </span><span class="s1">ie</span>

        <span class="s1">self.streamline()</span>

        <span class="s1">railroad = to_railroad(</span>
            <span class="s1">self</span><span class="s2">,</span>
            <span class="s1">vertical=vertical</span><span class="s2">,</span>
            <span class="s1">show_results_names=show_results_names</span><span class="s2">,</span>
            <span class="s1">show_groups=show_groups</span><span class="s2">,</span>
            <span class="s1">diagram_kwargs=kwargs</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">isinstance(output_html</span><span class="s2">, </span><span class="s1">(str</span><span class="s2">, </span><span class="s1">Path)):</span>
            <span class="s2">with </span><span class="s1">open(output_html</span><span class="s2">, </span><span class="s5">&quot;w&quot;</span><span class="s2">, </span><span class="s1">encoding=</span><span class="s5">&quot;utf-8&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">diag_file:</span>
                <span class="s1">diag_file.write(railroad_to_html(railroad))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># we were passed a file-like object, just write to it</span>
            <span class="s1">output_html.write(railroad_to_html(railroad))</span>

    <span class="s1">setDefaultWhitespaceChars = set_default_whitespace_chars</span>
    <span class="s1">inlineLiteralsUsing = inline_literals_using</span>
    <span class="s1">setResultsName = set_results_name</span>
    <span class="s1">setBreak = set_break</span>
    <span class="s1">setParseAction = set_parse_action</span>
    <span class="s1">addParseAction = add_parse_action</span>
    <span class="s1">addCondition = add_condition</span>
    <span class="s1">setFailAction = set_fail_action</span>
    <span class="s1">tryParse = try_parse</span>
    <span class="s1">canParseNext = can_parse_next</span>
    <span class="s1">resetCache = reset_cache</span>
    <span class="s1">enableLeftRecursion = enable_left_recursion</span>
    <span class="s1">enablePackrat = enable_packrat</span>
    <span class="s1">parseString = parse_string</span>
    <span class="s1">scanString = scan_string</span>
    <span class="s1">searchString = search_string</span>
    <span class="s1">transformString = transform_string</span>
    <span class="s1">setWhitespaceChars = set_whitespace_chars</span>
    <span class="s1">parseWithTabs = parse_with_tabs</span>
    <span class="s1">setDebugActions = set_debug_actions</span>
    <span class="s1">setDebug = set_debug</span>
    <span class="s1">defaultName = default_name</span>
    <span class="s1">setName = set_name</span>
    <span class="s1">parseFile = parse_file</span>
    <span class="s1">runTests = run_tests</span>
    <span class="s1">ignoreWhitespace = ignore_whitespace</span>
    <span class="s1">leaveWhitespace = leave_whitespace</span>


<span class="s2">class </span><span class="s1">_PendingSkip(ParserElement):</span>
    <span class="s0"># internal placeholder class to hold a place were '...' is added to a parser element,</span>
    <span class="s0"># once another ParserElement is added, this placeholder will be replaced with a SkipTo</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">expr: ParserElement</span><span class="s2">, </span><span class="s1">must_skip: bool = </span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.anchor = expr</span>
        <span class="s1">self.must_skip = must_skip</span>

    <span class="s2">def </span><span class="s1">_generateDefaultName(self):</span>
        <span class="s2">return </span><span class="s1">str(self.anchor + Empty()).replace(</span><span class="s5">&quot;Empty&quot;</span><span class="s2">, </span><span class="s5">&quot;...&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__add__(self</span><span class="s2">, </span><span class="s1">other) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s1">skipper = SkipTo(other).set_name(</span><span class="s5">&quot;...&quot;</span><span class="s1">)(</span><span class="s5">&quot;_skipped*&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.must_skip:</span>

            <span class="s2">def </span><span class="s1">must_skip(t):</span>
                <span class="s2">if not </span><span class="s1">t._skipped </span><span class="s2">or </span><span class="s1">t._skipped.as_list() == [</span><span class="s5">&quot;&quot;</span><span class="s1">]:</span>
                    <span class="s2">del </span><span class="s1">t[</span><span class="s3">0</span><span class="s1">]</span>
                    <span class="s1">t.pop(</span><span class="s5">&quot;_skipped&quot;</span><span class="s2">, None</span><span class="s1">)</span>

            <span class="s2">def </span><span class="s1">show_skip(t):</span>
                <span class="s2">if </span><span class="s1">t._skipped.as_list()[-</span><span class="s3">1</span><span class="s1">:] == [</span><span class="s5">&quot;&quot;</span><span class="s1">]:</span>
                    <span class="s1">t.pop(</span><span class="s5">&quot;_skipped&quot;</span><span class="s1">)</span>
                    <span class="s1">t[</span><span class="s5">&quot;_skipped&quot;</span><span class="s1">] = </span><span class="s5">&quot;missing &lt;&quot; </span><span class="s1">+ repr(self.anchor) + </span><span class="s5">&quot;&gt;&quot;</span>

            <span class="s2">return </span><span class="s1">(</span>
                <span class="s1">self.anchor + skipper().add_parse_action(must_skip)</span>
                <span class="s1">| skipper().add_parse_action(show_skip)</span>
            <span class="s1">) + other</span>

        <span class="s2">return </span><span class="s1">self.anchor + skipper + other</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s1">self.defaultName</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s2">raise </span><span class="s1">Exception(</span>
            <span class="s5">&quot;use of `...` expression without following SkipTo target expression&quot;</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">Token(ParserElement):</span>
    <span class="s4">&quot;&quot;&quot;Abstract :class:`ParserElement` subclass, for defining atomic 
    matching patterns. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">super().__init__(savelist=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_generateDefaultName(self):</span>
        <span class="s2">return </span><span class="s1">type(self).__name__</span>


<span class="s2">class </span><span class="s1">Empty(Token):</span>
    <span class="s4">&quot;&quot;&quot; 
    An empty token, will always match. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.mayReturnEmpty = </span><span class="s2">True</span>
        <span class="s1">self.mayIndexError = </span><span class="s2">False</span>


<span class="s2">class </span><span class="s1">NoMatch(Token):</span>
    <span class="s4">&quot;&quot;&quot; 
    A token that will never match. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.mayReturnEmpty = </span><span class="s2">True</span>
        <span class="s1">self.mayIndexError = </span><span class="s2">False</span>
        <span class="s1">self.errmsg = </span><span class="s5">&quot;Unmatchable token&quot;</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">self.errmsg</span><span class="s2">, </span><span class="s1">self)</span>


<span class="s2">class </span><span class="s1">Literal(Token):</span>
    <span class="s4">&quot;&quot;&quot; 
    Token to exactly match a specified string. 
 
    Example:: 
 
        Literal('blah').parse_string('blah')  # -&gt; ['blah'] 
        Literal('blah').parse_string('blahfooblah')  # -&gt; ['blah'] 
        Literal('blah').parse_string('bla')  # -&gt; Exception: Expected &quot;blah&quot; 
 
    For case-insensitive matching, use :class:`CaselessLiteral`. 
 
    For keyword matching (force word break before and after the matched string), 
    use :class:`Keyword` or :class:`CaselessKeyword`. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">match_string: str = </span><span class="s5">&quot;&quot;</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">matchString: str = </span><span class="s5">&quot;&quot;</span><span class="s1">):</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">match_string = matchString </span><span class="s2">or </span><span class="s1">match_string</span>
        <span class="s1">self.match = match_string</span>
        <span class="s1">self.matchLen = len(match_string)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self.firstMatchChar = match_string[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s2">except </span><span class="s1">IndexError:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;null string passed to Literal; use Empty() instead&quot;</span><span class="s1">)</span>
        <span class="s1">self.errmsg = </span><span class="s5">&quot;Expected &quot; </span><span class="s1">+ self.name</span>
        <span class="s1">self.mayReturnEmpty = </span><span class="s2">False</span>
        <span class="s1">self.mayIndexError = </span><span class="s2">False</span>

        <span class="s0"># Performance tuning: modify __class__ to select</span>
        <span class="s0"># a parseImpl optimized for single-character check</span>
        <span class="s2">if </span><span class="s1">self.matchLen == </span><span class="s3">1 </span><span class="s2">and </span><span class="s1">type(self) </span><span class="s2">is </span><span class="s1">Literal:</span>
            <span class="s1">self.__class__ = _SingleCharLiteral</span>

    <span class="s2">def </span><span class="s1">_generateDefaultName(self):</span>
        <span class="s2">return </span><span class="s1">repr(self.match)</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">instring[loc] == self.firstMatchChar </span><span class="s2">and </span><span class="s1">instring.startswith(</span>
            <span class="s1">self.match</span><span class="s2">, </span><span class="s1">loc</span>
        <span class="s1">):</span>
            <span class="s2">return </span><span class="s1">loc + self.matchLen</span><span class="s2">, </span><span class="s1">self.match</span>
        <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">self.errmsg</span><span class="s2">, </span><span class="s1">self)</span>


<span class="s2">class </span><span class="s1">_SingleCharLiteral(Literal):</span>
    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">instring[loc] == self.firstMatchChar:</span>
            <span class="s2">return </span><span class="s1">loc + </span><span class="s3">1</span><span class="s2">, </span><span class="s1">self.match</span>
        <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">self.errmsg</span><span class="s2">, </span><span class="s1">self)</span>


<span class="s1">ParserElement._literalStringClass = Literal</span>


<span class="s2">class </span><span class="s1">Keyword(Token):</span>
    <span class="s4">&quot;&quot;&quot; 
    Token to exactly match a specified string as a keyword, that is, 
    it must be immediately followed by a non-keyword character.  Compare 
    with :class:`Literal`: 
 
    - ``Literal(&quot;if&quot;)`` will match the leading ``'if'`` in 
      ``'ifAndOnlyIf'``. 
    - ``Keyword(&quot;if&quot;)`` will not; it will only match the leading 
      ``'if'`` in ``'if x=1'``, or ``'if(y==2)'`` 
 
    Accepts two optional constructor arguments in addition to the 
    keyword string: 
 
    - ``identChars`` is a string of characters that would be valid 
      identifier characters, defaulting to all alphanumerics + &quot;_&quot; and 
      &quot;$&quot; 
    - ``caseless`` allows case-insensitive matching, default is ``False``. 
 
    Example:: 
 
        Keyword(&quot;start&quot;).parse_string(&quot;start&quot;)  # -&gt; ['start'] 
        Keyword(&quot;start&quot;).parse_string(&quot;starting&quot;)  # -&gt; Exception 
 
    For case-insensitive matching, use :class:`CaselessKeyword`. 
    &quot;&quot;&quot;</span>

    <span class="s1">DEFAULT_KEYWORD_CHARS = alphanums + </span><span class="s5">&quot;_$&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">match_string: str = </span><span class="s5">&quot;&quot;</span><span class="s2">,</span>
        <span class="s1">ident_chars: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">caseless: bool = </span><span class="s2">False,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">matchString: str = </span><span class="s5">&quot;&quot;</span><span class="s2">,</span>
        <span class="s1">identChars: typing.Optional[str] = </span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">identChars = identChars </span><span class="s2">or </span><span class="s1">ident_chars</span>
        <span class="s2">if </span><span class="s1">identChars </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">identChars = Keyword.DEFAULT_KEYWORD_CHARS</span>
        <span class="s1">match_string = matchString </span><span class="s2">or </span><span class="s1">match_string</span>
        <span class="s1">self.match = match_string</span>
        <span class="s1">self.matchLen = len(match_string)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self.firstMatchChar = match_string[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s2">except </span><span class="s1">IndexError:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;null string passed to Keyword; use Empty() instead&quot;</span><span class="s1">)</span>
        <span class="s1">self.errmsg = </span><span class="s5">&quot;Expected {} {}&quot;</span><span class="s1">.format(type(self).__name__</span><span class="s2">, </span><span class="s1">self.name)</span>
        <span class="s1">self.mayReturnEmpty = </span><span class="s2">False</span>
        <span class="s1">self.mayIndexError = </span><span class="s2">False</span>
        <span class="s1">self.caseless = caseless</span>
        <span class="s2">if </span><span class="s1">caseless:</span>
            <span class="s1">self.caselessmatch = match_string.upper()</span>
            <span class="s1">identChars = identChars.upper()</span>
        <span class="s1">self.identChars = set(identChars)</span>

    <span class="s2">def </span><span class="s1">_generateDefaultName(self):</span>
        <span class="s2">return </span><span class="s1">repr(self.match)</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s1">errmsg = self.errmsg</span>
        <span class="s1">errloc = loc</span>
        <span class="s2">if </span><span class="s1">self.caseless:</span>
            <span class="s2">if </span><span class="s1">instring[loc : loc + self.matchLen].upper() == self.caselessmatch:</span>
                <span class="s2">if </span><span class="s1">loc == </span><span class="s3">0 </span><span class="s2">or </span><span class="s1">instring[loc - </span><span class="s3">1</span><span class="s1">].upper() </span><span class="s2">not in </span><span class="s1">self.identChars:</span>
                    <span class="s2">if </span><span class="s1">(</span>
                        <span class="s1">loc &gt;= len(instring) - self.matchLen</span>
                        <span class="s2">or </span><span class="s1">instring[loc + self.matchLen].upper() </span><span class="s2">not in </span><span class="s1">self.identChars</span>
                    <span class="s1">):</span>
                        <span class="s2">return </span><span class="s1">loc + self.matchLen</span><span class="s2">, </span><span class="s1">self.match</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s0"># followed by keyword char</span>
                        <span class="s1">errmsg += </span><span class="s5">&quot;, was immediately followed by keyword character&quot;</span>
                        <span class="s1">errloc = loc + self.matchLen</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s0"># preceded by keyword char</span>
                    <span class="s1">errmsg += </span><span class="s5">&quot;, keyword was immediately preceded by keyword character&quot;</span>
                    <span class="s1">errloc = loc - </span><span class="s3">1</span>
            <span class="s0"># else no match just raise plain exception</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">instring[loc] == self.firstMatchChar</span>
                <span class="s2">and </span><span class="s1">self.matchLen == </span><span class="s3">1</span>
                <span class="s2">or </span><span class="s1">instring.startswith(self.match</span><span class="s2">, </span><span class="s1">loc)</span>
            <span class="s1">):</span>
                <span class="s2">if </span><span class="s1">loc == </span><span class="s3">0 </span><span class="s2">or </span><span class="s1">instring[loc - </span><span class="s3">1</span><span class="s1">] </span><span class="s2">not in </span><span class="s1">self.identChars:</span>
                    <span class="s2">if </span><span class="s1">(</span>
                        <span class="s1">loc &gt;= len(instring) - self.matchLen</span>
                        <span class="s2">or </span><span class="s1">instring[loc + self.matchLen] </span><span class="s2">not in </span><span class="s1">self.identChars</span>
                    <span class="s1">):</span>
                        <span class="s2">return </span><span class="s1">loc + self.matchLen</span><span class="s2">, </span><span class="s1">self.match</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s0"># followed by keyword char</span>
                        <span class="s1">errmsg += (</span>
                            <span class="s5">&quot;, keyword was immediately followed by keyword character&quot;</span>
                        <span class="s1">)</span>
                        <span class="s1">errloc = loc + self.matchLen</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s0"># preceded by keyword char</span>
                    <span class="s1">errmsg += </span><span class="s5">&quot;, keyword was immediately preceded by keyword character&quot;</span>
                    <span class="s1">errloc = loc - </span><span class="s3">1</span>
            <span class="s0"># else no match just raise plain exception</span>

        <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">errloc</span><span class="s2">, </span><span class="s1">errmsg</span><span class="s2">, </span><span class="s1">self)</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">set_default_keyword_chars(chars) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Overrides the default characters used by :class:`Keyword` expressions. 
        &quot;&quot;&quot;</span>
        <span class="s1">Keyword.DEFAULT_KEYWORD_CHARS = chars</span>

    <span class="s1">setDefaultKeywordChars = set_default_keyword_chars</span>


<span class="s2">class </span><span class="s1">CaselessLiteral(Literal):</span>
    <span class="s4">&quot;&quot;&quot; 
    Token to match a specified string, ignoring case of letters. 
    Note: the matched results will always be in the case of the given 
    match string, NOT the case of the input text. 
 
    Example:: 
 
        CaselessLiteral(&quot;CMD&quot;)[1, ...].parse_string(&quot;cmd CMD Cmd10&quot;) 
        # -&gt; ['CMD', 'CMD', 'CMD'] 
 
    (Contrast with example for :class:`CaselessKeyword`.) 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">match_string: str = </span><span class="s5">&quot;&quot;</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">matchString: str = </span><span class="s5">&quot;&quot;</span><span class="s1">):</span>
        <span class="s1">match_string = matchString </span><span class="s2">or </span><span class="s1">match_string</span>
        <span class="s1">super().__init__(match_string.upper())</span>
        <span class="s0"># Preserve the defining literal.</span>
        <span class="s1">self.returnString = match_string</span>
        <span class="s1">self.errmsg = </span><span class="s5">&quot;Expected &quot; </span><span class="s1">+ self.name</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">instring[loc : loc + self.matchLen].upper() == self.match:</span>
            <span class="s2">return </span><span class="s1">loc + self.matchLen</span><span class="s2">, </span><span class="s1">self.returnString</span>
        <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">self.errmsg</span><span class="s2">, </span><span class="s1">self)</span>


<span class="s2">class </span><span class="s1">CaselessKeyword(Keyword):</span>
    <span class="s4">&quot;&quot;&quot; 
    Caseless version of :class:`Keyword`. 
 
    Example:: 
 
        CaselessKeyword(&quot;CMD&quot;)[1, ...].parse_string(&quot;cmd CMD Cmd10&quot;) 
        # -&gt; ['CMD', 'CMD'] 
 
    (Contrast with example for :class:`CaselessLiteral`.) 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">match_string: str = </span><span class="s5">&quot;&quot;</span><span class="s2">,</span>
        <span class="s1">ident_chars: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">matchString: str = </span><span class="s5">&quot;&quot;</span><span class="s2">,</span>
        <span class="s1">identChars: typing.Optional[str] = </span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s1">identChars = identChars </span><span class="s2">or </span><span class="s1">ident_chars</span>
        <span class="s1">match_string = matchString </span><span class="s2">or </span><span class="s1">match_string</span>
        <span class="s1">super().__init__(match_string</span><span class="s2">, </span><span class="s1">identChars</span><span class="s2">, </span><span class="s1">caseless=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">CloseMatch(Token):</span>
    <span class="s4">&quot;&quot;&quot;A variation on :class:`Literal` which matches &quot;close&quot; matches, 
    that is, strings with at most 'n' mismatching characters. 
    :class:`CloseMatch` takes parameters: 
 
    - ``match_string`` - string to be matched 
    - ``caseless`` - a boolean indicating whether to ignore casing when comparing characters 
    - ``max_mismatches`` - (``default=1``) maximum number of 
      mismatches allowed to count as a match 
 
    The results from a successful parse will contain the matched text 
    from the input string and the following named results: 
 
    - ``mismatches`` - a list of the positions within the 
      match_string where mismatches were found 
    - ``original`` - the original match_string used to compare 
      against the input string 
 
    If ``mismatches`` is an empty list, then the match was an exact 
    match. 
 
    Example:: 
 
        patt = CloseMatch(&quot;ATCATCGAATGGA&quot;) 
        patt.parse_string(&quot;ATCATCGAAXGGA&quot;) # -&gt; (['ATCATCGAAXGGA'], {'mismatches': [[9]], 'original': ['ATCATCGAATGGA']}) 
        patt.parse_string(&quot;ATCAXCGAAXGGA&quot;) # -&gt; Exception: Expected 'ATCATCGAATGGA' (with up to 1 mismatches) (at char 0), (line:1, col:1) 
 
        # exact match 
        patt.parse_string(&quot;ATCATCGAATGGA&quot;) # -&gt; (['ATCATCGAATGGA'], {'mismatches': [[]], 'original': ['ATCATCGAATGGA']}) 
 
        # close match allowing up to 2 mismatches 
        patt = CloseMatch(&quot;ATCATCGAATGGA&quot;, max_mismatches=2) 
        patt.parse_string(&quot;ATCAXCGAAXGGA&quot;) # -&gt; (['ATCAXCGAAXGGA'], {'mismatches': [[4, 9]], 'original': ['ATCATCGAATGGA']}) 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">match_string: str</span><span class="s2">,</span>
        <span class="s1">max_mismatches: int = </span><span class="s2">None,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">maxMismatches: int = </span><span class="s3">1</span><span class="s2">,</span>
        <span class="s1">caseless=</span><span class="s2">False,</span>
    <span class="s1">):</span>
        <span class="s1">maxMismatches = max_mismatches </span><span class="s2">if </span><span class="s1">max_mismatches </span><span class="s2">is not None else </span><span class="s1">maxMismatches</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.match_string = match_string</span>
        <span class="s1">self.maxMismatches = maxMismatches</span>
        <span class="s1">self.errmsg = </span><span class="s5">&quot;Expected {!r} (with up to {} mismatches)&quot;</span><span class="s1">.format(</span>
            <span class="s1">self.match_string</span><span class="s2">, </span><span class="s1">self.maxMismatches</span>
        <span class="s1">)</span>
        <span class="s1">self.caseless = caseless</span>
        <span class="s1">self.mayIndexError = </span><span class="s2">False</span>
        <span class="s1">self.mayReturnEmpty = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">_generateDefaultName(self):</span>
        <span class="s2">return </span><span class="s5">&quot;{}:{!r}&quot;</span><span class="s1">.format(type(self).__name__</span><span class="s2">, </span><span class="s1">self.match_string)</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s1">start = loc</span>
        <span class="s1">instrlen = len(instring)</span>
        <span class="s1">maxloc = start + len(self.match_string)</span>

        <span class="s2">if </span><span class="s1">maxloc &lt;= instrlen:</span>
            <span class="s1">match_string = self.match_string</span>
            <span class="s1">match_stringloc = </span><span class="s3">0</span>
            <span class="s1">mismatches = []</span>
            <span class="s1">maxMismatches = self.maxMismatches</span>

            <span class="s2">for </span><span class="s1">match_stringloc</span><span class="s2">, </span><span class="s1">s_m </span><span class="s2">in </span><span class="s1">enumerate(</span>
                <span class="s1">zip(instring[loc:maxloc]</span><span class="s2">, </span><span class="s1">match_string)</span>
            <span class="s1">):</span>
                <span class="s1">src</span><span class="s2">, </span><span class="s1">mat = s_m</span>
                <span class="s2">if </span><span class="s1">self.caseless:</span>
                    <span class="s1">src</span><span class="s2">, </span><span class="s1">mat = src.lower()</span><span class="s2">, </span><span class="s1">mat.lower()</span>

                <span class="s2">if </span><span class="s1">src != mat:</span>
                    <span class="s1">mismatches.append(match_stringloc)</span>
                    <span class="s2">if </span><span class="s1">len(mismatches) &gt; maxMismatches:</span>
                        <span class="s2">break</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">loc = start + match_stringloc + </span><span class="s3">1</span>
                <span class="s1">results = ParseResults([instring[start:loc]])</span>
                <span class="s1">results[</span><span class="s5">&quot;original&quot;</span><span class="s1">] = match_string</span>
                <span class="s1">results[</span><span class="s5">&quot;mismatches&quot;</span><span class="s1">] = mismatches</span>
                <span class="s2">return </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">results</span>

        <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">self.errmsg</span><span class="s2">, </span><span class="s1">self)</span>


<span class="s2">class </span><span class="s1">Word(Token):</span>
    <span class="s4">&quot;&quot;&quot;Token for matching words composed of allowed character sets. 
    Parameters: 
    - ``init_chars`` - string of all characters that should be used to 
      match as a word; &quot;ABC&quot; will match &quot;AAA&quot;, &quot;ABAB&quot;, &quot;CBAC&quot;, etc.; 
      if ``body_chars`` is also specified, then this is the string of 
      initial characters 
    - ``body_chars`` - string of characters that 
      can be used for matching after a matched initial character as 
      given in ``init_chars``; if omitted, same as the initial characters 
      (default=``None``) 
    - ``min`` - minimum number of characters to match (default=1) 
    - ``max`` - maximum number of characters to match (default=0) 
    - ``exact`` - exact number of characters to match (default=0) 
    - ``as_keyword`` - match as a keyword (default=``False``) 
    - ``exclude_chars`` - characters that might be 
      found in the input ``body_chars`` string but which should not be 
      accepted for matching ;useful to define a word of all 
      printables except for one or two characters, for instance 
      (default=``None``) 
 
    :class:`srange` is useful for defining custom character set strings 
    for defining :class:`Word` expressions, using range notation from 
    regular expression character sets. 
 
    A common mistake is to use :class:`Word` to match a specific literal 
    string, as in ``Word(&quot;Address&quot;)``. Remember that :class:`Word` 
    uses the string argument to define *sets* of matchable characters. 
    This expression would match &quot;Add&quot;, &quot;AAA&quot;, &quot;dAred&quot;, or any other word 
    made up of the characters 'A', 'd', 'r', 'e', and 's'. To match an 
    exact literal string, use :class:`Literal` or :class:`Keyword`. 
 
    pyparsing includes helper strings for building Words: 
 
    - :class:`alphas` 
    - :class:`nums` 
    - :class:`alphanums` 
    - :class:`hexnums` 
    - :class:`alphas8bit` (alphabetic characters in ASCII range 128-255 
      - accented, tilded, umlauted, etc.) 
    - :class:`punc8bit` (non-alphabetic characters in ASCII range 
      128-255 - currency, symbols, superscripts, diacriticals, etc.) 
    - :class:`printables` (any non-whitespace character) 
 
    ``alphas``, ``nums``, and ``printables`` are also defined in several 
    Unicode sets - see :class:`pyparsing_unicode``. 
 
    Example:: 
 
        # a word composed of digits 
        integer = Word(nums) # equivalent to Word(&quot;0123456789&quot;) or Word(srange(&quot;0-9&quot;)) 
 
        # a word with a leading capital, and zero or more lowercase 
        capital_word = Word(alphas.upper(), alphas.lower()) 
 
        # hostnames are alphanumeric, with leading alpha, and '-' 
        hostname = Word(alphas, alphanums + '-') 
 
        # roman numeral (not a strict parser, accepts invalid mix of characters) 
        roman = Word(&quot;IVXLCDM&quot;) 
 
        # any string of non-whitespace characters, except for ',' 
        csv_value = Word(printables, exclude_chars=&quot;,&quot;) 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">init_chars: str = </span><span class="s5">&quot;&quot;</span><span class="s2">,</span>
        <span class="s1">body_chars: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">min: int = </span><span class="s3">1</span><span class="s2">,</span>
        <span class="s1">max: int = </span><span class="s3">0</span><span class="s2">,</span>
        <span class="s1">exact: int = </span><span class="s3">0</span><span class="s2">,</span>
        <span class="s1">as_keyword: bool = </span><span class="s2">False,</span>
        <span class="s1">exclude_chars: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">initChars: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">bodyChars: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">asKeyword: bool = </span><span class="s2">False,</span>
        <span class="s1">excludeChars: typing.Optional[str] = </span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s1">initChars = initChars </span><span class="s2">or </span><span class="s1">init_chars</span>
        <span class="s1">bodyChars = bodyChars </span><span class="s2">or </span><span class="s1">body_chars</span>
        <span class="s1">asKeyword = asKeyword </span><span class="s2">or </span><span class="s1">as_keyword</span>
        <span class="s1">excludeChars = excludeChars </span><span class="s2">or </span><span class="s1">exclude_chars</span>
        <span class="s1">super().__init__()</span>
        <span class="s2">if not </span><span class="s1">initChars:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s5">&quot;invalid {}, initChars cannot be empty string&quot;</span><span class="s1">.format(</span>
                    <span class="s1">type(self).__name__</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s1">initChars = set(initChars)</span>
        <span class="s1">self.initChars = initChars</span>
        <span class="s2">if </span><span class="s1">excludeChars:</span>
            <span class="s1">excludeChars = set(excludeChars)</span>
            <span class="s1">initChars -= excludeChars</span>
            <span class="s2">if </span><span class="s1">bodyChars:</span>
                <span class="s1">bodyChars = set(bodyChars) - excludeChars</span>
        <span class="s1">self.initCharsOrig = </span><span class="s5">&quot;&quot;</span><span class="s1">.join(sorted(initChars))</span>

        <span class="s2">if </span><span class="s1">bodyChars:</span>
            <span class="s1">self.bodyCharsOrig = </span><span class="s5">&quot;&quot;</span><span class="s1">.join(sorted(bodyChars))</span>
            <span class="s1">self.bodyChars = set(bodyChars)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.bodyCharsOrig = </span><span class="s5">&quot;&quot;</span><span class="s1">.join(sorted(initChars))</span>
            <span class="s1">self.bodyChars = set(initChars)</span>

        <span class="s1">self.maxSpecified = max &gt; </span><span class="s3">0</span>

        <span class="s2">if </span><span class="s1">min &lt; </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s5">&quot;cannot specify a minimum length &lt; 1; use Opt(Word()) if zero-length word is permitted&quot;</span>
            <span class="s1">)</span>

        <span class="s1">self.minLen = min</span>

        <span class="s2">if </span><span class="s1">max &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">self.maxLen = max</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.maxLen = _MAX_INT</span>

        <span class="s2">if </span><span class="s1">exact &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">self.maxLen = exact</span>
            <span class="s1">self.minLen = exact</span>

        <span class="s1">self.errmsg = </span><span class="s5">&quot;Expected &quot; </span><span class="s1">+ self.name</span>
        <span class="s1">self.mayIndexError = </span><span class="s2">False</span>
        <span class="s1">self.asKeyword = asKeyword</span>

        <span class="s0"># see if we can make a regex for this Word</span>
        <span class="s2">if </span><span class="s5">&quot; &quot; </span><span class="s2">not in </span><span class="s1">self.initChars | self.bodyChars </span><span class="s2">and </span><span class="s1">(min == </span><span class="s3">1 </span><span class="s2">and </span><span class="s1">exact == </span><span class="s3">0</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">self.bodyChars == self.initChars:</span>
                <span class="s2">if </span><span class="s1">max == </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s1">repeat = </span><span class="s5">&quot;+&quot;</span>
                <span class="s2">elif </span><span class="s1">max == </span><span class="s3">1</span><span class="s1">:</span>
                    <span class="s1">repeat = </span><span class="s5">&quot;&quot;</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">repeat = </span><span class="s5">&quot;{{{},{}}}&quot;</span><span class="s1">.format(</span>
                        <span class="s1">self.minLen</span><span class="s2">, </span><span class="s5">&quot;&quot; </span><span class="s2">if </span><span class="s1">self.maxLen == _MAX_INT </span><span class="s2">else </span><span class="s1">self.maxLen</span>
                    <span class="s1">)</span>
                <span class="s1">self.reString = </span><span class="s5">&quot;[{}]{}&quot;</span><span class="s1">.format(</span>
                    <span class="s1">_collapse_string_to_ranges(self.initChars)</span><span class="s2">,</span>
                    <span class="s1">repeat</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">len(self.initChars) == </span><span class="s3">1</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">max == </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s1">repeat = </span><span class="s5">&quot;*&quot;</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">repeat = </span><span class="s5">&quot;{{0,{}}}&quot;</span><span class="s1">.format(max - </span><span class="s3">1</span><span class="s1">)</span>
                <span class="s1">self.reString = </span><span class="s5">&quot;{}[{}]{}&quot;</span><span class="s1">.format(</span>
                    <span class="s1">re.escape(self.initCharsOrig)</span><span class="s2">,</span>
                    <span class="s1">_collapse_string_to_ranges(self.bodyChars)</span><span class="s2">,</span>
                    <span class="s1">repeat</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">max == </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s1">repeat = </span><span class="s5">&quot;*&quot;</span>
                <span class="s2">elif </span><span class="s1">max == </span><span class="s3">2</span><span class="s1">:</span>
                    <span class="s1">repeat = </span><span class="s5">&quot;&quot;</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">repeat = </span><span class="s5">&quot;{{0,{}}}&quot;</span><span class="s1">.format(max - </span><span class="s3">1</span><span class="s1">)</span>
                <span class="s1">self.reString = </span><span class="s5">&quot;[{}][{}]{}&quot;</span><span class="s1">.format(</span>
                    <span class="s1">_collapse_string_to_ranges(self.initChars)</span><span class="s2">,</span>
                    <span class="s1">_collapse_string_to_ranges(self.bodyChars)</span><span class="s2">,</span>
                    <span class="s1">repeat</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">self.asKeyword:</span>
                <span class="s1">self.reString = </span><span class="s5">r&quot;\b&quot; </span><span class="s1">+ self.reString + </span><span class="s5">r&quot;\b&quot;</span>

            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">self.re = re.compile(self.reString)</span>
            <span class="s2">except </span><span class="s1">re.error:</span>
                <span class="s1">self.re = </span><span class="s2">None</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.re_match = self.re.match</span>
                <span class="s1">self.__class__ = _WordRegex</span>

    <span class="s2">def </span><span class="s1">_generateDefaultName(self):</span>
        <span class="s2">def </span><span class="s1">charsAsStr(s):</span>
            <span class="s1">max_repr_len = </span><span class="s3">16</span>
            <span class="s1">s = _collapse_string_to_ranges(s</span><span class="s2">, </span><span class="s1">re_escape=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">len(s) &gt; max_repr_len:</span>
                <span class="s2">return </span><span class="s1">s[: max_repr_len - </span><span class="s3">3</span><span class="s1">] + </span><span class="s5">&quot;...&quot;</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">s</span>

        <span class="s2">if </span><span class="s1">self.initChars != self.bodyChars:</span>
            <span class="s1">base = </span><span class="s5">&quot;W:({}, {})&quot;</span><span class="s1">.format(</span>
                <span class="s1">charsAsStr(self.initChars)</span><span class="s2">, </span><span class="s1">charsAsStr(self.bodyChars)</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">base = </span><span class="s5">&quot;W:({})&quot;</span><span class="s1">.format(charsAsStr(self.initChars))</span>

        <span class="s0"># add length specification</span>
        <span class="s2">if </span><span class="s1">self.minLen &gt; </span><span class="s3">1 </span><span class="s2">or </span><span class="s1">self.maxLen != _MAX_INT:</span>
            <span class="s2">if </span><span class="s1">self.minLen == self.maxLen:</span>
                <span class="s2">if </span><span class="s1">self.minLen == </span><span class="s3">1</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">base[</span><span class="s3">2</span><span class="s1">:]</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">base + </span><span class="s5">&quot;{{{}}}&quot;</span><span class="s1">.format(self.minLen)</span>
            <span class="s2">elif </span><span class="s1">self.maxLen == _MAX_INT:</span>
                <span class="s2">return </span><span class="s1">base + </span><span class="s5">&quot;{{{},...}}&quot;</span><span class="s1">.format(self.minLen)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">base + </span><span class="s5">&quot;{{{},{}}}&quot;</span><span class="s1">.format(self.minLen</span><span class="s2">, </span><span class="s1">self.maxLen)</span>
        <span class="s2">return </span><span class="s1">base</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">instring[loc] </span><span class="s2">not in </span><span class="s1">self.initChars:</span>
            <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">self.errmsg</span><span class="s2">, </span><span class="s1">self)</span>

        <span class="s1">start = loc</span>
        <span class="s1">loc += </span><span class="s3">1</span>
        <span class="s1">instrlen = len(instring)</span>
        <span class="s1">bodychars = self.bodyChars</span>
        <span class="s1">maxloc = start + self.maxLen</span>
        <span class="s1">maxloc = min(maxloc</span><span class="s2">, </span><span class="s1">instrlen)</span>
        <span class="s2">while </span><span class="s1">loc &lt; maxloc </span><span class="s2">and </span><span class="s1">instring[loc] </span><span class="s2">in </span><span class="s1">bodychars:</span>
            <span class="s1">loc += </span><span class="s3">1</span>

        <span class="s1">throwException = </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s1">loc - start &lt; self.minLen:</span>
            <span class="s1">throwException = </span><span class="s2">True</span>
        <span class="s2">elif </span><span class="s1">self.maxSpecified </span><span class="s2">and </span><span class="s1">loc &lt; instrlen </span><span class="s2">and </span><span class="s1">instring[loc] </span><span class="s2">in </span><span class="s1">bodychars:</span>
            <span class="s1">throwException = </span><span class="s2">True</span>
        <span class="s2">elif </span><span class="s1">self.asKeyword:</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">start &gt; </span><span class="s3">0</span>
                <span class="s2">and </span><span class="s1">instring[start - </span><span class="s3">1</span><span class="s1">] </span><span class="s2">in </span><span class="s1">bodychars</span>
                <span class="s2">or </span><span class="s1">loc &lt; instrlen</span>
                <span class="s2">and </span><span class="s1">instring[loc] </span><span class="s2">in </span><span class="s1">bodychars</span>
            <span class="s1">):</span>
                <span class="s1">throwException = </span><span class="s2">True</span>

        <span class="s2">if </span><span class="s1">throwException:</span>
            <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">self.errmsg</span><span class="s2">, </span><span class="s1">self)</span>

        <span class="s2">return </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">instring[start:loc]</span>


<span class="s2">class </span><span class="s1">_WordRegex(Word):</span>
    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s1">result = self.re_match(instring</span><span class="s2">, </span><span class="s1">loc)</span>
        <span class="s2">if not </span><span class="s1">result:</span>
            <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">self.errmsg</span><span class="s2">, </span><span class="s1">self)</span>

        <span class="s1">loc = result.end()</span>
        <span class="s2">return </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">result.group()</span>


<span class="s2">class </span><span class="s1">Char(_WordRegex):</span>
    <span class="s4">&quot;&quot;&quot;A short-cut class for defining :class:`Word` ``(characters, exact=1)``, 
    when defining a match of any single character in a string of 
    characters. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">charset: str</span><span class="s2">,</span>
        <span class="s1">as_keyword: bool = </span><span class="s2">False,</span>
        <span class="s1">exclude_chars: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">asKeyword: bool = </span><span class="s2">False,</span>
        <span class="s1">excludeChars: typing.Optional[str] = </span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s1">asKeyword = asKeyword </span><span class="s2">or </span><span class="s1">as_keyword</span>
        <span class="s1">excludeChars = excludeChars </span><span class="s2">or </span><span class="s1">exclude_chars</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">charset</span><span class="s2">, </span><span class="s1">exact=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">asKeyword=asKeyword</span><span class="s2">, </span><span class="s1">excludeChars=excludeChars</span>
        <span class="s1">)</span>
        <span class="s1">self.reString = </span><span class="s5">&quot;[{}]&quot;</span><span class="s1">.format(_collapse_string_to_ranges(self.initChars))</span>
        <span class="s2">if </span><span class="s1">asKeyword:</span>
            <span class="s1">self.reString = </span><span class="s5">r&quot;\b{}\b&quot;</span><span class="s1">.format(self.reString)</span>
        <span class="s1">self.re = re.compile(self.reString)</span>
        <span class="s1">self.re_match = self.re.match</span>


<span class="s2">class </span><span class="s1">Regex(Token):</span>
    <span class="s4">r&quot;&quot;&quot;Token for matching strings that match a given regular 
    expression. Defined with string specifying the regular expression in 
    a form recognized by the stdlib Python  `re module &lt;https://docs.python.org/3/library/re.html&gt;`_. 
    If the given regex contains named groups (defined using ``(?P&lt;name&gt;...)``), 
    these will be preserved as named :class:`ParseResults`. 
 
    If instead of the Python stdlib ``re`` module you wish to use a different RE module 
    (such as the ``regex`` module), you can do so by building your ``Regex`` object with 
    a compiled RE that was compiled using ``regex``. 
 
    Example:: 
 
        realnum = Regex(r&quot;[+-]?\d+\.\d*&quot;) 
        # ref: https://stackoverflow.com/questions/267399/how-do-you-match-only-valid-roman-numerals-with-a-regular-expression 
        roman = Regex(r&quot;M{0,4}(CM|CD|D?{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})&quot;) 
 
        # named fields in a regex will be returned as named results 
        date = Regex(r'(?P&lt;year&gt;\d{4})-(?P&lt;month&gt;\d\d?)-(?P&lt;day&gt;\d\d?)') 
 
        # the Regex class will accept re's compiled using the regex module 
        import regex 
        parser = pp.Regex(regex.compile(r'[0-9]')) 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">pattern: Any</span><span class="s2">,</span>
        <span class="s1">flags: Union[re.RegexFlag</span><span class="s2">, </span><span class="s1">int] = </span><span class="s3">0</span><span class="s2">,</span>
        <span class="s1">as_group_list: bool = </span><span class="s2">False,</span>
        <span class="s1">as_match: bool = </span><span class="s2">False,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">asGroupList: bool = </span><span class="s2">False,</span>
        <span class="s1">asMatch: bool = </span><span class="s2">False,</span>
    <span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot;The parameters ``pattern`` and ``flags`` are passed 
        to the ``re.compile()`` function as-is. See the Python 
        `re module &lt;https://docs.python.org/3/library/re.html&gt;`_ module for an 
        explanation of the acceptable patterns and flags. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">asGroupList = asGroupList </span><span class="s2">or </span><span class="s1">as_group_list</span>
        <span class="s1">asMatch = asMatch </span><span class="s2">or </span><span class="s1">as_match</span>

        <span class="s2">if </span><span class="s1">isinstance(pattern</span><span class="s2">, </span><span class="s1">str_type):</span>
            <span class="s2">if not </span><span class="s1">pattern:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;null string passed to Regex; use Empty() instead&quot;</span><span class="s1">)</span>

            <span class="s1">self._re = </span><span class="s2">None</span>
            <span class="s1">self.reString = self.pattern = pattern</span>
            <span class="s1">self.flags = flags</span>

        <span class="s2">elif </span><span class="s1">hasattr(pattern</span><span class="s2">, </span><span class="s5">&quot;pattern&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">hasattr(pattern</span><span class="s2">, </span><span class="s5">&quot;match&quot;</span><span class="s1">):</span>
            <span class="s1">self._re = pattern</span>
            <span class="s1">self.pattern = self.reString = pattern.pattern</span>
            <span class="s1">self.flags = flags</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s5">&quot;Regex may only be constructed with a string or a compiled RE object&quot;</span>
            <span class="s1">)</span>

        <span class="s1">self.errmsg = </span><span class="s5">&quot;Expected &quot; </span><span class="s1">+ self.name</span>
        <span class="s1">self.mayIndexError = </span><span class="s2">False</span>
        <span class="s1">self.asGroupList = asGroupList</span>
        <span class="s1">self.asMatch = asMatch</span>
        <span class="s2">if </span><span class="s1">self.asGroupList:</span>
            <span class="s1">self.parseImpl = self.parseImplAsGroupList</span>
        <span class="s2">if </span><span class="s1">self.asMatch:</span>
            <span class="s1">self.parseImpl = self.parseImplAsMatch</span>

    <span class="s1">@cached_property</span>
    <span class="s2">def </span><span class="s1">re(self):</span>
        <span class="s2">if </span><span class="s1">self._re:</span>
            <span class="s2">return </span><span class="s1">self._re</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">re.compile(self.pattern</span><span class="s2">, </span><span class="s1">self.flags)</span>
            <span class="s2">except </span><span class="s1">re.error:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s5">&quot;invalid pattern ({!r}) passed to Regex&quot;</span><span class="s1">.format(self.pattern)</span>
                <span class="s1">)</span>

    <span class="s1">@cached_property</span>
    <span class="s2">def </span><span class="s1">re_match(self):</span>
        <span class="s2">return </span><span class="s1">self.re.match</span>

    <span class="s1">@cached_property</span>
    <span class="s2">def </span><span class="s1">mayReturnEmpty(self):</span>
        <span class="s2">return </span><span class="s1">self.re_match(</span><span class="s5">&quot;&quot;</span><span class="s1">) </span><span class="s2">is not None</span>

    <span class="s2">def </span><span class="s1">_generateDefaultName(self):</span>
        <span class="s2">return </span><span class="s5">&quot;Re:({})&quot;</span><span class="s1">.format(repr(self.pattern).replace(</span><span class="s5">&quot;</span><span class="s2">\\\\</span><span class="s5">&quot;</span><span class="s2">, </span><span class="s5">&quot;</span><span class="s2">\\</span><span class="s5">&quot;</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s1">result = self.re_match(instring</span><span class="s2">, </span><span class="s1">loc)</span>
        <span class="s2">if not </span><span class="s1">result:</span>
            <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">self.errmsg</span><span class="s2">, </span><span class="s1">self)</span>

        <span class="s1">loc = result.end()</span>
        <span class="s1">ret = ParseResults(result.group())</span>
        <span class="s1">d = result.groupdict()</span>
        <span class="s2">if </span><span class="s1">d:</span>
            <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">d.items():</span>
                <span class="s1">ret[k] = v</span>
        <span class="s2">return </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">ret</span>

    <span class="s2">def </span><span class="s1">parseImplAsGroupList(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s1">result = self.re_match(instring</span><span class="s2">, </span><span class="s1">loc)</span>
        <span class="s2">if not </span><span class="s1">result:</span>
            <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">self.errmsg</span><span class="s2">, </span><span class="s1">self)</span>

        <span class="s1">loc = result.end()</span>
        <span class="s1">ret = result.groups()</span>
        <span class="s2">return </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">ret</span>

    <span class="s2">def </span><span class="s1">parseImplAsMatch(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s1">result = self.re_match(instring</span><span class="s2">, </span><span class="s1">loc)</span>
        <span class="s2">if not </span><span class="s1">result:</span>
            <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">self.errmsg</span><span class="s2">, </span><span class="s1">self)</span>

        <span class="s1">loc = result.end()</span>
        <span class="s1">ret = result</span>
        <span class="s2">return </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">ret</span>

    <span class="s2">def </span><span class="s1">sub(self</span><span class="s2">, </span><span class="s1">repl: str) -&gt; ParserElement:</span>
        <span class="s4">r&quot;&quot;&quot; 
        Return :class:`Regex` with an attached parse action to transform the parsed 
        result as if called using `re.sub(expr, repl, string) &lt;https://docs.python.org/3/library/re.html#re.sub&gt;`_. 
 
        Example:: 
 
            make_html = Regex(r&quot;(\w+):(.*?):&quot;).sub(r&quot;&lt;\1&gt;\2&lt;/\1&gt;&quot;) 
            print(make_html.transform_string(&quot;h1:main title:&quot;)) 
            # prints &quot;&lt;h1&gt;main title&lt;/h1&gt;&quot; 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.asGroupList:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s5">&quot;cannot use sub() with Regex(asGroupList=True)&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self.asMatch </span><span class="s2">and </span><span class="s1">callable(repl):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s5">&quot;cannot use sub() with a callable with Regex(asMatch=True)&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self.asMatch:</span>

            <span class="s2">def </span><span class="s1">pa(tokens):</span>
                <span class="s2">return </span><span class="s1">tokens[</span><span class="s3">0</span><span class="s1">].expand(repl)</span>

        <span class="s2">else</span><span class="s1">:</span>

            <span class="s2">def </span><span class="s1">pa(tokens):</span>
                <span class="s2">return </span><span class="s1">self.re.sub(repl</span><span class="s2">, </span><span class="s1">tokens[</span><span class="s3">0</span><span class="s1">])</span>

        <span class="s2">return </span><span class="s1">self.add_parse_action(pa)</span>


<span class="s2">class </span><span class="s1">QuotedString(Token):</span>
    <span class="s4">r&quot;&quot;&quot; 
    Token for matching strings that are delimited by quoting characters. 
 
    Defined with the following parameters: 
 
    - ``quote_char`` - string of one or more characters defining the 
      quote delimiting string 
    - ``esc_char`` - character to re_escape quotes, typically backslash 
      (default= ``None``) 
    - ``esc_quote`` - special quote sequence to re_escape an embedded quote 
      string (such as SQL's ``&quot;&quot;`` to re_escape an embedded ``&quot;``) 
      (default= ``None``) 
    - ``multiline`` - boolean indicating whether quotes can span 
      multiple lines (default= ``False``) 
    - ``unquote_results`` - boolean indicating whether the matched text 
      should be unquoted (default= ``True``) 
    - ``end_quote_char`` - string of one or more characters defining the 
      end of the quote delimited string (default= ``None``  =&gt; same as 
      quote_char) 
    - ``convert_whitespace_escapes`` - convert escaped whitespace 
      (``'\t'``, ``'\n'``, etc.) to actual whitespace 
      (default= ``True``) 
 
    Example:: 
 
        qs = QuotedString('&quot;') 
        print(qs.search_string('lsjdf &quot;This is the quote&quot; sldjf')) 
        complex_qs = QuotedString('{{', end_quote_char='}}') 
        print(complex_qs.search_string('lsjdf {{This is the &quot;quote&quot;}} sldjf')) 
        sql_qs = QuotedString('&quot;', esc_quote='&quot;&quot;') 
        print(sql_qs.search_string('lsjdf &quot;This is the quote with &quot;&quot;embedded&quot;&quot; quotes&quot; sldjf')) 
 
    prints:: 
 
        [['This is the quote']] 
        [['This is the &quot;quote&quot;']] 
        [['This is the quote with &quot;embedded&quot; quotes']] 
    &quot;&quot;&quot;</span>
    <span class="s1">ws_map = ((</span><span class="s5">r&quot;\t&quot;</span><span class="s2">, </span><span class="s5">&quot;</span><span class="s2">\t</span><span class="s5">&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s5">r&quot;\n&quot;</span><span class="s2">, </span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s5">r&quot;\f&quot;</span><span class="s2">, </span><span class="s5">&quot;</span><span class="s2">\f</span><span class="s5">&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s5">r&quot;\r&quot;</span><span class="s2">, </span><span class="s5">&quot;</span><span class="s2">\r</span><span class="s5">&quot;</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">quote_char: str = </span><span class="s5">&quot;&quot;</span><span class="s2">,</span>
        <span class="s1">esc_char: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">esc_quote: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">multiline: bool = </span><span class="s2">False,</span>
        <span class="s1">unquote_results: bool = </span><span class="s2">True,</span>
        <span class="s1">end_quote_char: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">convert_whitespace_escapes: bool = </span><span class="s2">True,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">quoteChar: str = </span><span class="s5">&quot;&quot;</span><span class="s2">,</span>
        <span class="s1">escChar: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">escQuote: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">unquoteResults: bool = </span><span class="s2">True,</span>
        <span class="s1">endQuoteChar: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">convertWhitespaceEscapes: bool = </span><span class="s2">True,</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">escChar = escChar </span><span class="s2">or </span><span class="s1">esc_char</span>
        <span class="s1">escQuote = escQuote </span><span class="s2">or </span><span class="s1">esc_quote</span>
        <span class="s1">unquoteResults = unquoteResults </span><span class="s2">and </span><span class="s1">unquote_results</span>
        <span class="s1">endQuoteChar = endQuoteChar </span><span class="s2">or </span><span class="s1">end_quote_char</span>
        <span class="s1">convertWhitespaceEscapes = (</span>
            <span class="s1">convertWhitespaceEscapes </span><span class="s2">and </span><span class="s1">convert_whitespace_escapes</span>
        <span class="s1">)</span>
        <span class="s1">quote_char = quoteChar </span><span class="s2">or </span><span class="s1">quote_char</span>

        <span class="s0"># remove white space from quote chars - wont work anyway</span>
        <span class="s1">quote_char = quote_char.strip()</span>
        <span class="s2">if not </span><span class="s1">quote_char:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;quote_char cannot be the empty string&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">endQuoteChar </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">endQuoteChar = quote_char</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">endQuoteChar = endQuoteChar.strip()</span>
            <span class="s2">if not </span><span class="s1">endQuoteChar:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;endQuoteChar cannot be the empty string&quot;</span><span class="s1">)</span>

        <span class="s1">self.quoteChar = quote_char</span>
        <span class="s1">self.quoteCharLen = len(quote_char)</span>
        <span class="s1">self.firstQuoteChar = quote_char[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">self.endQuoteChar = endQuoteChar</span>
        <span class="s1">self.endQuoteCharLen = len(endQuoteChar)</span>
        <span class="s1">self.escChar = escChar</span>
        <span class="s1">self.escQuote = escQuote</span>
        <span class="s1">self.unquoteResults = unquoteResults</span>
        <span class="s1">self.convertWhitespaceEscapes = convertWhitespaceEscapes</span>

        <span class="s1">sep = </span><span class="s5">&quot;&quot;</span>
        <span class="s1">inner_pattern = </span><span class="s5">&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">escQuote:</span>
            <span class="s1">inner_pattern += </span><span class="s5">r&quot;{}(?:{})&quot;</span><span class="s1">.format(sep</span><span class="s2">, </span><span class="s1">re.escape(escQuote))</span>
            <span class="s1">sep = </span><span class="s5">&quot;|&quot;</span>

        <span class="s2">if </span><span class="s1">escChar:</span>
            <span class="s1">inner_pattern += </span><span class="s5">r&quot;{}(?:{}.)&quot;</span><span class="s1">.format(sep</span><span class="s2">, </span><span class="s1">re.escape(escChar))</span>
            <span class="s1">sep = </span><span class="s5">&quot;|&quot;</span>
            <span class="s1">self.escCharReplacePattern = re.escape(self.escChar) + </span><span class="s5">&quot;(.)&quot;</span>

        <span class="s2">if </span><span class="s1">len(self.endQuoteChar) &gt; </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">inner_pattern += (</span>
                <span class="s5">&quot;{}(?:&quot;</span><span class="s1">.format(sep)</span>
                <span class="s1">+ </span><span class="s5">&quot;|&quot;</span><span class="s1">.join(</span>
                    <span class="s5">&quot;(?:{}(?!{}))&quot;</span><span class="s1">.format(</span>
                        <span class="s1">re.escape(self.endQuoteChar[:i])</span><span class="s2">,</span>
                        <span class="s1">re.escape(self.endQuoteChar[i:])</span><span class="s2">,</span>
                    <span class="s1">)</span>
                    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(self.endQuoteChar) - </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span>
                <span class="s1">)</span>
                <span class="s1">+ </span><span class="s5">&quot;)&quot;</span>
            <span class="s1">)</span>
            <span class="s1">sep = </span><span class="s5">&quot;|&quot;</span>

        <span class="s2">if </span><span class="s1">multiline:</span>
            <span class="s1">self.flags = re.MULTILINE | re.DOTALL</span>
            <span class="s1">inner_pattern += </span><span class="s5">r&quot;{}(?:[^{}{}])&quot;</span><span class="s1">.format(</span>
                <span class="s1">sep</span><span class="s2">,</span>
                <span class="s1">_escape_regex_range_chars(self.endQuoteChar[</span><span class="s3">0</span><span class="s1">])</span><span class="s2">,</span>
                <span class="s1">(_escape_regex_range_chars(escChar) </span><span class="s2">if </span><span class="s1">escChar </span><span class="s2">is not None else </span><span class="s5">&quot;&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.flags = </span><span class="s3">0</span>
            <span class="s1">inner_pattern += </span><span class="s5">r&quot;{}(?:[^{}\n\r{}])&quot;</span><span class="s1">.format(</span>
                <span class="s1">sep</span><span class="s2">,</span>
                <span class="s1">_escape_regex_range_chars(self.endQuoteChar[</span><span class="s3">0</span><span class="s1">])</span><span class="s2">,</span>
                <span class="s1">(_escape_regex_range_chars(escChar) </span><span class="s2">if </span><span class="s1">escChar </span><span class="s2">is not None else </span><span class="s5">&quot;&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span>

        <span class="s1">self.pattern = </span><span class="s5">&quot;&quot;</span><span class="s1">.join(</span>
            <span class="s1">[</span>
                <span class="s1">re.escape(self.quoteChar)</span><span class="s2">,</span>
                <span class="s5">&quot;(?:&quot;</span><span class="s2">,</span>
                <span class="s1">inner_pattern</span><span class="s2">,</span>
                <span class="s5">&quot;)*&quot;</span><span class="s2">,</span>
                <span class="s1">re.escape(self.endQuoteChar)</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self.re = re.compile(self.pattern</span><span class="s2">, </span><span class="s1">self.flags)</span>
            <span class="s1">self.reString = self.pattern</span>
            <span class="s1">self.re_match = self.re.match</span>
        <span class="s2">except </span><span class="s1">re.error:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s5">&quot;invalid pattern {!r} passed to Regex&quot;</span><span class="s1">.format(self.pattern)</span>
            <span class="s1">)</span>

        <span class="s1">self.errmsg = </span><span class="s5">&quot;Expected &quot; </span><span class="s1">+ self.name</span>
        <span class="s1">self.mayIndexError = </span><span class="s2">False</span>
        <span class="s1">self.mayReturnEmpty = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">_generateDefaultName(self):</span>
        <span class="s2">if </span><span class="s1">self.quoteChar == self.endQuoteChar </span><span class="s2">and </span><span class="s1">isinstance(self.quoteChar</span><span class="s2">, </span><span class="s1">str_type):</span>
            <span class="s2">return </span><span class="s5">&quot;string enclosed in {!r}&quot;</span><span class="s1">.format(self.quoteChar)</span>

        <span class="s2">return </span><span class="s5">&quot;quoted string, starting with {} ending with {}&quot;</span><span class="s1">.format(</span>
            <span class="s1">self.quoteChar</span><span class="s2">, </span><span class="s1">self.endQuoteChar</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s1">result = (</span>
            <span class="s1">instring[loc] == self.firstQuoteChar</span>
            <span class="s2">and </span><span class="s1">self.re_match(instring</span><span class="s2">, </span><span class="s1">loc)</span>
            <span class="s2">or None</span>
        <span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">result:</span>
            <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">self.errmsg</span><span class="s2">, </span><span class="s1">self)</span>

        <span class="s1">loc = result.end()</span>
        <span class="s1">ret = result.group()</span>

        <span class="s2">if </span><span class="s1">self.unquoteResults:</span>

            <span class="s0"># strip off quotes</span>
            <span class="s1">ret = ret[self.quoteCharLen : -self.endQuoteCharLen]</span>

            <span class="s2">if </span><span class="s1">isinstance(ret</span><span class="s2">, </span><span class="s1">str_type):</span>
                <span class="s0"># replace escaped whitespace</span>
                <span class="s2">if </span><span class="s5">&quot;</span><span class="s2">\\</span><span class="s5">&quot; </span><span class="s2">in </span><span class="s1">ret </span><span class="s2">and </span><span class="s1">self.convertWhitespaceEscapes:</span>
                    <span class="s2">for </span><span class="s1">wslit</span><span class="s2">, </span><span class="s1">wschar </span><span class="s2">in </span><span class="s1">self.ws_map:</span>
                        <span class="s1">ret = ret.replace(wslit</span><span class="s2">, </span><span class="s1">wschar)</span>

                <span class="s0"># replace escaped characters</span>
                <span class="s2">if </span><span class="s1">self.escChar:</span>
                    <span class="s1">ret = re.sub(self.escCharReplacePattern</span><span class="s2">, </span><span class="s5">r&quot;\g&lt;1&gt;&quot;</span><span class="s2">, </span><span class="s1">ret)</span>

                <span class="s0"># replace escaped quotes</span>
                <span class="s2">if </span><span class="s1">self.escQuote:</span>
                    <span class="s1">ret = ret.replace(self.escQuote</span><span class="s2">, </span><span class="s1">self.endQuoteChar)</span>

        <span class="s2">return </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">ret</span>


<span class="s2">class </span><span class="s1">CharsNotIn(Token):</span>
    <span class="s4">&quot;&quot;&quot;Token for matching words composed of characters *not* in a given 
    set (will include whitespace in matched characters if not listed in 
    the provided exclusion set - see example). Defined with string 
    containing all disallowed characters, and an optional minimum, 
    maximum, and/or exact length.  The default value for ``min`` is 
    1 (a minimum value &lt; 1 is not valid); the default values for 
    ``max`` and ``exact`` are 0, meaning no maximum or exact 
    length restriction. 
 
    Example:: 
 
        # define a comma-separated-value as anything that is not a ',' 
        csv_value = CharsNotIn(',') 
        print(delimited_list(csv_value).parse_string(&quot;dkls,lsdkjf,s12 34,@!#,213&quot;)) 
 
    prints:: 
 
        ['dkls', 'lsdkjf', 's12 34', '@!#', '213'] 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">not_chars: str = </span><span class="s5">&quot;&quot;</span><span class="s2">,</span>
        <span class="s1">min: int = </span><span class="s3">1</span><span class="s2">,</span>
        <span class="s1">max: int = </span><span class="s3">0</span><span class="s2">,</span>
        <span class="s1">exact: int = </span><span class="s3">0</span><span class="s2">,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">notChars: str = </span><span class="s5">&quot;&quot;</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.skipWhitespace = </span><span class="s2">False</span>
        <span class="s1">self.notChars = not_chars </span><span class="s2">or </span><span class="s1">notChars</span>
        <span class="s1">self.notCharsSet = set(self.notChars)</span>

        <span class="s2">if </span><span class="s1">min &lt; </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s5">&quot;cannot specify a minimum length &lt; 1; use &quot;</span>
                <span class="s5">&quot;Opt(CharsNotIn()) if zero-length char group is permitted&quot;</span>
            <span class="s1">)</span>

        <span class="s1">self.minLen = min</span>

        <span class="s2">if </span><span class="s1">max &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">self.maxLen = max</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.maxLen = _MAX_INT</span>

        <span class="s2">if </span><span class="s1">exact &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">self.maxLen = exact</span>
            <span class="s1">self.minLen = exact</span>

        <span class="s1">self.errmsg = </span><span class="s5">&quot;Expected &quot; </span><span class="s1">+ self.name</span>
        <span class="s1">self.mayReturnEmpty = self.minLen == </span><span class="s3">0</span>
        <span class="s1">self.mayIndexError = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">_generateDefaultName(self):</span>
        <span class="s1">not_chars_str = _collapse_string_to_ranges(self.notChars)</span>
        <span class="s2">if </span><span class="s1">len(not_chars_str) &gt; </span><span class="s3">16</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s5">&quot;!W:({}...)&quot;</span><span class="s1">.format(self.notChars[: </span><span class="s3">16 </span><span class="s1">- </span><span class="s3">3</span><span class="s1">])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s5">&quot;!W:({})&quot;</span><span class="s1">.format(self.notChars)</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s1">notchars = self.notCharsSet</span>
        <span class="s2">if </span><span class="s1">instring[loc] </span><span class="s2">in </span><span class="s1">notchars:</span>
            <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">self.errmsg</span><span class="s2">, </span><span class="s1">self)</span>

        <span class="s1">start = loc</span>
        <span class="s1">loc += </span><span class="s3">1</span>
        <span class="s1">maxlen = min(start + self.maxLen</span><span class="s2">, </span><span class="s1">len(instring))</span>
        <span class="s2">while </span><span class="s1">loc &lt; maxlen </span><span class="s2">and </span><span class="s1">instring[loc] </span><span class="s2">not in </span><span class="s1">notchars:</span>
            <span class="s1">loc += </span><span class="s3">1</span>

        <span class="s2">if </span><span class="s1">loc - start &lt; self.minLen:</span>
            <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">self.errmsg</span><span class="s2">, </span><span class="s1">self)</span>

        <span class="s2">return </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">instring[start:loc]</span>


<span class="s2">class </span><span class="s1">White(Token):</span>
    <span class="s4">&quot;&quot;&quot;Special matching class for matching whitespace.  Normally, 
    whitespace is ignored by pyparsing grammars.  This class is included 
    when some whitespace structures are significant.  Define with 
    a string containing the whitespace characters to be matched; default 
    is ``&quot; \\t\\r\\n&quot;``.  Also takes optional ``min``, 
    ``max``, and ``exact`` arguments, as defined for the 
    :class:`Word` class. 
    &quot;&quot;&quot;</span>

    <span class="s1">whiteStrs = {</span>
        <span class="s5">&quot; &quot;</span><span class="s1">: </span><span class="s5">&quot;&lt;SP&gt;&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;</span><span class="s2">\t</span><span class="s5">&quot;</span><span class="s1">: </span><span class="s5">&quot;&lt;TAB&gt;&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s1">: </span><span class="s5">&quot;&lt;LF&gt;&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;</span><span class="s2">\r</span><span class="s5">&quot;</span><span class="s1">: </span><span class="s5">&quot;&lt;CR&gt;&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;</span><span class="s2">\f</span><span class="s5">&quot;</span><span class="s1">: </span><span class="s5">&quot;&lt;FF&gt;&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;</span><span class="s2">\u00A0</span><span class="s5">&quot;</span><span class="s1">: </span><span class="s5">&quot;&lt;NBSP&gt;&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;</span><span class="s2">\u1680</span><span class="s5">&quot;</span><span class="s1">: </span><span class="s5">&quot;&lt;OGHAM_SPACE_MARK&gt;&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;</span><span class="s2">\u180E</span><span class="s5">&quot;</span><span class="s1">: </span><span class="s5">&quot;&lt;MONGOLIAN_VOWEL_SEPARATOR&gt;&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;</span><span class="s2">\u2000</span><span class="s5">&quot;</span><span class="s1">: </span><span class="s5">&quot;&lt;EN_QUAD&gt;&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;</span><span class="s2">\u2001</span><span class="s5">&quot;</span><span class="s1">: </span><span class="s5">&quot;&lt;EM_QUAD&gt;&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;</span><span class="s2">\u2002</span><span class="s5">&quot;</span><span class="s1">: </span><span class="s5">&quot;&lt;EN_SPACE&gt;&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;</span><span class="s2">\u2003</span><span class="s5">&quot;</span><span class="s1">: </span><span class="s5">&quot;&lt;EM_SPACE&gt;&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;</span><span class="s2">\u2004</span><span class="s5">&quot;</span><span class="s1">: </span><span class="s5">&quot;&lt;THREE-PER-EM_SPACE&gt;&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;</span><span class="s2">\u2005</span><span class="s5">&quot;</span><span class="s1">: </span><span class="s5">&quot;&lt;FOUR-PER-EM_SPACE&gt;&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;</span><span class="s2">\u2006</span><span class="s5">&quot;</span><span class="s1">: </span><span class="s5">&quot;&lt;SIX-PER-EM_SPACE&gt;&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;</span><span class="s2">\u2007</span><span class="s5">&quot;</span><span class="s1">: </span><span class="s5">&quot;&lt;FIGURE_SPACE&gt;&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;</span><span class="s2">\u2008</span><span class="s5">&quot;</span><span class="s1">: </span><span class="s5">&quot;&lt;PUNCTUATION_SPACE&gt;&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;</span><span class="s2">\u2009</span><span class="s5">&quot;</span><span class="s1">: </span><span class="s5">&quot;&lt;THIN_SPACE&gt;&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;</span><span class="s2">\u200A</span><span class="s5">&quot;</span><span class="s1">: </span><span class="s5">&quot;&lt;HAIR_SPACE&gt;&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;</span><span class="s2">\u200B</span><span class="s5">&quot;</span><span class="s1">: </span><span class="s5">&quot;&lt;ZERO_WIDTH_SPACE&gt;&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;</span><span class="s2">\u202F</span><span class="s5">&quot;</span><span class="s1">: </span><span class="s5">&quot;&lt;NNBSP&gt;&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;</span><span class="s2">\u205F</span><span class="s5">&quot;</span><span class="s1">: </span><span class="s5">&quot;&lt;MMSP&gt;&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;</span><span class="s2">\u3000</span><span class="s5">&quot;</span><span class="s1">: </span><span class="s5">&quot;&lt;IDEOGRAPHIC_SPACE&gt;&quot;</span><span class="s2">,</span>
    <span class="s1">}</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">ws: str = </span><span class="s5">&quot; </span><span class="s2">\t\r\n</span><span class="s5">&quot;</span><span class="s2">, </span><span class="s1">min: int = </span><span class="s3">1</span><span class="s2">, </span><span class="s1">max: int = </span><span class="s3">0</span><span class="s2">, </span><span class="s1">exact: int = </span><span class="s3">0</span><span class="s1">):</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.matchWhite = ws</span>
        <span class="s1">self.set_whitespace_chars(</span>
            <span class="s5">&quot;&quot;</span><span class="s1">.join(c </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">self.whiteStrs </span><span class="s2">if </span><span class="s1">c </span><span class="s2">not in </span><span class="s1">self.matchWhite)</span><span class="s2">,</span>
            <span class="s1">copy_defaults=</span><span class="s2">True,</span>
        <span class="s1">)</span>
        <span class="s0"># self.leave_whitespace()</span>
        <span class="s1">self.mayReturnEmpty = </span><span class="s2">True</span>
        <span class="s1">self.errmsg = </span><span class="s5">&quot;Expected &quot; </span><span class="s1">+ self.name</span>

        <span class="s1">self.minLen = min</span>

        <span class="s2">if </span><span class="s1">max &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">self.maxLen = max</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.maxLen = _MAX_INT</span>

        <span class="s2">if </span><span class="s1">exact &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">self.maxLen = exact</span>
            <span class="s1">self.minLen = exact</span>

    <span class="s2">def </span><span class="s1">_generateDefaultName(self):</span>
        <span class="s2">return </span><span class="s5">&quot;&quot;</span><span class="s1">.join(White.whiteStrs[c] </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">self.matchWhite)</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">instring[loc] </span><span class="s2">not in </span><span class="s1">self.matchWhite:</span>
            <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">self.errmsg</span><span class="s2">, </span><span class="s1">self)</span>
        <span class="s1">start = loc</span>
        <span class="s1">loc += </span><span class="s3">1</span>
        <span class="s1">maxloc = start + self.maxLen</span>
        <span class="s1">maxloc = min(maxloc</span><span class="s2">, </span><span class="s1">len(instring))</span>
        <span class="s2">while </span><span class="s1">loc &lt; maxloc </span><span class="s2">and </span><span class="s1">instring[loc] </span><span class="s2">in </span><span class="s1">self.matchWhite:</span>
            <span class="s1">loc += </span><span class="s3">1</span>

        <span class="s2">if </span><span class="s1">loc - start &lt; self.minLen:</span>
            <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">self.errmsg</span><span class="s2">, </span><span class="s1">self)</span>

        <span class="s2">return </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">instring[start:loc]</span>


<span class="s2">class </span><span class="s1">PositionToken(Token):</span>
    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.mayReturnEmpty = </span><span class="s2">True</span>
        <span class="s1">self.mayIndexError = </span><span class="s2">False</span>


<span class="s2">class </span><span class="s1">GoToColumn(PositionToken):</span>
    <span class="s4">&quot;&quot;&quot;Token to advance to a specific column of input text; useful for 
    tabular report scraping. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">colno: int):</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.col = colno</span>

    <span class="s2">def </span><span class="s1">preParse(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc):</span>
        <span class="s2">if </span><span class="s1">col(loc</span><span class="s2">, </span><span class="s1">instring) != self.col:</span>
            <span class="s1">instrlen = len(instring)</span>
            <span class="s2">if </span><span class="s1">self.ignoreExprs:</span>
                <span class="s1">loc = self._skipIgnorables(instring</span><span class="s2">, </span><span class="s1">loc)</span>
            <span class="s2">while </span><span class="s1">(</span>
                <span class="s1">loc &lt; instrlen</span>
                <span class="s2">and </span><span class="s1">instring[loc].isspace()</span>
                <span class="s2">and </span><span class="s1">col(loc</span><span class="s2">, </span><span class="s1">instring) != self.col</span>
            <span class="s1">):</span>
                <span class="s1">loc += </span><span class="s3">1</span>
        <span class="s2">return </span><span class="s1">loc</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s1">thiscol = col(loc</span><span class="s2">, </span><span class="s1">instring)</span>
        <span class="s2">if </span><span class="s1">thiscol &gt; self.col:</span>
            <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s5">&quot;Text not in expected column&quot;</span><span class="s2">, </span><span class="s1">self)</span>
        <span class="s1">newloc = loc + self.col - thiscol</span>
        <span class="s1">ret = instring[loc:newloc]</span>
        <span class="s2">return </span><span class="s1">newloc</span><span class="s2">, </span><span class="s1">ret</span>


<span class="s2">class </span><span class="s1">LineStart(PositionToken):</span>
    <span class="s4">r&quot;&quot;&quot;Matches if current position is at the beginning of a line within 
    the parse string 
 
    Example:: 
 
        test = '''\ 
        AAA this line 
        AAA and this line 
          AAA but not this one 
        B AAA and definitely not this one 
        ''' 
 
        for t in (LineStart() + 'AAA' + restOfLine).search_string(test): 
            print(t) 
 
    prints:: 
 
        ['AAA', ' this line'] 
        ['AAA', ' and this line'] 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.leave_whitespace()</span>
        <span class="s1">self.orig_whiteChars = set() | self.whiteChars</span>
        <span class="s1">self.whiteChars.discard(</span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s1">)</span>
        <span class="s1">self.skipper = Empty().set_whitespace_chars(self.whiteChars)</span>
        <span class="s1">self.errmsg = </span><span class="s5">&quot;Expected start of line&quot;</span>

    <span class="s2">def </span><span class="s1">preParse(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc):</span>
        <span class="s2">if </span><span class="s1">loc == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">loc</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">ret = self.skipper.preParse(instring</span><span class="s2">, </span><span class="s1">loc)</span>
            <span class="s2">if </span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot; </span><span class="s2">in </span><span class="s1">self.orig_whiteChars:</span>
                <span class="s2">while </span><span class="s1">instring[ret : ret + </span><span class="s3">1</span><span class="s1">] == </span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s1">:</span>
                    <span class="s1">ret = self.skipper.preParse(instring</span><span class="s2">, </span><span class="s1">ret + </span><span class="s3">1</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">ret</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">col(loc</span><span class="s2">, </span><span class="s1">instring) == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">[]</span>
        <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">self.errmsg</span><span class="s2">, </span><span class="s1">self)</span>


<span class="s2">class </span><span class="s1">LineEnd(PositionToken):</span>
    <span class="s4">&quot;&quot;&quot;Matches if current position is at the end of a line within the 
    parse string 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.whiteChars.discard(</span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s1">)</span>
        <span class="s1">self.set_whitespace_chars(self.whiteChars</span><span class="s2">, </span><span class="s1">copy_defaults=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">self.errmsg = </span><span class="s5">&quot;Expected end of line&quot;</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">loc &lt; len(instring):</span>
            <span class="s2">if </span><span class="s1">instring[loc] == </span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">loc + </span><span class="s3">1</span><span class="s2">, </span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">self.errmsg</span><span class="s2">, </span><span class="s1">self)</span>
        <span class="s2">elif </span><span class="s1">loc == len(instring):</span>
            <span class="s2">return </span><span class="s1">loc + </span><span class="s3">1</span><span class="s2">, </span><span class="s1">[]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">self.errmsg</span><span class="s2">, </span><span class="s1">self)</span>


<span class="s2">class </span><span class="s1">StringStart(PositionToken):</span>
    <span class="s4">&quot;&quot;&quot;Matches if current position is at the beginning of the parse 
    string 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.errmsg = </span><span class="s5">&quot;Expected start of text&quot;</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">loc != </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s0"># see if entire string up to here is just whitespace and ignoreables</span>
            <span class="s2">if </span><span class="s1">loc != self.preParse(instring</span><span class="s2">, </span><span class="s3">0</span><span class="s1">):</span>
                <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">self.errmsg</span><span class="s2">, </span><span class="s1">self)</span>
        <span class="s2">return </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">[]</span>


<span class="s2">class </span><span class="s1">StringEnd(PositionToken):</span>
    <span class="s4">&quot;&quot;&quot; 
    Matches if current position is at the end of the parse string 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.errmsg = </span><span class="s5">&quot;Expected end of text&quot;</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">loc &lt; len(instring):</span>
            <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">self.errmsg</span><span class="s2">, </span><span class="s1">self)</span>
        <span class="s2">elif </span><span class="s1">loc == len(instring):</span>
            <span class="s2">return </span><span class="s1">loc + </span><span class="s3">1</span><span class="s2">, </span><span class="s1">[]</span>
        <span class="s2">elif </span><span class="s1">loc &gt; len(instring):</span>
            <span class="s2">return </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">[]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">self.errmsg</span><span class="s2">, </span><span class="s1">self)</span>


<span class="s2">class </span><span class="s1">WordStart(PositionToken):</span>
    <span class="s4">&quot;&quot;&quot;Matches if the current position is at the beginning of a 
    :class:`Word`, and is not preceded by any character in a given 
    set of ``word_chars`` (default= ``printables``). To emulate the 
    ``\b`` behavior of regular expressions, use 
    ``WordStart(alphanums)``. ``WordStart`` will also match at 
    the beginning of the string being parsed, or at the beginning of 
    a line. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">word_chars: str = printables</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">wordChars: str = printables):</span>
        <span class="s1">wordChars = word_chars </span><span class="s2">if </span><span class="s1">wordChars == printables </span><span class="s2">else </span><span class="s1">wordChars</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.wordChars = set(wordChars)</span>
        <span class="s1">self.errmsg = </span><span class="s5">&quot;Not at the start of a word&quot;</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">loc != </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">instring[loc - </span><span class="s3">1</span><span class="s1">] </span><span class="s2">in </span><span class="s1">self.wordChars</span>
                <span class="s2">or </span><span class="s1">instring[loc] </span><span class="s2">not in </span><span class="s1">self.wordChars</span>
            <span class="s1">):</span>
                <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">self.errmsg</span><span class="s2">, </span><span class="s1">self)</span>
        <span class="s2">return </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">[]</span>


<span class="s2">class </span><span class="s1">WordEnd(PositionToken):</span>
    <span class="s4">&quot;&quot;&quot;Matches if the current position is at the end of a :class:`Word`, 
    and is not followed by any character in a given set of ``word_chars`` 
    (default= ``printables``). To emulate the ``\b`` behavior of 
    regular expressions, use ``WordEnd(alphanums)``. ``WordEnd`` 
    will also match at the end of the string being parsed, or at the end 
    of a line. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">word_chars: str = printables</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">wordChars: str = printables):</span>
        <span class="s1">wordChars = word_chars </span><span class="s2">if </span><span class="s1">wordChars == printables </span><span class="s2">else </span><span class="s1">wordChars</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.wordChars = set(wordChars)</span>
        <span class="s1">self.skipWhitespace = </span><span class="s2">False</span>
        <span class="s1">self.errmsg = </span><span class="s5">&quot;Not at the end of a word&quot;</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s1">instrlen = len(instring)</span>
        <span class="s2">if </span><span class="s1">instrlen &gt; </span><span class="s3">0 </span><span class="s2">and </span><span class="s1">loc &lt; instrlen:</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">instring[loc] </span><span class="s2">in </span><span class="s1">self.wordChars</span>
                <span class="s2">or </span><span class="s1">instring[loc - </span><span class="s3">1</span><span class="s1">] </span><span class="s2">not in </span><span class="s1">self.wordChars</span>
            <span class="s1">):</span>
                <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">self.errmsg</span><span class="s2">, </span><span class="s1">self)</span>
        <span class="s2">return </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">[]</span>


<span class="s2">class </span><span class="s1">ParseExpression(ParserElement):</span>
    <span class="s4">&quot;&quot;&quot;Abstract subclass of ParserElement, for combining and 
    post-processing parsed tokens. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">exprs: typing.Iterable[ParserElement]</span><span class="s2">, </span><span class="s1">savelist: bool = </span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">super().__init__(savelist)</span>
        <span class="s1">self.exprs: List[ParserElement]</span>
        <span class="s2">if </span><span class="s1">isinstance(exprs</span><span class="s2">, </span><span class="s1">_generatorType):</span>
            <span class="s1">exprs = list(exprs)</span>

        <span class="s2">if </span><span class="s1">isinstance(exprs</span><span class="s2">, </span><span class="s1">str_type):</span>
            <span class="s1">self.exprs = [self._literalStringClass(exprs)]</span>
        <span class="s2">elif </span><span class="s1">isinstance(exprs</span><span class="s2">, </span><span class="s1">ParserElement):</span>
            <span class="s1">self.exprs = [exprs]</span>
        <span class="s2">elif </span><span class="s1">isinstance(exprs</span><span class="s2">, </span><span class="s1">Iterable):</span>
            <span class="s1">exprs = list(exprs)</span>
            <span class="s0"># if sequence of strings provided, wrap with Literal</span>
            <span class="s2">if </span><span class="s1">any(isinstance(expr</span><span class="s2">, </span><span class="s1">str_type) </span><span class="s2">for </span><span class="s1">expr </span><span class="s2">in </span><span class="s1">exprs):</span>
                <span class="s1">exprs = (</span>
                    <span class="s1">self._literalStringClass(e) </span><span class="s2">if </span><span class="s1">isinstance(e</span><span class="s2">, </span><span class="s1">str_type) </span><span class="s2">else </span><span class="s1">e</span>
                    <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">exprs</span>
                <span class="s1">)</span>
            <span class="s1">self.exprs = list(exprs)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">self.exprs = list(exprs)</span>
            <span class="s2">except </span><span class="s1">TypeError:</span>
                <span class="s1">self.exprs = [exprs]</span>
        <span class="s1">self.callPreparse = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">recurse(self) -&gt; Sequence[ParserElement]:</span>
        <span class="s2">return </span><span class="s1">self.exprs[:]</span>

    <span class="s2">def </span><span class="s1">append(self</span><span class="s2">, </span><span class="s1">other) -&gt; ParserElement:</span>
        <span class="s1">self.exprs.append(other)</span>
        <span class="s1">self._defaultName = </span><span class="s2">None</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">leave_whitespace(self</span><span class="s2">, </span><span class="s1">recursive: bool = </span><span class="s2">True</span><span class="s1">) -&gt; ParserElement:</span>
        <span class="s4">&quot;&quot;&quot; 
        Extends ``leave_whitespace`` defined in base class, and also invokes ``leave_whitespace`` on 
           all contained expressions. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().leave_whitespace(recursive)</span>

        <span class="s2">if </span><span class="s1">recursive:</span>
            <span class="s1">self.exprs = [e.copy() </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs]</span>
            <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs:</span>
                <span class="s1">e.leave_whitespace(recursive)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">ignore_whitespace(self</span><span class="s2">, </span><span class="s1">recursive: bool = </span><span class="s2">True</span><span class="s1">) -&gt; ParserElement:</span>
        <span class="s4">&quot;&quot;&quot; 
        Extends ``ignore_whitespace`` defined in base class, and also invokes ``leave_whitespace`` on 
           all contained expressions. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().ignore_whitespace(recursive)</span>
        <span class="s2">if </span><span class="s1">recursive:</span>
            <span class="s1">self.exprs = [e.copy() </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs]</span>
            <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs:</span>
                <span class="s1">e.ignore_whitespace(recursive)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">ignore(self</span><span class="s2">, </span><span class="s1">other) -&gt; ParserElement:</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">Suppress):</span>
            <span class="s2">if </span><span class="s1">other </span><span class="s2">not in </span><span class="s1">self.ignoreExprs:</span>
                <span class="s1">super().ignore(other)</span>
                <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs:</span>
                    <span class="s1">e.ignore(self.ignoreExprs[-</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">super().ignore(other)</span>
            <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs:</span>
                <span class="s1">e.ignore(self.ignoreExprs[-</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">_generateDefaultName(self):</span>
        <span class="s2">return </span><span class="s5">&quot;{}:({})&quot;</span><span class="s1">.format(self.__class__.__name__</span><span class="s2">, </span><span class="s1">str(self.exprs))</span>

    <span class="s2">def </span><span class="s1">streamline(self) -&gt; ParserElement:</span>
        <span class="s2">if </span><span class="s1">self.streamlined:</span>
            <span class="s2">return </span><span class="s1">self</span>

        <span class="s1">super().streamline()</span>

        <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs:</span>
            <span class="s1">e.streamline()</span>

        <span class="s0"># collapse nested :class:`And`'s of the form ``And(And(And(a, b), c), d)`` to ``And(a, b, c, d)``</span>
        <span class="s0"># but only if there are no parse actions or resultsNames on the nested And's</span>
        <span class="s0"># (likewise for :class:`Or`'s and :class:`MatchFirst`'s)</span>
        <span class="s2">if </span><span class="s1">len(self.exprs) == </span><span class="s3">2</span><span class="s1">:</span>
            <span class="s1">other = self.exprs[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">self.__class__)</span>
                <span class="s2">and not </span><span class="s1">other.parseAction</span>
                <span class="s2">and </span><span class="s1">other.resultsName </span><span class="s2">is None</span>
                <span class="s2">and not </span><span class="s1">other.debug</span>
            <span class="s1">):</span>
                <span class="s1">self.exprs = other.exprs[:] + [self.exprs[</span><span class="s3">1</span><span class="s1">]]</span>
                <span class="s1">self._defaultName = </span><span class="s2">None</span>
                <span class="s1">self.mayReturnEmpty |= other.mayReturnEmpty</span>
                <span class="s1">self.mayIndexError |= other.mayIndexError</span>

            <span class="s1">other = self.exprs[-</span><span class="s3">1</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">self.__class__)</span>
                <span class="s2">and not </span><span class="s1">other.parseAction</span>
                <span class="s2">and </span><span class="s1">other.resultsName </span><span class="s2">is None</span>
                <span class="s2">and not </span><span class="s1">other.debug</span>
            <span class="s1">):</span>
                <span class="s1">self.exprs = self.exprs[:-</span><span class="s3">1</span><span class="s1">] + other.exprs[:]</span>
                <span class="s1">self._defaultName = </span><span class="s2">None</span>
                <span class="s1">self.mayReturnEmpty |= other.mayReturnEmpty</span>
                <span class="s1">self.mayIndexError |= other.mayIndexError</span>

        <span class="s1">self.errmsg = </span><span class="s5">&quot;Expected &quot; </span><span class="s1">+ str(self)</span>

        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">validate(self</span><span class="s2">, </span><span class="s1">validateTrace=</span><span class="s2">None</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">tmp = (validateTrace </span><span class="s2">if </span><span class="s1">validateTrace </span><span class="s2">is not None else </span><span class="s1">[])[:] + [self]</span>
        <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs:</span>
            <span class="s1">e.validate(tmp)</span>
        <span class="s1">self._checkRecursion([])</span>

    <span class="s2">def </span><span class="s1">copy(self) -&gt; ParserElement:</span>
        <span class="s1">ret = super().copy()</span>
        <span class="s1">ret.exprs = [e.copy() </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs]</span>
        <span class="s2">return </span><span class="s1">ret</span>

    <span class="s2">def </span><span class="s1">_setResultsName(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">listAllMatches=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">__diag__.warn_ungrouped_named_tokens_in_collection</span>
            <span class="s2">and </span><span class="s1">Diagnostics.warn_ungrouped_named_tokens_in_collection</span>
            <span class="s2">not in </span><span class="s1">self.suppress_warnings_</span>
        <span class="s1">):</span>
            <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs:</span>
                <span class="s2">if </span><span class="s1">(</span>
                    <span class="s1">isinstance(e</span><span class="s2">, </span><span class="s1">ParserElement)</span>
                    <span class="s2">and </span><span class="s1">e.resultsName</span>
                    <span class="s2">and </span><span class="s1">Diagnostics.warn_ungrouped_named_tokens_in_collection</span>
                    <span class="s2">not in </span><span class="s1">e.suppress_warnings_</span>
                <span class="s1">):</span>
                    <span class="s1">warnings.warn(</span>
                        <span class="s5">&quot;{}: setting results name {!r} on {} expression &quot;</span>
                        <span class="s5">&quot;collides with {!r} on contained expression&quot;</span><span class="s1">.format(</span>
                            <span class="s5">&quot;warn_ungrouped_named_tokens_in_collection&quot;</span><span class="s2">,</span>
                            <span class="s1">name</span><span class="s2">,</span>
                            <span class="s1">type(self).__name__</span><span class="s2">,</span>
                            <span class="s1">e.resultsName</span><span class="s2">,</span>
                        <span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">stacklevel=</span><span class="s3">3</span><span class="s2">,</span>
                    <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">super()._setResultsName(name</span><span class="s2">, </span><span class="s1">listAllMatches)</span>

    <span class="s1">ignoreWhitespace = ignore_whitespace</span>
    <span class="s1">leaveWhitespace = leave_whitespace</span>


<span class="s2">class </span><span class="s1">And(ParseExpression):</span>
    <span class="s4">&quot;&quot;&quot; 
    Requires all given :class:`ParseExpression` s to be found in the given order. 
    Expressions may be separated by whitespace. 
    May be constructed using the ``'+'`` operator. 
    May also be constructed using the ``'-'`` operator, which will 
    suppress backtracking. 
 
    Example:: 
 
        integer = Word(nums) 
        name_expr = Word(alphas)[1, ...] 
 
        expr = And([integer(&quot;id&quot;), name_expr(&quot;name&quot;), integer(&quot;age&quot;)]) 
        # more easily written as: 
        expr = integer(&quot;id&quot;) + name_expr(&quot;name&quot;) + integer(&quot;age&quot;) 
    &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">_ErrorStop(Empty):</span>
        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
            <span class="s1">super().__init__(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s1">self.leave_whitespace()</span>

        <span class="s2">def </span><span class="s1">_generateDefaultName(self):</span>
            <span class="s2">return </span><span class="s5">&quot;-&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">exprs_arg: typing.Iterable[ParserElement]</span><span class="s2">, </span><span class="s1">savelist: bool = </span><span class="s2">True</span>
    <span class="s1">):</span>
        <span class="s1">exprs: List[ParserElement] = list(exprs_arg)</span>
        <span class="s2">if </span><span class="s1">exprs </span><span class="s2">and </span><span class="s1">Ellipsis </span><span class="s2">in </span><span class="s1">exprs:</span>
            <span class="s1">tmp = []</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">expr </span><span class="s2">in </span><span class="s1">enumerate(exprs):</span>
                <span class="s2">if </span><span class="s1">expr </span><span class="s2">is </span><span class="s1">Ellipsis:</span>
                    <span class="s2">if </span><span class="s1">i &lt; len(exprs) - </span><span class="s3">1</span><span class="s1">:</span>
                        <span class="s1">skipto_arg: ParserElement = (Empty() + exprs[i + </span><span class="s3">1</span><span class="s1">]).exprs[-</span><span class="s3">1</span><span class="s1">]</span>
                        <span class="s1">tmp.append(SkipTo(skipto_arg)(</span><span class="s5">&quot;_skipped*&quot;</span><span class="s1">))</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s2">raise </span><span class="s1">Exception(</span>
                            <span class="s5">&quot;cannot construct And with sequence ending in ...&quot;</span>
                        <span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">tmp.append(expr)</span>
            <span class="s1">exprs[:] = tmp</span>
        <span class="s1">super().__init__(exprs</span><span class="s2">, </span><span class="s1">savelist)</span>
        <span class="s2">if </span><span class="s1">self.exprs:</span>
            <span class="s1">self.mayReturnEmpty = all(e.mayReturnEmpty </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs)</span>
            <span class="s2">if not </span><span class="s1">isinstance(self.exprs[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">White):</span>
                <span class="s1">self.set_whitespace_chars(</span>
                    <span class="s1">self.exprs[</span><span class="s3">0</span><span class="s1">].whiteChars</span><span class="s2">,</span>
                    <span class="s1">copy_defaults=self.exprs[</span><span class="s3">0</span><span class="s1">].copyDefaultWhiteChars</span><span class="s2">,</span>
                <span class="s1">)</span>
                <span class="s1">self.skipWhitespace = self.exprs[</span><span class="s3">0</span><span class="s1">].skipWhitespace</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.skipWhitespace = </span><span class="s2">False</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.mayReturnEmpty = </span><span class="s2">True</span>
        <span class="s1">self.callPreparse = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">streamline(self) -&gt; ParserElement:</span>
        <span class="s0"># collapse any _PendingSkip's</span>
        <span class="s2">if </span><span class="s1">self.exprs:</span>
            <span class="s2">if </span><span class="s1">any(</span>
                <span class="s1">isinstance(e</span><span class="s2">, </span><span class="s1">ParseExpression)</span>
                <span class="s2">and </span><span class="s1">e.exprs</span>
                <span class="s2">and </span><span class="s1">isinstance(e.exprs[-</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">_PendingSkip)</span>
                <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs[:-</span><span class="s3">1</span><span class="s1">]</span>
            <span class="s1">):</span>
                <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">e </span><span class="s2">in </span><span class="s1">enumerate(self.exprs[:-</span><span class="s3">1</span><span class="s1">]):</span>
                    <span class="s2">if </span><span class="s1">e </span><span class="s2">is None</span><span class="s1">:</span>
                        <span class="s2">continue</span>
                    <span class="s2">if </span><span class="s1">(</span>
                        <span class="s1">isinstance(e</span><span class="s2">, </span><span class="s1">ParseExpression)</span>
                        <span class="s2">and </span><span class="s1">e.exprs</span>
                        <span class="s2">and </span><span class="s1">isinstance(e.exprs[-</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">_PendingSkip)</span>
                    <span class="s1">):</span>
                        <span class="s1">e.exprs[-</span><span class="s3">1</span><span class="s1">] = e.exprs[-</span><span class="s3">1</span><span class="s1">] + self.exprs[i + </span><span class="s3">1</span><span class="s1">]</span>
                        <span class="s1">self.exprs[i + </span><span class="s3">1</span><span class="s1">] = </span><span class="s2">None</span>
                <span class="s1">self.exprs = [e </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs </span><span class="s2">if </span><span class="s1">e </span><span class="s2">is not None</span><span class="s1">]</span>

        <span class="s1">super().streamline()</span>

        <span class="s0"># link any IndentedBlocks to the prior expression</span>
        <span class="s2">for </span><span class="s1">prev</span><span class="s2">, </span><span class="s1">cur </span><span class="s2">in </span><span class="s1">zip(self.exprs</span><span class="s2">, </span><span class="s1">self.exprs[</span><span class="s3">1</span><span class="s1">:]):</span>
            <span class="s0"># traverse cur or any first embedded expr of cur looking for an IndentedBlock</span>
            <span class="s0"># (but watch out for recursive grammar)</span>
            <span class="s1">seen = set()</span>
            <span class="s2">while </span><span class="s1">cur:</span>
                <span class="s2">if </span><span class="s1">id(cur) </span><span class="s2">in </span><span class="s1">seen:</span>
                    <span class="s2">break</span>
                <span class="s1">seen.add(id(cur))</span>
                <span class="s2">if </span><span class="s1">isinstance(cur</span><span class="s2">, </span><span class="s1">IndentedBlock):</span>
                    <span class="s1">prev.add_parse_action(</span>
                        <span class="s2">lambda </span><span class="s1">s</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">cur_=cur: setattr(</span>
                            <span class="s1">cur_</span><span class="s2">, </span><span class="s5">&quot;parent_anchor&quot;</span><span class="s2">, </span><span class="s1">col(l</span><span class="s2">, </span><span class="s1">s)</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>
                    <span class="s2">break</span>
                <span class="s1">subs = cur.recurse()</span>
                <span class="s1">cur = next(iter(subs)</span><span class="s2">, None</span><span class="s1">)</span>

        <span class="s1">self.mayReturnEmpty = all(e.mayReturnEmpty </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0"># pass False as callPreParse arg to _parse for first element, since we already</span>
        <span class="s0"># pre-parsed the string as part of our And pre-parsing</span>
        <span class="s1">loc</span><span class="s2">, </span><span class="s1">resultlist = self.exprs[</span><span class="s3">0</span><span class="s1">]._parse(</span>
            <span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions</span><span class="s2">, </span><span class="s1">callPreParse=</span><span class="s2">False</span>
        <span class="s1">)</span>
        <span class="s1">errorStop = </span><span class="s2">False</span>
        <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs[</span><span class="s3">1</span><span class="s1">:]:</span>
            <span class="s0"># if isinstance(e, And._ErrorStop):</span>
            <span class="s2">if </span><span class="s1">type(e) </span><span class="s2">is </span><span class="s1">And._ErrorStop:</span>
                <span class="s1">errorStop = </span><span class="s2">True</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">errorStop:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">loc</span><span class="s2">, </span><span class="s1">exprtokens = e._parse(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions)</span>
                <span class="s2">except </span><span class="s1">ParseSyntaxException:</span>
                    <span class="s2">raise</span>
                <span class="s2">except </span><span class="s1">ParseBaseException </span><span class="s2">as </span><span class="s1">pe:</span>
                    <span class="s1">pe.__traceback__ = </span><span class="s2">None</span>
                    <span class="s2">raise </span><span class="s1">ParseSyntaxException._from_exception(pe)</span>
                <span class="s2">except </span><span class="s1">IndexError:</span>
                    <span class="s2">raise </span><span class="s1">ParseSyntaxException(</span>
                        <span class="s1">instring</span><span class="s2">, </span><span class="s1">len(instring)</span><span class="s2">, </span><span class="s1">self.errmsg</span><span class="s2">, </span><span class="s1">self</span>
                    <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">loc</span><span class="s2">, </span><span class="s1">exprtokens = e._parse(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions)</span>
            <span class="s2">if </span><span class="s1">exprtokens </span><span class="s2">or </span><span class="s1">exprtokens.haskeys():</span>
                <span class="s1">resultlist += exprtokens</span>
        <span class="s2">return </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">resultlist</span>

    <span class="s2">def </span><span class="s1">__iadd__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">str_type):</span>
            <span class="s1">other = self._literalStringClass(other)</span>
        <span class="s2">return </span><span class="s1">self.append(other)  </span><span class="s0"># And([self, other])</span>

    <span class="s2">def </span><span class="s1">_checkRecursion(self</span><span class="s2">, </span><span class="s1">parseElementList):</span>
        <span class="s1">subRecCheckList = parseElementList[:] + [self]</span>
        <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs:</span>
            <span class="s1">e._checkRecursion(subRecCheckList)</span>
            <span class="s2">if not </span><span class="s1">e.mayReturnEmpty:</span>
                <span class="s2">break</span>

    <span class="s2">def </span><span class="s1">_generateDefaultName(self):</span>
        <span class="s1">inner = </span><span class="s5">&quot; &quot;</span><span class="s1">.join(str(e) </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs)</span>
        <span class="s0"># strip off redundant inner {}'s</span>
        <span class="s2">while </span><span class="s1">len(inner) &gt; </span><span class="s3">1 </span><span class="s2">and </span><span class="s1">inner[</span><span class="s3">0 </span><span class="s1">:: len(inner) - </span><span class="s3">1</span><span class="s1">] == </span><span class="s5">&quot;{}&quot;</span><span class="s1">:</span>
            <span class="s1">inner = inner[</span><span class="s3">1</span><span class="s1">:-</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s5">&quot;{&quot; </span><span class="s1">+ inner + </span><span class="s5">&quot;}&quot;</span>


<span class="s2">class </span><span class="s1">Or(ParseExpression):</span>
    <span class="s4">&quot;&quot;&quot;Requires that at least one :class:`ParseExpression` is found. If 
    two expressions match, the expression that matches the longest 
    string will be used. May be constructed using the ``'^'`` 
    operator. 
 
    Example:: 
 
        # construct Or using '^' operator 
 
        number = Word(nums) ^ Combine(Word(nums) + '.' + Word(nums)) 
        print(number.search_string(&quot;123 3.1416 789&quot;)) 
 
    prints:: 
 
        [['123'], ['3.1416'], ['789']] 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">exprs: typing.Iterable[ParserElement]</span><span class="s2">, </span><span class="s1">savelist: bool = </span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">super().__init__(exprs</span><span class="s2">, </span><span class="s1">savelist)</span>
        <span class="s2">if </span><span class="s1">self.exprs:</span>
            <span class="s1">self.mayReturnEmpty = any(e.mayReturnEmpty </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs)</span>
            <span class="s1">self.skipWhitespace = all(e.skipWhitespace </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.mayReturnEmpty = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">streamline(self) -&gt; ParserElement:</span>
        <span class="s1">super().streamline()</span>
        <span class="s2">if </span><span class="s1">self.exprs:</span>
            <span class="s1">self.mayReturnEmpty = any(e.mayReturnEmpty </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs)</span>
            <span class="s1">self.saveAsList = any(e.saveAsList </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs)</span>
            <span class="s1">self.skipWhitespace = all(</span>
                <span class="s1">e.skipWhitespace </span><span class="s2">and not </span><span class="s1">isinstance(e</span><span class="s2">, </span><span class="s1">White) </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.saveAsList = </span><span class="s2">False</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s1">maxExcLoc = -</span><span class="s3">1</span>
        <span class="s1">maxException = </span><span class="s2">None</span>
        <span class="s1">matches = []</span>
        <span class="s1">fatals = []</span>
        <span class="s2">if </span><span class="s1">all(e.callPreparse </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs):</span>
            <span class="s1">loc = self.preParse(instring</span><span class="s2">, </span><span class="s1">loc)</span>
        <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">loc2 = e.try_parse(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">raise_fatal=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s2">except </span><span class="s1">ParseFatalException </span><span class="s2">as </span><span class="s1">pfe:</span>
                <span class="s1">pfe.__traceback__ = </span><span class="s2">None</span>
                <span class="s1">pfe.parserElement = e</span>
                <span class="s1">fatals.append(pfe)</span>
                <span class="s1">maxException = </span><span class="s2">None</span>
                <span class="s1">maxExcLoc = -</span><span class="s3">1</span>
            <span class="s2">except </span><span class="s1">ParseException </span><span class="s2">as </span><span class="s1">err:</span>
                <span class="s2">if not </span><span class="s1">fatals:</span>
                    <span class="s1">err.__traceback__ = </span><span class="s2">None</span>
                    <span class="s2">if </span><span class="s1">err.loc &gt; maxExcLoc:</span>
                        <span class="s1">maxException = err</span>
                        <span class="s1">maxExcLoc = err.loc</span>
            <span class="s2">except </span><span class="s1">IndexError:</span>
                <span class="s2">if </span><span class="s1">len(instring) &gt; maxExcLoc:</span>
                    <span class="s1">maxException = ParseException(</span>
                        <span class="s1">instring</span><span class="s2">, </span><span class="s1">len(instring)</span><span class="s2">, </span><span class="s1">e.errmsg</span><span class="s2">, </span><span class="s1">self</span>
                    <span class="s1">)</span>
                    <span class="s1">maxExcLoc = len(instring)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s0"># save match among all matches, to retry longest to shortest</span>
                <span class="s1">matches.append((loc2</span><span class="s2">, </span><span class="s1">e))</span>

        <span class="s2">if </span><span class="s1">matches:</span>
            <span class="s0"># re-evaluate all matches in descending order of length of match, in case attached actions</span>
            <span class="s0"># might change whether or how much they match of the input.</span>
            <span class="s1">matches.sort(key=itemgetter(</span><span class="s3">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">reverse=</span><span class="s2">True</span><span class="s1">)</span>

            <span class="s2">if not </span><span class="s1">doActions:</span>
                <span class="s0"># no further conditions or parse actions to change the selection of</span>
                <span class="s0"># alternative, so the first match will be the best match</span>
                <span class="s1">best_expr = matches[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">1</span><span class="s1">]</span>
                <span class="s2">return </span><span class="s1">best_expr._parse(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions)</span>

            <span class="s1">longest = -</span><span class="s3">1</span><span class="s2">, None</span>
            <span class="s2">for </span><span class="s1">loc1</span><span class="s2">, </span><span class="s1">expr1 </span><span class="s2">in </span><span class="s1">matches:</span>
                <span class="s2">if </span><span class="s1">loc1 &lt;= longest[</span><span class="s3">0</span><span class="s1">]:</span>
                    <span class="s0"># already have a longer match than this one will deliver, we are done</span>
                    <span class="s2">return </span><span class="s1">longest</span>

                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">loc2</span><span class="s2">, </span><span class="s1">toks = expr1._parse(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions)</span>
                <span class="s2">except </span><span class="s1">ParseException </span><span class="s2">as </span><span class="s1">err:</span>
                    <span class="s1">err.__traceback__ = </span><span class="s2">None</span>
                    <span class="s2">if </span><span class="s1">err.loc &gt; maxExcLoc:</span>
                        <span class="s1">maxException = err</span>
                        <span class="s1">maxExcLoc = err.loc</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">loc2 &gt;= loc1:</span>
                        <span class="s2">return </span><span class="s1">loc2</span><span class="s2">, </span><span class="s1">toks</span>
                    <span class="s0"># didn't match as much as before</span>
                    <span class="s2">elif </span><span class="s1">loc2 &gt; longest[</span><span class="s3">0</span><span class="s1">]:</span>
                        <span class="s1">longest = loc2</span><span class="s2">, </span><span class="s1">toks</span>

            <span class="s2">if </span><span class="s1">longest != (-</span><span class="s3">1</span><span class="s2">, None</span><span class="s1">):</span>
                <span class="s2">return </span><span class="s1">longest</span>

        <span class="s2">if </span><span class="s1">fatals:</span>
            <span class="s2">if </span><span class="s1">len(fatals) &gt; </span><span class="s3">1</span><span class="s1">:</span>
                <span class="s1">fatals.sort(key=</span><span class="s2">lambda </span><span class="s1">e: -e.loc)</span>
                <span class="s2">if </span><span class="s1">fatals[</span><span class="s3">0</span><span class="s1">].loc == fatals[</span><span class="s3">1</span><span class="s1">].loc:</span>
                    <span class="s1">fatals.sort(key=</span><span class="s2">lambda </span><span class="s1">e: (-e.loc</span><span class="s2">, </span><span class="s1">-len(str(e.parserElement))))</span>
            <span class="s1">max_fatal = fatals[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s2">raise </span><span class="s1">max_fatal</span>

        <span class="s2">if </span><span class="s1">maxException </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">maxException.msg = self.errmsg</span>
            <span class="s2">raise </span><span class="s1">maxException</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ParseException(</span>
                <span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s5">&quot;no defined alternatives to match&quot;</span><span class="s2">, </span><span class="s1">self</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__ixor__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">str_type):</span>
            <span class="s1">other = self._literalStringClass(other)</span>
        <span class="s2">return </span><span class="s1">self.append(other)  </span><span class="s0"># Or([self, other])</span>

    <span class="s2">def </span><span class="s1">_generateDefaultName(self):</span>
        <span class="s2">return </span><span class="s5">&quot;{&quot; </span><span class="s1">+ </span><span class="s5">&quot; ^ &quot;</span><span class="s1">.join(str(e) </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs) + </span><span class="s5">&quot;}&quot;</span>

    <span class="s2">def </span><span class="s1">_setResultsName(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">listAllMatches=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">__diag__.warn_multiple_tokens_in_named_alternation</span>
            <span class="s2">and </span><span class="s1">Diagnostics.warn_multiple_tokens_in_named_alternation</span>
            <span class="s2">not in </span><span class="s1">self.suppress_warnings_</span>
        <span class="s1">):</span>
            <span class="s2">if </span><span class="s1">any(</span>
                <span class="s1">isinstance(e</span><span class="s2">, </span><span class="s1">And)</span>
                <span class="s2">and </span><span class="s1">Diagnostics.warn_multiple_tokens_in_named_alternation</span>
                <span class="s2">not in </span><span class="s1">e.suppress_warnings_</span>
                <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs</span>
            <span class="s1">):</span>
                <span class="s1">warnings.warn(</span>
                    <span class="s5">&quot;{}: setting results name {!r} on {} expression &quot;</span>
                    <span class="s5">&quot;will return a list of all parsed tokens in an And alternative, &quot;</span>
                    <span class="s5">&quot;in prior versions only the first token was returned; enclose &quot;</span>
                    <span class="s5">&quot;contained argument in Group&quot;</span><span class="s1">.format(</span>
                        <span class="s5">&quot;warn_multiple_tokens_in_named_alternation&quot;</span><span class="s2">,</span>
                        <span class="s1">name</span><span class="s2">,</span>
                        <span class="s1">type(self).__name__</span><span class="s2">,</span>
                    <span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">stacklevel=</span><span class="s3">3</span><span class="s2">,</span>
                <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">super()._setResultsName(name</span><span class="s2">, </span><span class="s1">listAllMatches)</span>


<span class="s2">class </span><span class="s1">MatchFirst(ParseExpression):</span>
    <span class="s4">&quot;&quot;&quot;Requires that at least one :class:`ParseExpression` is found. If 
    more than one expression matches, the first one listed is the one that will 
    match. May be constructed using the ``'|'`` operator. 
 
    Example:: 
 
        # construct MatchFirst using '|' operator 
 
        # watch the order of expressions to match 
        number = Word(nums) | Combine(Word(nums) + '.' + Word(nums)) 
        print(number.search_string(&quot;123 3.1416 789&quot;)) #  Fail! -&gt; [['123'], ['3'], ['1416'], ['789']] 
 
        # put more selective expression first 
        number = Combine(Word(nums) + '.' + Word(nums)) | Word(nums) 
        print(number.search_string(&quot;123 3.1416 789&quot;)) #  Better -&gt; [['123'], ['3.1416'], ['789']] 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">exprs: typing.Iterable[ParserElement]</span><span class="s2">, </span><span class="s1">savelist: bool = </span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">super().__init__(exprs</span><span class="s2">, </span><span class="s1">savelist)</span>
        <span class="s2">if </span><span class="s1">self.exprs:</span>
            <span class="s1">self.mayReturnEmpty = any(e.mayReturnEmpty </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs)</span>
            <span class="s1">self.skipWhitespace = all(e.skipWhitespace </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.mayReturnEmpty = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">streamline(self) -&gt; ParserElement:</span>
        <span class="s2">if </span><span class="s1">self.streamlined:</span>
            <span class="s2">return </span><span class="s1">self</span>

        <span class="s1">super().streamline()</span>
        <span class="s2">if </span><span class="s1">self.exprs:</span>
            <span class="s1">self.saveAsList = any(e.saveAsList </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs)</span>
            <span class="s1">self.mayReturnEmpty = any(e.mayReturnEmpty </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs)</span>
            <span class="s1">self.skipWhitespace = all(</span>
                <span class="s1">e.skipWhitespace </span><span class="s2">and not </span><span class="s1">isinstance(e</span><span class="s2">, </span><span class="s1">White) </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.saveAsList = </span><span class="s2">False</span>
            <span class="s1">self.mayReturnEmpty = </span><span class="s2">True</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s1">maxExcLoc = -</span><span class="s3">1</span>
        <span class="s1">maxException = </span><span class="s2">None</span>

        <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">e._parse(</span>
                    <span class="s1">instring</span><span class="s2">,</span>
                    <span class="s1">loc</span><span class="s2">,</span>
                    <span class="s1">doActions</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s2">except </span><span class="s1">ParseFatalException </span><span class="s2">as </span><span class="s1">pfe:</span>
                <span class="s1">pfe.__traceback__ = </span><span class="s2">None</span>
                <span class="s1">pfe.parserElement = e</span>
                <span class="s2">raise</span>
            <span class="s2">except </span><span class="s1">ParseException </span><span class="s2">as </span><span class="s1">err:</span>
                <span class="s2">if </span><span class="s1">err.loc &gt; maxExcLoc:</span>
                    <span class="s1">maxException = err</span>
                    <span class="s1">maxExcLoc = err.loc</span>
            <span class="s2">except </span><span class="s1">IndexError:</span>
                <span class="s2">if </span><span class="s1">len(instring) &gt; maxExcLoc:</span>
                    <span class="s1">maxException = ParseException(</span>
                        <span class="s1">instring</span><span class="s2">, </span><span class="s1">len(instring)</span><span class="s2">, </span><span class="s1">e.errmsg</span><span class="s2">, </span><span class="s1">self</span>
                    <span class="s1">)</span>
                    <span class="s1">maxExcLoc = len(instring)</span>

        <span class="s2">if </span><span class="s1">maxException </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">maxException.msg = self.errmsg</span>
            <span class="s2">raise </span><span class="s1">maxException</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ParseException(</span>
                <span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s5">&quot;no defined alternatives to match&quot;</span><span class="s2">, </span><span class="s1">self</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__ior__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">str_type):</span>
            <span class="s1">other = self._literalStringClass(other)</span>
        <span class="s2">return </span><span class="s1">self.append(other)  </span><span class="s0"># MatchFirst([self, other])</span>

    <span class="s2">def </span><span class="s1">_generateDefaultName(self):</span>
        <span class="s2">return </span><span class="s5">&quot;{&quot; </span><span class="s1">+ </span><span class="s5">&quot; | &quot;</span><span class="s1">.join(str(e) </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs) + </span><span class="s5">&quot;}&quot;</span>

    <span class="s2">def </span><span class="s1">_setResultsName(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">listAllMatches=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">__diag__.warn_multiple_tokens_in_named_alternation</span>
            <span class="s2">and </span><span class="s1">Diagnostics.warn_multiple_tokens_in_named_alternation</span>
            <span class="s2">not in </span><span class="s1">self.suppress_warnings_</span>
        <span class="s1">):</span>
            <span class="s2">if </span><span class="s1">any(</span>
                <span class="s1">isinstance(e</span><span class="s2">, </span><span class="s1">And)</span>
                <span class="s2">and </span><span class="s1">Diagnostics.warn_multiple_tokens_in_named_alternation</span>
                <span class="s2">not in </span><span class="s1">e.suppress_warnings_</span>
                <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs</span>
            <span class="s1">):</span>
                <span class="s1">warnings.warn(</span>
                    <span class="s5">&quot;{}: setting results name {!r} on {} expression &quot;</span>
                    <span class="s5">&quot;will return a list of all parsed tokens in an And alternative, &quot;</span>
                    <span class="s5">&quot;in prior versions only the first token was returned; enclose &quot;</span>
                    <span class="s5">&quot;contained argument in Group&quot;</span><span class="s1">.format(</span>
                        <span class="s5">&quot;warn_multiple_tokens_in_named_alternation&quot;</span><span class="s2">,</span>
                        <span class="s1">name</span><span class="s2">,</span>
                        <span class="s1">type(self).__name__</span><span class="s2">,</span>
                    <span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">stacklevel=</span><span class="s3">3</span><span class="s2">,</span>
                <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">super()._setResultsName(name</span><span class="s2">, </span><span class="s1">listAllMatches)</span>


<span class="s2">class </span><span class="s1">Each(ParseExpression):</span>
    <span class="s4">&quot;&quot;&quot;Requires all given :class:`ParseExpression` s to be found, but in 
    any order. Expressions may be separated by whitespace. 
 
    May be constructed using the ``'&amp;'`` operator. 
 
    Example:: 
 
        color = one_of(&quot;RED ORANGE YELLOW GREEN BLUE PURPLE BLACK WHITE BROWN&quot;) 
        shape_type = one_of(&quot;SQUARE CIRCLE TRIANGLE STAR HEXAGON OCTAGON&quot;) 
        integer = Word(nums) 
        shape_attr = &quot;shape:&quot; + shape_type(&quot;shape&quot;) 
        posn_attr = &quot;posn:&quot; + Group(integer(&quot;x&quot;) + ',' + integer(&quot;y&quot;))(&quot;posn&quot;) 
        color_attr = &quot;color:&quot; + color(&quot;color&quot;) 
        size_attr = &quot;size:&quot; + integer(&quot;size&quot;) 
 
        # use Each (using operator '&amp;') to accept attributes in any order 
        # (shape and posn are required, color and size are optional) 
        shape_spec = shape_attr &amp; posn_attr &amp; Opt(color_attr) &amp; Opt(size_attr) 
 
        shape_spec.run_tests(''' 
            shape: SQUARE color: BLACK posn: 100, 120 
            shape: CIRCLE size: 50 color: BLUE posn: 50,80 
            color:GREEN size:20 shape:TRIANGLE posn:20,40 
            ''' 
            ) 
 
    prints:: 
 
        shape: SQUARE color: BLACK posn: 100, 120 
        ['shape:', 'SQUARE', 'color:', 'BLACK', 'posn:', ['100', ',', '120']] 
        - color: BLACK 
        - posn: ['100', ',', '120'] 
          - x: 100 
          - y: 120 
        - shape: SQUARE 
 
 
        shape: CIRCLE size: 50 color: BLUE posn: 50,80 
        ['shape:', 'CIRCLE', 'size:', '50', 'color:', 'BLUE', 'posn:', ['50', ',', '80']] 
        - color: BLUE 
        - posn: ['50', ',', '80'] 
          - x: 50 
          - y: 80 
        - shape: CIRCLE 
        - size: 50 
 
 
        color: GREEN size: 20 shape: TRIANGLE posn: 20,40 
        ['color:', 'GREEN', 'size:', '20', 'shape:', 'TRIANGLE', 'posn:', ['20', ',', '40']] 
        - color: GREEN 
        - posn: ['20', ',', '40'] 
          - x: 20 
          - y: 40 
        - shape: TRIANGLE 
        - size: 20 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">exprs: typing.Iterable[ParserElement]</span><span class="s2">, </span><span class="s1">savelist: bool = </span><span class="s2">True</span><span class="s1">):</span>
        <span class="s1">super().__init__(exprs</span><span class="s2">, </span><span class="s1">savelist)</span>
        <span class="s2">if </span><span class="s1">self.exprs:</span>
            <span class="s1">self.mayReturnEmpty = all(e.mayReturnEmpty </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.mayReturnEmpty = </span><span class="s2">True</span>
        <span class="s1">self.skipWhitespace = </span><span class="s2">True</span>
        <span class="s1">self.initExprGroups = </span><span class="s2">True</span>
        <span class="s1">self.saveAsList = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">streamline(self) -&gt; ParserElement:</span>
        <span class="s1">super().streamline()</span>
        <span class="s2">if </span><span class="s1">self.exprs:</span>
            <span class="s1">self.mayReturnEmpty = all(e.mayReturnEmpty </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.mayReturnEmpty = </span><span class="s2">True</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">self.initExprGroups:</span>
            <span class="s1">self.opt1map = dict(</span>
                <span class="s1">(id(e.expr)</span><span class="s2">, </span><span class="s1">e) </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs </span><span class="s2">if </span><span class="s1">isinstance(e</span><span class="s2">, </span><span class="s1">Opt)</span>
            <span class="s1">)</span>
            <span class="s1">opt1 = [e.expr </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs </span><span class="s2">if </span><span class="s1">isinstance(e</span><span class="s2">, </span><span class="s1">Opt)]</span>
            <span class="s1">opt2 = [</span>
                <span class="s1">e</span>
                <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs</span>
                <span class="s2">if </span><span class="s1">e.mayReturnEmpty </span><span class="s2">and not </span><span class="s1">isinstance(e</span><span class="s2">, </span><span class="s1">(Opt</span><span class="s2">, </span><span class="s1">Regex</span><span class="s2">, </span><span class="s1">ZeroOrMore))</span>
            <span class="s1">]</span>
            <span class="s1">self.optionals = opt1 + opt2</span>
            <span class="s1">self.multioptionals = [</span>
                <span class="s1">e.expr.set_results_name(e.resultsName</span><span class="s2">, </span><span class="s1">list_all_matches=</span><span class="s2">True</span><span class="s1">)</span>
                <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs</span>
                <span class="s2">if </span><span class="s1">isinstance(e</span><span class="s2">, </span><span class="s1">_MultipleMatch)</span>
            <span class="s1">]</span>
            <span class="s1">self.multirequired = [</span>
                <span class="s1">e.expr.set_results_name(e.resultsName</span><span class="s2">, </span><span class="s1">list_all_matches=</span><span class="s2">True</span><span class="s1">)</span>
                <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs</span>
                <span class="s2">if </span><span class="s1">isinstance(e</span><span class="s2">, </span><span class="s1">OneOrMore)</span>
            <span class="s1">]</span>
            <span class="s1">self.required = [</span>
                <span class="s1">e </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs </span><span class="s2">if not </span><span class="s1">isinstance(e</span><span class="s2">, </span><span class="s1">(Opt</span><span class="s2">, </span><span class="s1">ZeroOrMore</span><span class="s2">, </span><span class="s1">OneOrMore))</span>
            <span class="s1">]</span>
            <span class="s1">self.required += self.multirequired</span>
            <span class="s1">self.initExprGroups = </span><span class="s2">False</span>

        <span class="s1">tmpLoc = loc</span>
        <span class="s1">tmpReqd = self.required[:]</span>
        <span class="s1">tmpOpt = self.optionals[:]</span>
        <span class="s1">multis = self.multioptionals[:]</span>
        <span class="s1">matchOrder = []</span>

        <span class="s1">keepMatching = </span><span class="s2">True</span>
        <span class="s1">failed = []</span>
        <span class="s1">fatals = []</span>
        <span class="s2">while </span><span class="s1">keepMatching:</span>
            <span class="s1">tmpExprs = tmpReqd + tmpOpt + multis</span>
            <span class="s1">failed.clear()</span>
            <span class="s1">fatals.clear()</span>
            <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">tmpExprs:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">tmpLoc = e.try_parse(instring</span><span class="s2">, </span><span class="s1">tmpLoc</span><span class="s2">, </span><span class="s1">raise_fatal=</span><span class="s2">True</span><span class="s1">)</span>
                <span class="s2">except </span><span class="s1">ParseFatalException </span><span class="s2">as </span><span class="s1">pfe:</span>
                    <span class="s1">pfe.__traceback__ = </span><span class="s2">None</span>
                    <span class="s1">pfe.parserElement = e</span>
                    <span class="s1">fatals.append(pfe)</span>
                    <span class="s1">failed.append(e)</span>
                <span class="s2">except </span><span class="s1">ParseException:</span>
                    <span class="s1">failed.append(e)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">matchOrder.append(self.opt1map.get(id(e)</span><span class="s2">, </span><span class="s1">e))</span>
                    <span class="s2">if </span><span class="s1">e </span><span class="s2">in </span><span class="s1">tmpReqd:</span>
                        <span class="s1">tmpReqd.remove(e)</span>
                    <span class="s2">elif </span><span class="s1">e </span><span class="s2">in </span><span class="s1">tmpOpt:</span>
                        <span class="s1">tmpOpt.remove(e)</span>
            <span class="s2">if </span><span class="s1">len(failed) == len(tmpExprs):</span>
                <span class="s1">keepMatching = </span><span class="s2">False</span>

        <span class="s0"># look for any ParseFatalExceptions</span>
        <span class="s2">if </span><span class="s1">fatals:</span>
            <span class="s2">if </span><span class="s1">len(fatals) &gt; </span><span class="s3">1</span><span class="s1">:</span>
                <span class="s1">fatals.sort(key=</span><span class="s2">lambda </span><span class="s1">e: -e.loc)</span>
                <span class="s2">if </span><span class="s1">fatals[</span><span class="s3">0</span><span class="s1">].loc == fatals[</span><span class="s3">1</span><span class="s1">].loc:</span>
                    <span class="s1">fatals.sort(key=</span><span class="s2">lambda </span><span class="s1">e: (-e.loc</span><span class="s2">, </span><span class="s1">-len(str(e.parserElement))))</span>
            <span class="s1">max_fatal = fatals[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s2">raise </span><span class="s1">max_fatal</span>

        <span class="s2">if </span><span class="s1">tmpReqd:</span>
            <span class="s1">missing = </span><span class="s5">&quot;, &quot;</span><span class="s1">.join([str(e) </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">tmpReqd])</span>
            <span class="s2">raise </span><span class="s1">ParseException(</span>
                <span class="s1">instring</span><span class="s2">,</span>
                <span class="s1">loc</span><span class="s2">,</span>
                <span class="s5">&quot;Missing one or more required elements ({})&quot;</span><span class="s1">.format(missing)</span><span class="s2">,</span>
            <span class="s1">)</span>

        <span class="s0"># add any unmatched Opts, in case they have default values defined</span>
        <span class="s1">matchOrder += [e </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs </span><span class="s2">if </span><span class="s1">isinstance(e</span><span class="s2">, </span><span class="s1">Opt) </span><span class="s2">and </span><span class="s1">e.expr </span><span class="s2">in </span><span class="s1">tmpOpt]</span>

        <span class="s1">total_results = ParseResults([])</span>
        <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">matchOrder:</span>
            <span class="s1">loc</span><span class="s2">, </span><span class="s1">results = e._parse(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions)</span>
            <span class="s1">total_results += results</span>

        <span class="s2">return </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">total_results</span>

    <span class="s2">def </span><span class="s1">_generateDefaultName(self):</span>
        <span class="s2">return </span><span class="s5">&quot;{&quot; </span><span class="s1">+ </span><span class="s5">&quot; &amp; &quot;</span><span class="s1">.join(str(e) </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self.exprs) + </span><span class="s5">&quot;}&quot;</span>


<span class="s2">class </span><span class="s1">ParseElementEnhance(ParserElement):</span>
    <span class="s4">&quot;&quot;&quot;Abstract subclass of :class:`ParserElement`, for combining and 
    post-processing parsed tokens. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">expr: Union[ParserElement</span><span class="s2">, </span><span class="s1">str]</span><span class="s2">, </span><span class="s1">savelist: bool = </span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">super().__init__(savelist)</span>
        <span class="s2">if </span><span class="s1">isinstance(expr</span><span class="s2">, </span><span class="s1">str_type):</span>
            <span class="s2">if </span><span class="s1">issubclass(self._literalStringClass</span><span class="s2">, </span><span class="s1">Token):</span>
                <span class="s1">expr = self._literalStringClass(expr)</span>
            <span class="s2">elif </span><span class="s1">issubclass(type(self)</span><span class="s2">, </span><span class="s1">self._literalStringClass):</span>
                <span class="s1">expr = Literal(expr)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">expr = self._literalStringClass(Literal(expr))</span>
        <span class="s1">self.expr = expr</span>
        <span class="s2">if </span><span class="s1">expr </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.mayIndexError = expr.mayIndexError</span>
            <span class="s1">self.mayReturnEmpty = expr.mayReturnEmpty</span>
            <span class="s1">self.set_whitespace_chars(</span>
                <span class="s1">expr.whiteChars</span><span class="s2">, </span><span class="s1">copy_defaults=expr.copyDefaultWhiteChars</span>
            <span class="s1">)</span>
            <span class="s1">self.skipWhitespace = expr.skipWhitespace</span>
            <span class="s1">self.saveAsList = expr.saveAsList</span>
            <span class="s1">self.callPreparse = expr.callPreparse</span>
            <span class="s1">self.ignoreExprs.extend(expr.ignoreExprs)</span>

    <span class="s2">def </span><span class="s1">recurse(self) -&gt; Sequence[ParserElement]:</span>
        <span class="s2">return </span><span class="s1">[self.expr] </span><span class="s2">if </span><span class="s1">self.expr </span><span class="s2">is not None else </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">self.expr </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.expr._parse(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions</span><span class="s2">, </span><span class="s1">callPreParse=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s5">&quot;No expression defined&quot;</span><span class="s2">, </span><span class="s1">self)</span>

    <span class="s2">def </span><span class="s1">leave_whitespace(self</span><span class="s2">, </span><span class="s1">recursive: bool = </span><span class="s2">True</span><span class="s1">) -&gt; ParserElement:</span>
        <span class="s1">super().leave_whitespace(recursive)</span>

        <span class="s2">if </span><span class="s1">recursive:</span>
            <span class="s1">self.expr = self.expr.copy()</span>
            <span class="s2">if </span><span class="s1">self.expr </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">self.expr.leave_whitespace(recursive)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">ignore_whitespace(self</span><span class="s2">, </span><span class="s1">recursive: bool = </span><span class="s2">True</span><span class="s1">) -&gt; ParserElement:</span>
        <span class="s1">super().ignore_whitespace(recursive)</span>

        <span class="s2">if </span><span class="s1">recursive:</span>
            <span class="s1">self.expr = self.expr.copy()</span>
            <span class="s2">if </span><span class="s1">self.expr </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">self.expr.ignore_whitespace(recursive)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">ignore(self</span><span class="s2">, </span><span class="s1">other) -&gt; ParserElement:</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">Suppress):</span>
            <span class="s2">if </span><span class="s1">other </span><span class="s2">not in </span><span class="s1">self.ignoreExprs:</span>
                <span class="s1">super().ignore(other)</span>
                <span class="s2">if </span><span class="s1">self.expr </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">self.expr.ignore(self.ignoreExprs[-</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">super().ignore(other)</span>
            <span class="s2">if </span><span class="s1">self.expr </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">self.expr.ignore(self.ignoreExprs[-</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">streamline(self) -&gt; ParserElement:</span>
        <span class="s1">super().streamline()</span>
        <span class="s2">if </span><span class="s1">self.expr </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.expr.streamline()</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">_checkRecursion(self</span><span class="s2">, </span><span class="s1">parseElementList):</span>
        <span class="s2">if </span><span class="s1">self </span><span class="s2">in </span><span class="s1">parseElementList:</span>
            <span class="s2">raise </span><span class="s1">RecursiveGrammarException(parseElementList + [self])</span>
        <span class="s1">subRecCheckList = parseElementList[:] + [self]</span>
        <span class="s2">if </span><span class="s1">self.expr </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.expr._checkRecursion(subRecCheckList)</span>

    <span class="s2">def </span><span class="s1">validate(self</span><span class="s2">, </span><span class="s1">validateTrace=</span><span class="s2">None</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">validateTrace </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">validateTrace = []</span>
        <span class="s1">tmp = validateTrace[:] + [self]</span>
        <span class="s2">if </span><span class="s1">self.expr </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.expr.validate(tmp)</span>
        <span class="s1">self._checkRecursion([])</span>

    <span class="s2">def </span><span class="s1">_generateDefaultName(self):</span>
        <span class="s2">return </span><span class="s5">&quot;{}:({})&quot;</span><span class="s1">.format(self.__class__.__name__</span><span class="s2">, </span><span class="s1">str(self.expr))</span>

    <span class="s1">ignoreWhitespace = ignore_whitespace</span>
    <span class="s1">leaveWhitespace = leave_whitespace</span>


<span class="s2">class </span><span class="s1">IndentedBlock(ParseElementEnhance):</span>
    <span class="s4">&quot;&quot;&quot; 
    Expression to match one or more expressions at a given indentation level. 
    Useful for parsing text where structure is implied by indentation (like Python source code). 
    &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">_Indent(Empty):</span>
        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">ref_col: int):</span>
            <span class="s1">super().__init__()</span>
            <span class="s1">self.errmsg = </span><span class="s5">&quot;expected indent at column {}&quot;</span><span class="s1">.format(ref_col)</span>
            <span class="s1">self.add_condition(</span><span class="s2">lambda </span><span class="s1">s</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">t: col(l</span><span class="s2">, </span><span class="s1">s) == ref_col)</span>

    <span class="s2">class </span><span class="s1">_IndentGreater(Empty):</span>
        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">ref_col: int):</span>
            <span class="s1">super().__init__()</span>
            <span class="s1">self.errmsg = </span><span class="s5">&quot;expected indent at column greater than {}&quot;</span><span class="s1">.format(ref_col)</span>
            <span class="s1">self.add_condition(</span><span class="s2">lambda </span><span class="s1">s</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">t: col(l</span><span class="s2">, </span><span class="s1">s) &gt; ref_col)</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">expr: ParserElement</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">recursive: bool = </span><span class="s2">False, </span><span class="s1">grouped: bool = </span><span class="s2">True</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__(expr</span><span class="s2">, </span><span class="s1">savelist=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s0"># if recursive:</span>
        <span class="s0">#     raise NotImplementedError(&quot;IndentedBlock with recursive is not implemented&quot;)</span>
        <span class="s1">self._recursive = recursive</span>
        <span class="s1">self._grouped = grouped</span>
        <span class="s1">self.parent_anchor = </span><span class="s3">1</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0"># advance parse position to non-whitespace by using an Empty()</span>
        <span class="s0"># this should be the column to be used for all subsequent indented lines</span>
        <span class="s1">anchor_loc = Empty().preParse(instring</span><span class="s2">, </span><span class="s1">loc)</span>

        <span class="s0"># see if self.expr matches at the current location - if not it will raise an exception</span>
        <span class="s0"># and no further work is necessary</span>
        <span class="s1">self.expr.try_parse(instring</span><span class="s2">, </span><span class="s1">anchor_loc</span><span class="s2">, </span><span class="s1">doActions)</span>

        <span class="s1">indent_col = col(anchor_loc</span><span class="s2">, </span><span class="s1">instring)</span>
        <span class="s1">peer_detect_expr = self._Indent(indent_col)</span>

        <span class="s1">inner_expr = Empty() + peer_detect_expr + self.expr</span>
        <span class="s2">if </span><span class="s1">self._recursive:</span>
            <span class="s1">sub_indent = self._IndentGreater(indent_col)</span>
            <span class="s1">nested_block = IndentedBlock(</span>
                <span class="s1">self.expr</span><span class="s2">, </span><span class="s1">recursive=self._recursive</span><span class="s2">, </span><span class="s1">grouped=self._grouped</span>
            <span class="s1">)</span>
            <span class="s1">nested_block.set_debug(self.debug)</span>
            <span class="s1">nested_block.parent_anchor = indent_col</span>
            <span class="s1">inner_expr += Opt(sub_indent + nested_block)</span>

        <span class="s1">inner_expr.set_name(</span><span class="s5">f&quot;inner </span><span class="s2">{</span><span class="s1">hex(id(inner_expr))[-</span><span class="s3">4</span><span class="s1">:].upper()</span><span class="s2">}</span><span class="s5">@</span><span class="s2">{</span><span class="s1">indent_col</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s1">)</span>
        <span class="s1">block = OneOrMore(inner_expr)</span>

        <span class="s1">trailing_undent = self._Indent(self.parent_anchor) | StringEnd()</span>

        <span class="s2">if </span><span class="s1">self._grouped:</span>
            <span class="s1">wrapper = Group</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">wrapper = </span><span class="s2">lambda </span><span class="s1">expr: expr</span>
        <span class="s2">return </span><span class="s1">(wrapper(block) + Optional(trailing_undent)).parseImpl(</span>
            <span class="s1">instring</span><span class="s2">, </span><span class="s1">anchor_loc</span><span class="s2">, </span><span class="s1">doActions</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">AtStringStart(ParseElementEnhance):</span>
    <span class="s4">&quot;&quot;&quot;Matches if expression matches at the beginning of the parse 
    string:: 
 
        AtStringStart(Word(nums)).parse_string(&quot;123&quot;) 
        # prints [&quot;123&quot;] 
 
        AtStringStart(Word(nums)).parse_string(&quot;    123&quot;) 
        # raises ParseException 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">expr: Union[ParserElement</span><span class="s2">, </span><span class="s1">str]):</span>
        <span class="s1">super().__init__(expr)</span>
        <span class="s1">self.callPreparse = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">loc != </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s5">&quot;not found at string start&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">super().parseImpl(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions)</span>


<span class="s2">class </span><span class="s1">AtLineStart(ParseElementEnhance):</span>
    <span class="s4">r&quot;&quot;&quot;Matches if an expression matches at the beginning of a line within 
    the parse string 
 
    Example:: 
 
        test = '''\ 
        AAA this line 
        AAA and this line 
          AAA but not this one 
        B AAA and definitely not this one 
        ''' 
 
        for t in (AtLineStart('AAA') + restOfLine).search_string(test): 
            print(t) 
 
    prints:: 
 
        ['AAA', ' this line'] 
        ['AAA', ' and this line'] 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">expr: Union[ParserElement</span><span class="s2">, </span><span class="s1">str]):</span>
        <span class="s1">super().__init__(expr)</span>
        <span class="s1">self.callPreparse = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">col(loc</span><span class="s2">, </span><span class="s1">instring) != </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s5">&quot;not found at line start&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">super().parseImpl(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions)</span>


<span class="s2">class </span><span class="s1">FollowedBy(ParseElementEnhance):</span>
    <span class="s4">&quot;&quot;&quot;Lookahead matching of the given parse expression. 
    ``FollowedBy`` does *not* advance the parsing position within 
    the input string, it only verifies that the specified parse 
    expression matches at the current position.  ``FollowedBy`` 
    always returns a null token list. If any results names are defined 
    in the lookahead expression, those *will* be returned for access by 
    name. 
 
    Example:: 
 
        # use FollowedBy to match a label only if it is followed by a ':' 
        data_word = Word(alphas) 
        label = data_word + FollowedBy(':') 
        attr_expr = Group(label + Suppress(':') + OneOrMore(data_word, stop_on=label).set_parse_action(' '.join)) 
 
        attr_expr[1, ...].parse_string(&quot;shape: SQUARE color: BLACK posn: upper left&quot;).pprint() 
 
    prints:: 
 
        [['shape', 'SQUARE'], ['color', 'BLACK'], ['posn', 'upper left']] 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">expr: Union[ParserElement</span><span class="s2">, </span><span class="s1">str]):</span>
        <span class="s1">super().__init__(expr)</span>
        <span class="s1">self.mayReturnEmpty = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0"># by using self._expr.parse and deleting the contents of the returned ParseResults list</span>
        <span class="s0"># we keep any named results that were defined in the FollowedBy expression</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">ret = self.expr._parse(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=doActions)</span>
        <span class="s2">del </span><span class="s1">ret[:]</span>

        <span class="s2">return </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">ret</span>


<span class="s2">class </span><span class="s1">PrecededBy(ParseElementEnhance):</span>
    <span class="s4">&quot;&quot;&quot;Lookbehind matching of the given parse expression. 
    ``PrecededBy`` does not advance the parsing position within the 
    input string, it only verifies that the specified parse expression 
    matches prior to the current position.  ``PrecededBy`` always 
    returns a null token list, but if a results name is defined on the 
    given expression, it is returned. 
 
    Parameters: 
 
    - expr - expression that must match prior to the current parse 
      location 
    - retreat - (default= ``None``) - (int) maximum number of characters 
      to lookbehind prior to the current parse location 
 
    If the lookbehind expression is a string, :class:`Literal`, 
    :class:`Keyword`, or a :class:`Word` or :class:`CharsNotIn` 
    with a specified exact or maximum length, then the retreat 
    parameter is not required. Otherwise, retreat must be specified to 
    give a maximum number of characters to look back from 
    the current parse position for a lookbehind match. 
 
    Example:: 
 
        # VB-style variable names with type prefixes 
        int_var = PrecededBy(&quot;#&quot;) + pyparsing_common.identifier 
        str_var = PrecededBy(&quot;$&quot;) + pyparsing_common.identifier 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">expr: Union[ParserElement</span><span class="s2">, </span><span class="s1">str]</span><span class="s2">, </span><span class="s1">retreat: typing.Optional[int] = </span><span class="s2">None</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__(expr)</span>
        <span class="s1">self.expr = self.expr().leave_whitespace()</span>
        <span class="s1">self.mayReturnEmpty = </span><span class="s2">True</span>
        <span class="s1">self.mayIndexError = </span><span class="s2">False</span>
        <span class="s1">self.exact = </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s1">isinstance(expr</span><span class="s2">, </span><span class="s1">str_type):</span>
            <span class="s1">retreat = len(expr)</span>
            <span class="s1">self.exact = </span><span class="s2">True</span>
        <span class="s2">elif </span><span class="s1">isinstance(expr</span><span class="s2">, </span><span class="s1">(Literal</span><span class="s2">, </span><span class="s1">Keyword)):</span>
            <span class="s1">retreat = expr.matchLen</span>
            <span class="s1">self.exact = </span><span class="s2">True</span>
        <span class="s2">elif </span><span class="s1">isinstance(expr</span><span class="s2">, </span><span class="s1">(Word</span><span class="s2">, </span><span class="s1">CharsNotIn)) </span><span class="s2">and </span><span class="s1">expr.maxLen != _MAX_INT:</span>
            <span class="s1">retreat = expr.maxLen</span>
            <span class="s1">self.exact = </span><span class="s2">True</span>
        <span class="s2">elif </span><span class="s1">isinstance(expr</span><span class="s2">, </span><span class="s1">PositionToken):</span>
            <span class="s1">retreat = </span><span class="s3">0</span>
            <span class="s1">self.exact = </span><span class="s2">True</span>
        <span class="s1">self.retreat = retreat</span>
        <span class="s1">self.errmsg = </span><span class="s5">&quot;not preceded by &quot; </span><span class="s1">+ str(expr)</span>
        <span class="s1">self.skipWhitespace = </span><span class="s2">False</span>
        <span class="s1">self.parseAction.append(</span><span class="s2">lambda </span><span class="s1">s</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">t: t.__delitem__(slice(</span><span class="s2">None, None</span><span class="s1">)))</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc=</span><span class="s3">0</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">self.exact:</span>
            <span class="s2">if </span><span class="s1">loc &lt; self.retreat:</span>
                <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">self.errmsg)</span>
            <span class="s1">start = loc - self.retreat</span>
            <span class="s1">_</span><span class="s2">, </span><span class="s1">ret = self.expr._parse(instring</span><span class="s2">, </span><span class="s1">start)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># retreat specified a maximum lookbehind window, iterate</span>
            <span class="s1">test_expr = self.expr + StringEnd()</span>
            <span class="s1">instring_slice = instring[max(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">loc - self.retreat) : loc]</span>
            <span class="s1">last_expr = ParseException(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">self.errmsg)</span>
            <span class="s2">for </span><span class="s1">offset </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">min(loc</span><span class="s2">, </span><span class="s1">self.retreat + </span><span class="s3">1</span><span class="s1">) + </span><span class="s3">1</span><span class="s1">):</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s0"># print('trying', offset, instring_slice, repr(instring_slice[loc - offset:]))</span>
                    <span class="s1">_</span><span class="s2">, </span><span class="s1">ret = test_expr._parse(</span>
                        <span class="s1">instring_slice</span><span class="s2">, </span><span class="s1">len(instring_slice) - offset</span>
                    <span class="s1">)</span>
                <span class="s2">except </span><span class="s1">ParseBaseException </span><span class="s2">as </span><span class="s1">pbe:</span>
                    <span class="s1">last_expr = pbe</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">break</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">last_expr</span>
        <span class="s2">return </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">ret</span>


<span class="s2">class </span><span class="s1">Located(ParseElementEnhance):</span>
    <span class="s4">&quot;&quot;&quot; 
    Decorates a returned token with its starting and ending 
    locations in the input string. 
 
    This helper adds the following results names: 
 
    - ``locn_start`` - location where matched expression begins 
    - ``locn_end`` - location where matched expression ends 
    - ``value`` - the actual parsed results 
 
    Be careful if the input text contains ``&lt;TAB&gt;`` characters, you 
    may want to call :class:`ParserElement.parse_with_tabs` 
 
    Example:: 
 
        wd = Word(alphas) 
        for match in Located(wd).search_string(&quot;ljsdf123lksdjjf123lkkjj1222&quot;): 
            print(match) 
 
    prints:: 
 
        [0, ['ljsdf'], 5] 
        [8, ['lksdjjf'], 15] 
        [18, ['lkkjj'], 23] 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s1">start = loc</span>
        <span class="s1">loc</span><span class="s2">, </span><span class="s1">tokens = self.expr._parse(instring</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">doActions</span><span class="s2">, </span><span class="s1">callPreParse=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">ret_tokens = ParseResults([start</span><span class="s2">, </span><span class="s1">tokens</span><span class="s2">, </span><span class="s1">loc])</span>
        <span class="s1">ret_tokens[</span><span class="s5">&quot;locn_start&quot;</span><span class="s1">] = start</span>
        <span class="s1">ret_tokens[</span><span class="s5">&quot;value&quot;</span><span class="s1">] = tokens</span>
        <span class="s1">ret_tokens[</span><span class="s5">&quot;locn_end&quot;</span><span class="s1">] = loc</span>
        <span class="s2">if </span><span class="s1">self.resultsName:</span>
            <span class="s0"># must return as a list, so that the name will be attached to the complete group</span>
            <span class="s2">return </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">[ret_tokens]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">ret_tokens</span>


<span class="s2">class </span><span class="s1">NotAny(ParseElementEnhance):</span>
    <span class="s4">&quot;&quot;&quot; 
    Lookahead to disallow matching with the given parse expression. 
    ``NotAny`` does *not* advance the parsing position within the 
    input string, it only verifies that the specified parse expression 
    does *not* match at the current position.  Also, ``NotAny`` does 
    *not* skip over leading whitespace. ``NotAny`` always returns 
    a null token list.  May be constructed using the ``'~'`` operator. 
 
    Example:: 
 
        AND, OR, NOT = map(CaselessKeyword, &quot;AND OR NOT&quot;.split()) 
 
        # take care not to mistake keywords for identifiers 
        ident = ~(AND | OR | NOT) + Word(alphas) 
        boolean_term = Opt(NOT) + ident 
 
        # very crude boolean expression - to support parenthesis groups and 
        # operation hierarchy, use infix_notation 
        boolean_expr = boolean_term + ((AND | OR) + boolean_term)[...] 
 
        # integers that are followed by &quot;.&quot; are actually floats 
        integer = Word(nums) + ~Char(&quot;.&quot;) 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">expr: Union[ParserElement</span><span class="s2">, </span><span class="s1">str]):</span>
        <span class="s1">super().__init__(expr)</span>
        <span class="s0"># do NOT use self.leave_whitespace(), don't want to propagate to exprs</span>
        <span class="s0"># self.leave_whitespace()</span>
        <span class="s1">self.skipWhitespace = </span><span class="s2">False</span>

        <span class="s1">self.mayReturnEmpty = </span><span class="s2">True</span>
        <span class="s1">self.errmsg = </span><span class="s5">&quot;Found unwanted token, &quot; </span><span class="s1">+ str(self.expr)</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">self.expr.can_parse_next(instring</span><span class="s2">, </span><span class="s1">loc):</span>
            <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">self.errmsg</span><span class="s2">, </span><span class="s1">self)</span>
        <span class="s2">return </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">_generateDefaultName(self):</span>
        <span class="s2">return </span><span class="s5">&quot;~{&quot; </span><span class="s1">+ str(self.expr) + </span><span class="s5">&quot;}&quot;</span>


<span class="s2">class </span><span class="s1">_MultipleMatch(ParseElementEnhance):</span>
    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">expr: ParserElement</span><span class="s2">,</span>
        <span class="s1">stop_on: typing.Optional[Union[ParserElement</span><span class="s2">, </span><span class="s1">str]] = </span><span class="s2">None,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">stopOn: typing.Optional[Union[ParserElement</span><span class="s2">, </span><span class="s1">str]] = </span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__(expr)</span>
        <span class="s1">stopOn = stopOn </span><span class="s2">or </span><span class="s1">stop_on</span>
        <span class="s1">self.saveAsList = </span><span class="s2">True</span>
        <span class="s1">ender = stopOn</span>
        <span class="s2">if </span><span class="s1">isinstance(ender</span><span class="s2">, </span><span class="s1">str_type):</span>
            <span class="s1">ender = self._literalStringClass(ender)</span>
        <span class="s1">self.stopOn(ender)</span>

    <span class="s2">def </span><span class="s1">stopOn(self</span><span class="s2">, </span><span class="s1">ender) -&gt; ParserElement:</span>
        <span class="s2">if </span><span class="s1">isinstance(ender</span><span class="s2">, </span><span class="s1">str_type):</span>
            <span class="s1">ender = self._literalStringClass(ender)</span>
        <span class="s1">self.not_ender = ~ender </span><span class="s2">if </span><span class="s1">ender </span><span class="s2">is not None else None</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s1">self_expr_parse = self.expr._parse</span>
        <span class="s1">self_skip_ignorables = self._skipIgnorables</span>
        <span class="s1">check_ender = self.not_ender </span><span class="s2">is not None</span>
        <span class="s2">if </span><span class="s1">check_ender:</span>
            <span class="s1">try_not_ender = self.not_ender.tryParse</span>

        <span class="s0"># must be at least one (but first see if we are the stopOn sentinel;</span>
        <span class="s0"># if so, fail)</span>
        <span class="s2">if </span><span class="s1">check_ender:</span>
            <span class="s1">try_not_ender(instring</span><span class="s2">, </span><span class="s1">loc)</span>
        <span class="s1">loc</span><span class="s2">, </span><span class="s1">tokens = self_expr_parse(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">hasIgnoreExprs = </span><span class="s2">not not </span><span class="s1">self.ignoreExprs</span>
            <span class="s2">while </span><span class="s3">1</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">check_ender:</span>
                    <span class="s1">try_not_ender(instring</span><span class="s2">, </span><span class="s1">loc)</span>
                <span class="s2">if </span><span class="s1">hasIgnoreExprs:</span>
                    <span class="s1">preloc = self_skip_ignorables(instring</span><span class="s2">, </span><span class="s1">loc)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">preloc = loc</span>
                <span class="s1">loc</span><span class="s2">, </span><span class="s1">tmptokens = self_expr_parse(instring</span><span class="s2">, </span><span class="s1">preloc</span><span class="s2">, </span><span class="s1">doActions)</span>
                <span class="s2">if </span><span class="s1">tmptokens </span><span class="s2">or </span><span class="s1">tmptokens.haskeys():</span>
                    <span class="s1">tokens += tmptokens</span>
        <span class="s2">except </span><span class="s1">(ParseException</span><span class="s2">, </span><span class="s1">IndexError):</span>
            <span class="s2">pass</span>

        <span class="s2">return </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">tokens</span>

    <span class="s2">def </span><span class="s1">_setResultsName(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">listAllMatches=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">__diag__.warn_ungrouped_named_tokens_in_collection</span>
            <span class="s2">and </span><span class="s1">Diagnostics.warn_ungrouped_named_tokens_in_collection</span>
            <span class="s2">not in </span><span class="s1">self.suppress_warnings_</span>
        <span class="s1">):</span>
            <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">[self.expr] + self.expr.recurse():</span>
                <span class="s2">if </span><span class="s1">(</span>
                    <span class="s1">isinstance(e</span><span class="s2">, </span><span class="s1">ParserElement)</span>
                    <span class="s2">and </span><span class="s1">e.resultsName</span>
                    <span class="s2">and </span><span class="s1">Diagnostics.warn_ungrouped_named_tokens_in_collection</span>
                    <span class="s2">not in </span><span class="s1">e.suppress_warnings_</span>
                <span class="s1">):</span>
                    <span class="s1">warnings.warn(</span>
                        <span class="s5">&quot;{}: setting results name {!r} on {} expression &quot;</span>
                        <span class="s5">&quot;collides with {!r} on contained expression&quot;</span><span class="s1">.format(</span>
                            <span class="s5">&quot;warn_ungrouped_named_tokens_in_collection&quot;</span><span class="s2">,</span>
                            <span class="s1">name</span><span class="s2">,</span>
                            <span class="s1">type(self).__name__</span><span class="s2">,</span>
                            <span class="s1">e.resultsName</span><span class="s2">,</span>
                        <span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">stacklevel=</span><span class="s3">3</span><span class="s2">,</span>
                    <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">super()._setResultsName(name</span><span class="s2">, </span><span class="s1">listAllMatches)</span>


<span class="s2">class </span><span class="s1">OneOrMore(_MultipleMatch):</span>
    <span class="s4">&quot;&quot;&quot; 
    Repetition of one or more of the given expression. 
 
    Parameters: 
    - expr - expression that must match one or more times 
    - stop_on - (default= ``None``) - expression for a terminating sentinel 
         (only required if the sentinel would ordinarily match the repetition 
         expression) 
 
    Example:: 
 
        data_word = Word(alphas) 
        label = data_word + FollowedBy(':') 
        attr_expr = Group(label + Suppress(':') + OneOrMore(data_word).set_parse_action(' '.join)) 
 
        text = &quot;shape: SQUARE posn: upper left color: BLACK&quot; 
        attr_expr[1, ...].parse_string(text).pprint()  # Fail! read 'color' as data instead of next label -&gt; [['shape', 'SQUARE color']] 
 
        # use stop_on attribute for OneOrMore to avoid reading label string as part of the data 
        attr_expr = Group(label + Suppress(':') + OneOrMore(data_word, stop_on=label).set_parse_action(' '.join)) 
        OneOrMore(attr_expr).parse_string(text).pprint() # Better -&gt; [['shape', 'SQUARE'], ['posn', 'upper left'], ['color', 'BLACK']] 
 
        # could also be written as 
        (attr_expr * (1,)).parse_string(text).pprint() 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_generateDefaultName(self):</span>
        <span class="s2">return </span><span class="s5">&quot;{&quot; </span><span class="s1">+ str(self.expr) + </span><span class="s5">&quot;}...&quot;</span>


<span class="s2">class </span><span class="s1">ZeroOrMore(_MultipleMatch):</span>
    <span class="s4">&quot;&quot;&quot; 
    Optional repetition of zero or more of the given expression. 
 
    Parameters: 
    - ``expr`` - expression that must match zero or more times 
    - ``stop_on`` - expression for a terminating sentinel 
      (only required if the sentinel would ordinarily match the repetition 
      expression) - (default= ``None``) 
 
    Example: similar to :class:`OneOrMore` 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">expr: ParserElement</span><span class="s2">,</span>
        <span class="s1">stop_on: typing.Optional[Union[ParserElement</span><span class="s2">, </span><span class="s1">str]] = </span><span class="s2">None,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">stopOn: typing.Optional[Union[ParserElement</span><span class="s2">, </span><span class="s1">str]] = </span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__(expr</span><span class="s2">, </span><span class="s1">stopOn=stopOn </span><span class="s2">or </span><span class="s1">stop_on)</span>
        <span class="s1">self.mayReturnEmpty = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">super().parseImpl(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions)</span>
        <span class="s2">except </span><span class="s1">(ParseException</span><span class="s2">, </span><span class="s1">IndexError):</span>
            <span class="s2">return </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">ParseResults([]</span><span class="s2">, </span><span class="s1">name=self.resultsName)</span>

    <span class="s2">def </span><span class="s1">_generateDefaultName(self):</span>
        <span class="s2">return </span><span class="s5">&quot;[&quot; </span><span class="s1">+ str(self.expr) + </span><span class="s5">&quot;]...&quot;</span>


<span class="s2">class </span><span class="s1">_NullToken:</span>
    <span class="s2">def </span><span class="s1">__bool__(self):</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s5">&quot;&quot;</span>


<span class="s2">class </span><span class="s1">Opt(ParseElementEnhance):</span>
    <span class="s4">&quot;&quot;&quot; 
    Optional matching of the given expression. 
 
    Parameters: 
    - ``expr`` - expression that must match zero or more times 
    - ``default`` (optional) - value to be returned if the optional expression is not found. 
 
    Example:: 
 
        # US postal code can be a 5-digit zip, plus optional 4-digit qualifier 
        zip = Combine(Word(nums, exact=5) + Opt('-' + Word(nums, exact=4))) 
        zip.run_tests(''' 
            # traditional ZIP code 
            12345 
 
            # ZIP+4 form 
            12101-0001 
 
            # invalid ZIP 
            98765- 
            ''') 
 
    prints:: 
 
        # traditional ZIP code 
        12345 
        ['12345'] 
 
        # ZIP+4 form 
        12101-0001 
        ['12101-0001'] 
 
        # invalid ZIP 
        98765- 
             ^ 
        FAIL: Expected end of text (at char 5), (line:1, col:6) 
    &quot;&quot;&quot;</span>

    <span class="s1">__optionalNotMatched = _NullToken()</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">expr: Union[ParserElement</span><span class="s2">, </span><span class="s1">str]</span><span class="s2">, </span><span class="s1">default: Any = __optionalNotMatched</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__(expr</span><span class="s2">, </span><span class="s1">savelist=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">self.saveAsList = self.expr.saveAsList</span>
        <span class="s1">self.defaultValue = default</span>
        <span class="s1">self.mayReturnEmpty = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s1">self_expr = self.expr</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">loc</span><span class="s2">, </span><span class="s1">tokens = self_expr._parse(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions</span><span class="s2">, </span><span class="s1">callPreParse=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">(ParseException</span><span class="s2">, </span><span class="s1">IndexError):</span>
            <span class="s1">default_value = self.defaultValue</span>
            <span class="s2">if </span><span class="s1">default_value </span><span class="s2">is not </span><span class="s1">self.__optionalNotMatched:</span>
                <span class="s2">if </span><span class="s1">self_expr.resultsName:</span>
                    <span class="s1">tokens = ParseResults([default_value])</span>
                    <span class="s1">tokens[self_expr.resultsName] = default_value</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">tokens = [default_value]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">tokens = []</span>
        <span class="s2">return </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">tokens</span>

    <span class="s2">def </span><span class="s1">_generateDefaultName(self):</span>
        <span class="s1">inner = str(self.expr)</span>
        <span class="s0"># strip off redundant inner {}'s</span>
        <span class="s2">while </span><span class="s1">len(inner) &gt; </span><span class="s3">1 </span><span class="s2">and </span><span class="s1">inner[</span><span class="s3">0 </span><span class="s1">:: len(inner) - </span><span class="s3">1</span><span class="s1">] == </span><span class="s5">&quot;{}&quot;</span><span class="s1">:</span>
            <span class="s1">inner = inner[</span><span class="s3">1</span><span class="s1">:-</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s5">&quot;[&quot; </span><span class="s1">+ inner + </span><span class="s5">&quot;]&quot;</span>


<span class="s1">Optional = Opt</span>


<span class="s2">class </span><span class="s1">SkipTo(ParseElementEnhance):</span>
    <span class="s4">&quot;&quot;&quot; 
    Token for skipping over all undefined text until the matched 
    expression is found. 
 
    Parameters: 
    - ``expr`` - target expression marking the end of the data to be skipped 
    - ``include`` - if ``True``, the target expression is also parsed 
      (the skipped text and target expression are returned as a 2-element 
      list) (default= ``False``). 
    - ``ignore`` - (default= ``None``) used to define grammars (typically quoted strings and 
      comments) that might contain false matches to the target expression 
    - ``fail_on`` - (default= ``None``) define expressions that are not allowed to be 
      included in the skipped test; if found before the target expression is found, 
      the :class:`SkipTo` is not a match 
 
    Example:: 
 
        report = ''' 
            Outstanding Issues Report - 1 Jan 2000 
 
               # | Severity | Description                               |  Days Open 
            -----+----------+-------------------------------------------+----------- 
             101 | Critical | Intermittent system crash                 |          6 
              94 | Cosmetic | Spelling error on Login ('log|n')         |         14 
              79 | Minor    | System slow when running too many reports |         47 
            ''' 
        integer = Word(nums) 
        SEP = Suppress('|') 
        # use SkipTo to simply match everything up until the next SEP 
        # - ignore quoted strings, so that a '|' character inside a quoted string does not match 
        # - parse action will call token.strip() for each matched token, i.e., the description body 
        string_data = SkipTo(SEP, ignore=quoted_string) 
        string_data.set_parse_action(token_map(str.strip)) 
        ticket_expr = (integer(&quot;issue_num&quot;) + SEP 
                      + string_data(&quot;sev&quot;) + SEP 
                      + string_data(&quot;desc&quot;) + SEP 
                      + integer(&quot;days_open&quot;)) 
 
        for tkt in ticket_expr.search_string(report): 
            print tkt.dump() 
 
    prints:: 
 
        ['101', 'Critical', 'Intermittent system crash', '6'] 
        - days_open: '6' 
        - desc: 'Intermittent system crash' 
        - issue_num: '101' 
        - sev: 'Critical' 
        ['94', 'Cosmetic', &quot;Spelling error on Login ('log|n')&quot;, '14'] 
        - days_open: '14' 
        - desc: &quot;Spelling error on Login ('log|n')&quot; 
        - issue_num: '94' 
        - sev: 'Cosmetic' 
        ['79', 'Minor', 'System slow when running too many reports', '47'] 
        - days_open: '47' 
        - desc: 'System slow when running too many reports' 
        - issue_num: '79' 
        - sev: 'Minor' 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">other: Union[ParserElement</span><span class="s2">, </span><span class="s1">str]</span><span class="s2">,</span>
        <span class="s1">include: bool = </span><span class="s2">False,</span>
        <span class="s1">ignore: bool = </span><span class="s2">None,</span>
        <span class="s1">fail_on: typing.Optional[Union[ParserElement</span><span class="s2">, </span><span class="s1">str]] = </span><span class="s2">None,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">failOn: Union[ParserElement</span><span class="s2">, </span><span class="s1">str] = </span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__(other)</span>
        <span class="s1">failOn = failOn </span><span class="s2">or </span><span class="s1">fail_on</span>
        <span class="s1">self.ignoreExpr = ignore</span>
        <span class="s1">self.mayReturnEmpty = </span><span class="s2">True</span>
        <span class="s1">self.mayIndexError = </span><span class="s2">False</span>
        <span class="s1">self.includeMatch = include</span>
        <span class="s1">self.saveAsList = </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s1">isinstance(failOn</span><span class="s2">, </span><span class="s1">str_type):</span>
            <span class="s1">self.failOn = self._literalStringClass(failOn)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.failOn = failOn</span>
        <span class="s1">self.errmsg = </span><span class="s5">&quot;No match found for &quot; </span><span class="s1">+ str(self.expr)</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s1">startloc = loc</span>
        <span class="s1">instrlen = len(instring)</span>
        <span class="s1">self_expr_parse = self.expr._parse</span>
        <span class="s1">self_failOn_canParseNext = (</span>
            <span class="s1">self.failOn.canParseNext </span><span class="s2">if </span><span class="s1">self.failOn </span><span class="s2">is not None else None</span>
        <span class="s1">)</span>
        <span class="s1">self_ignoreExpr_tryParse = (</span>
            <span class="s1">self.ignoreExpr.tryParse </span><span class="s2">if </span><span class="s1">self.ignoreExpr </span><span class="s2">is not None else None</span>
        <span class="s1">)</span>

        <span class="s1">tmploc = loc</span>
        <span class="s2">while </span><span class="s1">tmploc &lt;= instrlen:</span>
            <span class="s2">if </span><span class="s1">self_failOn_canParseNext </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s0"># break if failOn expression matches</span>
                <span class="s2">if </span><span class="s1">self_failOn_canParseNext(instring</span><span class="s2">, </span><span class="s1">tmploc):</span>
                    <span class="s2">break</span>

            <span class="s2">if </span><span class="s1">self_ignoreExpr_tryParse </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s0"># advance past ignore expressions</span>
                <span class="s2">while </span><span class="s3">1</span><span class="s1">:</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s1">tmploc = self_ignoreExpr_tryParse(instring</span><span class="s2">, </span><span class="s1">tmploc)</span>
                    <span class="s2">except </span><span class="s1">ParseBaseException:</span>
                        <span class="s2">break</span>

            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">self_expr_parse(instring</span><span class="s2">, </span><span class="s1">tmploc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">False, </span><span class="s1">callPreParse=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s2">except </span><span class="s1">(ParseException</span><span class="s2">, </span><span class="s1">IndexError):</span>
                <span class="s0"># no match, advance loc in string</span>
                <span class="s1">tmploc += </span><span class="s3">1</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s0"># matched skipto expr, done</span>
                <span class="s2">break</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># ran off the end of the input string without matching skipto expr, fail</span>
            <span class="s2">raise </span><span class="s1">ParseException(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">self.errmsg</span><span class="s2">, </span><span class="s1">self)</span>

        <span class="s0"># build up return values</span>
        <span class="s1">loc = tmploc</span>
        <span class="s1">skiptext = instring[startloc:loc]</span>
        <span class="s1">skipresult = ParseResults(skiptext)</span>

        <span class="s2">if </span><span class="s1">self.includeMatch:</span>
            <span class="s1">loc</span><span class="s2">, </span><span class="s1">mat = self_expr_parse(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions</span><span class="s2">, </span><span class="s1">callPreParse=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s1">skipresult += mat</span>

        <span class="s2">return </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">skipresult</span>


<span class="s2">class </span><span class="s1">Forward(ParseElementEnhance):</span>
    <span class="s4">&quot;&quot;&quot; 
    Forward declaration of an expression to be defined later - 
    used for recursive grammars, such as algebraic infix notation. 
    When the expression is known, it is assigned to the ``Forward`` 
    variable using the ``'&lt;&lt;'`` operator. 
 
    Note: take care when assigning to ``Forward`` not to overlook 
    precedence of operators. 
 
    Specifically, ``'|'`` has a lower precedence than ``'&lt;&lt;'``, so that:: 
 
        fwd_expr &lt;&lt; a | b | c 
 
    will actually be evaluated as:: 
 
        (fwd_expr &lt;&lt; a) | b | c 
 
    thereby leaving b and c out as parseable alternatives.  It is recommended that you 
    explicitly group the values inserted into the ``Forward``:: 
 
        fwd_expr &lt;&lt; (a | b | c) 
 
    Converting to use the ``'&lt;&lt;='`` operator instead will avoid this problem. 
 
    See :class:`ParseResults.pprint` for an example of a recursive 
    parser created using ``Forward``. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">other: typing.Optional[Union[ParserElement</span><span class="s2">, </span><span class="s1">str]] = </span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self.caller_frame = traceback.extract_stack(limit=</span><span class="s3">2</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">super().__init__(other</span><span class="s2">, </span><span class="s1">savelist=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">self.lshift_line = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__lshift__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s5">&quot;caller_frame&quot;</span><span class="s1">):</span>
            <span class="s2">del </span><span class="s1">self.caller_frame</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">str_type):</span>
            <span class="s1">other = self._literalStringClass(other)</span>
        <span class="s1">self.expr = other</span>
        <span class="s1">self.mayIndexError = self.expr.mayIndexError</span>
        <span class="s1">self.mayReturnEmpty = self.expr.mayReturnEmpty</span>
        <span class="s1">self.set_whitespace_chars(</span>
            <span class="s1">self.expr.whiteChars</span><span class="s2">, </span><span class="s1">copy_defaults=self.expr.copyDefaultWhiteChars</span>
        <span class="s1">)</span>
        <span class="s1">self.skipWhitespace = self.expr.skipWhitespace</span>
        <span class="s1">self.saveAsList = self.expr.saveAsList</span>
        <span class="s1">self.ignoreExprs.extend(self.expr.ignoreExprs)</span>
        <span class="s1">self.lshift_line = traceback.extract_stack(limit=</span><span class="s3">2</span><span class="s1">)[-</span><span class="s3">2</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__ilshift__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self &lt;&lt; other</span>

    <span class="s2">def </span><span class="s1">__or__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s1">caller_line = traceback.extract_stack(limit=</span><span class="s3">2</span><span class="s1">)[-</span><span class="s3">2</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">__diag__.warn_on_match_first_with_lshift_operator</span>
            <span class="s2">and </span><span class="s1">caller_line == self.lshift_line</span>
            <span class="s2">and </span><span class="s1">Diagnostics.warn_on_match_first_with_lshift_operator</span>
            <span class="s2">not in </span><span class="s1">self.suppress_warnings_</span>
        <span class="s1">):</span>
            <span class="s1">warnings.warn(</span>
                <span class="s5">&quot;using '&lt;&lt;' operator with '|' is probably an error, use '&lt;&lt;='&quot;</span><span class="s2">,</span>
                <span class="s1">stacklevel=</span><span class="s3">2</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s1">ret = super().__or__(other)</span>
        <span class="s2">return </span><span class="s1">ret</span>

    <span class="s2">def </span><span class="s1">__del__(self):</span>
        <span class="s0"># see if we are getting dropped because of '=' reassignment of var instead of '&lt;&lt;=' or '&lt;&lt;'</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">self.expr </span><span class="s2">is None</span>
            <span class="s2">and </span><span class="s1">__diag__.warn_on_assignment_to_Forward</span>
            <span class="s2">and </span><span class="s1">Diagnostics.warn_on_assignment_to_Forward </span><span class="s2">not in </span><span class="s1">self.suppress_warnings_</span>
        <span class="s1">):</span>
            <span class="s1">warnings.warn_explicit(</span>
                <span class="s5">&quot;Forward defined here but no expression attached later using '&lt;&lt;=' or '&lt;&lt;'&quot;</span><span class="s2">,</span>
                <span class="s1">UserWarning</span><span class="s2">,</span>
                <span class="s1">filename=self.caller_frame.filename</span><span class="s2">,</span>
                <span class="s1">lineno=self.caller_frame.lineno</span><span class="s2">,</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">self.expr </span><span class="s2">is None</span>
            <span class="s2">and </span><span class="s1">__diag__.warn_on_parse_using_empty_Forward</span>
            <span class="s2">and </span><span class="s1">Diagnostics.warn_on_parse_using_empty_Forward</span>
            <span class="s2">not in </span><span class="s1">self.suppress_warnings_</span>
        <span class="s1">):</span>
            <span class="s0"># walk stack until parse_string, scan_string, search_string, or transform_string is found</span>
            <span class="s1">parse_fns = [</span>
                <span class="s5">&quot;parse_string&quot;</span><span class="s2">,</span>
                <span class="s5">&quot;scan_string&quot;</span><span class="s2">,</span>
                <span class="s5">&quot;search_string&quot;</span><span class="s2">,</span>
                <span class="s5">&quot;transform_string&quot;</span><span class="s2">,</span>
            <span class="s1">]</span>
            <span class="s1">tb = traceback.extract_stack(limit=</span><span class="s3">200</span><span class="s1">)</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">frm </span><span class="s2">in </span><span class="s1">enumerate(reversed(tb)</span><span class="s2">, </span><span class="s1">start=</span><span class="s3">1</span><span class="s1">):</span>
                <span class="s2">if </span><span class="s1">frm.name </span><span class="s2">in </span><span class="s1">parse_fns:</span>
                    <span class="s1">stacklevel = i + </span><span class="s3">1</span>
                    <span class="s2">break</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">stacklevel = </span><span class="s3">2</span>
            <span class="s1">warnings.warn(</span>
                <span class="s5">&quot;Forward expression was never assigned a value, will not parse any input&quot;</span><span class="s2">,</span>
                <span class="s1">stacklevel=stacklevel</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">ParserElement._left_recursion_enabled:</span>
            <span class="s2">return </span><span class="s1">super().parseImpl(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions)</span>
        <span class="s0"># ## Bounded Recursion algorithm ##</span>
        <span class="s0"># Recursion only needs to be processed at ``Forward`` elements, since they are</span>
        <span class="s0"># the only ones that can actually refer to themselves. The general idea is</span>
        <span class="s0"># to handle recursion stepwise: We start at no recursion, then recurse once,</span>
        <span class="s0"># recurse twice, ..., until more recursion offers no benefit (we hit the bound).</span>
        <span class="s0">#</span>
        <span class="s0"># The &quot;trick&quot; here is that each ``Forward`` gets evaluated in two contexts</span>
        <span class="s0"># - to *match* a specific recursion level, and</span>
        <span class="s0"># - to *search* the bounded recursion level</span>
        <span class="s0"># and the two run concurrently. The *search* must *match* each recursion level</span>
        <span class="s0"># to find the best possible match. This is handled by a memo table, which</span>
        <span class="s0"># provides the previous match to the next level match attempt.</span>
        <span class="s0">#</span>
        <span class="s0"># See also &quot;Left Recursion in Parsing Expression Grammars&quot;, Medeiros et al.</span>
        <span class="s0">#</span>
        <span class="s0"># There is a complication since we not only *parse* but also *transform* via</span>
        <span class="s0"># actions: We do not want to run the actions too often while expanding. Thus,</span>
        <span class="s0"># we expand using `doActions=False` and only run `doActions=True` if the next</span>
        <span class="s0"># recursion level is acceptable.</span>
        <span class="s2">with </span><span class="s1">ParserElement.recursion_lock:</span>
            <span class="s1">memo = ParserElement.recursion_memos</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s0"># we are parsing at a specific recursion expansion - use it as-is</span>
                <span class="s1">prev_loc</span><span class="s2">, </span><span class="s1">prev_result = memo[loc</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">doActions]</span>
                <span class="s2">if </span><span class="s1">isinstance(prev_result</span><span class="s2">, </span><span class="s1">Exception):</span>
                    <span class="s2">raise </span><span class="s1">prev_result</span>
                <span class="s2">return </span><span class="s1">prev_loc</span><span class="s2">, </span><span class="s1">prev_result.copy()</span>
            <span class="s2">except </span><span class="s1">KeyError:</span>
                <span class="s1">act_key = (loc</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, True</span><span class="s1">)</span>
                <span class="s1">peek_key = (loc</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, False</span><span class="s1">)</span>
                <span class="s0"># we are searching for the best recursion expansion - keep on improving</span>
                <span class="s0"># both `doActions` cases must be tracked separately here!</span>
                <span class="s1">prev_loc</span><span class="s2">, </span><span class="s1">prev_peek = memo[peek_key] = (</span>
                    <span class="s1">loc - </span><span class="s3">1</span><span class="s2">,</span>
                    <span class="s1">ParseException(</span>
                        <span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s5">&quot;Forward recursion without base case&quot;</span><span class="s2">, </span><span class="s1">self</span>
                    <span class="s1">)</span><span class="s2">,</span>
                <span class="s1">)</span>
                <span class="s2">if </span><span class="s1">doActions:</span>
                    <span class="s1">memo[act_key] = memo[peek_key]</span>
                <span class="s2">while True</span><span class="s1">:</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s1">new_loc</span><span class="s2">, </span><span class="s1">new_peek = super().parseImpl(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, False</span><span class="s1">)</span>
                    <span class="s2">except </span><span class="s1">ParseException:</span>
                        <span class="s0"># we failed before getting any match  do not hide the error</span>
                        <span class="s2">if </span><span class="s1">isinstance(prev_peek</span><span class="s2">, </span><span class="s1">Exception):</span>
                            <span class="s2">raise</span>
                        <span class="s1">new_loc</span><span class="s2">, </span><span class="s1">new_peek = prev_loc</span><span class="s2">, </span><span class="s1">prev_peek</span>
                    <span class="s0"># the match did not get better: we are done</span>
                    <span class="s2">if </span><span class="s1">new_loc &lt;= prev_loc:</span>
                        <span class="s2">if </span><span class="s1">doActions:</span>
                            <span class="s0"># replace the match for doActions=False as well,</span>
                            <span class="s0"># in case the action did backtrack</span>
                            <span class="s1">prev_loc</span><span class="s2">, </span><span class="s1">prev_result = memo[peek_key] = memo[act_key]</span>
                            <span class="s2">del </span><span class="s1">memo[peek_key]</span><span class="s2">, </span><span class="s1">memo[act_key]</span>
                            <span class="s2">return </span><span class="s1">prev_loc</span><span class="s2">, </span><span class="s1">prev_result.copy()</span>
                        <span class="s2">del </span><span class="s1">memo[peek_key]</span>
                        <span class="s2">return </span><span class="s1">prev_loc</span><span class="s2">, </span><span class="s1">prev_peek.copy()</span>
                    <span class="s0"># the match did get better: see if we can improve further</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s2">if </span><span class="s1">doActions:</span>
                            <span class="s2">try</span><span class="s1">:</span>
                                <span class="s1">memo[act_key] = super().parseImpl(instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, True</span><span class="s1">)</span>
                            <span class="s2">except </span><span class="s1">ParseException </span><span class="s2">as </span><span class="s1">e:</span>
                                <span class="s1">memo[peek_key] = memo[act_key] = (new_loc</span><span class="s2">, </span><span class="s1">e)</span>
                                <span class="s2">raise</span>
                        <span class="s1">prev_loc</span><span class="s2">, </span><span class="s1">prev_peek = memo[peek_key] = new_loc</span><span class="s2">, </span><span class="s1">new_peek</span>

    <span class="s2">def </span><span class="s1">leave_whitespace(self</span><span class="s2">, </span><span class="s1">recursive: bool = </span><span class="s2">True</span><span class="s1">) -&gt; ParserElement:</span>
        <span class="s1">self.skipWhitespace = </span><span class="s2">False</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">ignore_whitespace(self</span><span class="s2">, </span><span class="s1">recursive: bool = </span><span class="s2">True</span><span class="s1">) -&gt; ParserElement:</span>
        <span class="s1">self.skipWhitespace = </span><span class="s2">True</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">streamline(self) -&gt; ParserElement:</span>
        <span class="s2">if not </span><span class="s1">self.streamlined:</span>
            <span class="s1">self.streamlined = </span><span class="s2">True</span>
            <span class="s2">if </span><span class="s1">self.expr </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">self.expr.streamline()</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">validate(self</span><span class="s2">, </span><span class="s1">validateTrace=</span><span class="s2">None</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">validateTrace </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">validateTrace = []</span>

        <span class="s2">if </span><span class="s1">self </span><span class="s2">not in </span><span class="s1">validateTrace:</span>
            <span class="s1">tmp = validateTrace[:] + [self]</span>
            <span class="s2">if </span><span class="s1">self.expr </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">self.expr.validate(tmp)</span>
        <span class="s1">self._checkRecursion([])</span>

    <span class="s2">def </span><span class="s1">_generateDefaultName(self):</span>
        <span class="s0"># Avoid infinite recursion by setting a temporary _defaultName</span>
        <span class="s1">self._defaultName = </span><span class="s5">&quot;: ...&quot;</span>

        <span class="s0"># Use the string representation of main expression.</span>
        <span class="s1">retString = </span><span class="s5">&quot;...&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.expr </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">retString = str(self.expr)[:</span><span class="s3">1000</span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">retString = </span><span class="s5">&quot;None&quot;</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.__class__.__name__ + </span><span class="s5">&quot;: &quot; </span><span class="s1">+ retString</span>

    <span class="s2">def </span><span class="s1">copy(self) -&gt; ParserElement:</span>
        <span class="s2">if </span><span class="s1">self.expr </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">super().copy()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">ret = Forward()</span>
            <span class="s1">ret &lt;&lt;= self</span>
            <span class="s2">return </span><span class="s1">ret</span>

    <span class="s2">def </span><span class="s1">_setResultsName(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">list_all_matches=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">__diag__.warn_name_set_on_empty_Forward</span>
            <span class="s2">and </span><span class="s1">Diagnostics.warn_name_set_on_empty_Forward</span>
            <span class="s2">not in </span><span class="s1">self.suppress_warnings_</span>
        <span class="s1">):</span>
            <span class="s2">if </span><span class="s1">self.expr </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">warnings.warn(</span>
                    <span class="s5">&quot;{}: setting results name {!r} on {} expression &quot;</span>
                    <span class="s5">&quot;that has no contained expression&quot;</span><span class="s1">.format(</span>
                        <span class="s5">&quot;warn_name_set_on_empty_Forward&quot;</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">type(self).__name__</span>
                    <span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">stacklevel=</span><span class="s3">3</span><span class="s2">,</span>
                <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">super()._setResultsName(name</span><span class="s2">, </span><span class="s1">list_all_matches)</span>

    <span class="s1">ignoreWhitespace = ignore_whitespace</span>
    <span class="s1">leaveWhitespace = leave_whitespace</span>


<span class="s2">class </span><span class="s1">TokenConverter(ParseElementEnhance):</span>
    <span class="s4">&quot;&quot;&quot; 
    Abstract subclass of :class:`ParseExpression`, for converting parsed results. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">expr: Union[ParserElement</span><span class="s2">, </span><span class="s1">str]</span><span class="s2">, </span><span class="s1">savelist=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">super().__init__(expr)  </span><span class="s0"># , savelist)</span>
        <span class="s1">self.saveAsList = </span><span class="s2">False</span>


<span class="s2">class </span><span class="s1">Combine(TokenConverter):</span>
    <span class="s4">&quot;&quot;&quot;Converter to concatenate all matching tokens to a single string. 
    By default, the matching patterns must also be contiguous in the 
    input string; this can be disabled by specifying 
    ``'adjacent=False'`` in the constructor. 
 
    Example:: 
 
        real = Word(nums) + '.' + Word(nums) 
        print(real.parse_string('3.1416')) # -&gt; ['3', '.', '1416'] 
        # will also erroneously match the following 
        print(real.parse_string('3. 1416')) # -&gt; ['3', '.', '1416'] 
 
        real = Combine(Word(nums) + '.' + Word(nums)) 
        print(real.parse_string('3.1416')) # -&gt; ['3.1416'] 
        # no match when there are internal spaces 
        print(real.parse_string('3. 1416')) # -&gt; Exception: Expected W:(0123...) 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">expr: ParserElement</span><span class="s2">,</span>
        <span class="s1">join_string: str = </span><span class="s5">&quot;&quot;</span><span class="s2">,</span>
        <span class="s1">adjacent: bool = </span><span class="s2">True,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">joinString: typing.Optional[str] = </span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__(expr)</span>
        <span class="s1">joinString = joinString </span><span class="s2">if </span><span class="s1">joinString </span><span class="s2">is not None else </span><span class="s1">join_string</span>
        <span class="s0"># suppress whitespace-stripping in contained parse expressions, but re-enable it on the Combine itself</span>
        <span class="s2">if </span><span class="s1">adjacent:</span>
            <span class="s1">self.leave_whitespace()</span>
        <span class="s1">self.adjacent = adjacent</span>
        <span class="s1">self.skipWhitespace = </span><span class="s2">True</span>
        <span class="s1">self.joinString = joinString</span>
        <span class="s1">self.callPreparse = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">ignore(self</span><span class="s2">, </span><span class="s1">other) -&gt; ParserElement:</span>
        <span class="s2">if </span><span class="s1">self.adjacent:</span>
            <span class="s1">ParserElement.ignore(self</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">super().ignore(other)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">postParse(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">tokenlist):</span>
        <span class="s1">retToks = tokenlist.copy()</span>
        <span class="s2">del </span><span class="s1">retToks[:]</span>
        <span class="s1">retToks += ParseResults(</span>
            <span class="s1">[</span><span class="s5">&quot;&quot;</span><span class="s1">.join(tokenlist._asStringList(self.joinString))]</span><span class="s2">, </span><span class="s1">modal=self.modalResults</span>
        <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self.resultsName </span><span class="s2">and </span><span class="s1">retToks.haskeys():</span>
            <span class="s2">return </span><span class="s1">[retToks]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">retToks</span>


<span class="s2">class </span><span class="s1">Group(TokenConverter):</span>
    <span class="s4">&quot;&quot;&quot;Converter to return the matched tokens as a list - useful for 
    returning tokens of :class:`ZeroOrMore` and :class:`OneOrMore` expressions. 
 
    The optional ``aslist`` argument when set to True will return the 
    parsed tokens as a Python list instead of a pyparsing ParseResults. 
 
    Example:: 
 
        ident = Word(alphas) 
        num = Word(nums) 
        term = ident | num 
        func = ident + Opt(delimited_list(term)) 
        print(func.parse_string(&quot;fn a, b, 100&quot;)) 
        # -&gt; ['fn', 'a', 'b', '100'] 
 
        func = ident + Group(Opt(delimited_list(term))) 
        print(func.parse_string(&quot;fn a, b, 100&quot;)) 
        # -&gt; ['fn', ['a', 'b', '100']] 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">expr: ParserElement</span><span class="s2">, </span><span class="s1">aslist: bool = </span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">super().__init__(expr)</span>
        <span class="s1">self.saveAsList = </span><span class="s2">True</span>
        <span class="s1">self._asPythonList = aslist</span>

    <span class="s2">def </span><span class="s1">postParse(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">tokenlist):</span>
        <span class="s2">if </span><span class="s1">self._asPythonList:</span>
            <span class="s2">return </span><span class="s1">ParseResults.List(</span>
                <span class="s1">tokenlist.asList()</span>
                <span class="s2">if </span><span class="s1">isinstance(tokenlist</span><span class="s2">, </span><span class="s1">ParseResults)</span>
                <span class="s2">else </span><span class="s1">list(tokenlist)</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[tokenlist]</span>


<span class="s2">class </span><span class="s1">Dict(TokenConverter):</span>
    <span class="s4">&quot;&quot;&quot;Converter to return a repetitive expression as a list, but also 
    as a dictionary. Each element can also be referenced using the first 
    token in the expression as its key. Useful for tabular report 
    scraping when the first column can be used as a item key. 
 
    The optional ``asdict`` argument when set to True will return the 
    parsed tokens as a Python dict instead of a pyparsing ParseResults. 
 
    Example:: 
 
        data_word = Word(alphas) 
        label = data_word + FollowedBy(':') 
 
        text = &quot;shape: SQUARE posn: upper left color: light blue texture: burlap&quot; 
        attr_expr = (label + Suppress(':') + OneOrMore(data_word, stop_on=label).set_parse_action(' '.join)) 
 
        # print attributes as plain groups 
        print(attr_expr[1, ...].parse_string(text).dump()) 
 
        # instead of OneOrMore(expr), parse using Dict(Group(expr)[1, ...]) - Dict will auto-assign names 
        result = Dict(Group(attr_expr)[1, ...]).parse_string(text) 
        print(result.dump()) 
 
        # access named fields as dict entries, or output as dict 
        print(result['shape']) 
        print(result.as_dict()) 
 
    prints:: 
 
        ['shape', 'SQUARE', 'posn', 'upper left', 'color', 'light blue', 'texture', 'burlap'] 
        [['shape', 'SQUARE'], ['posn', 'upper left'], ['color', 'light blue'], ['texture', 'burlap']] 
        - color: 'light blue' 
        - posn: 'upper left' 
        - shape: 'SQUARE' 
        - texture: 'burlap' 
        SQUARE 
        {'color': 'light blue', 'posn': 'upper left', 'texture': 'burlap', 'shape': 'SQUARE'} 
 
    See more examples at :class:`ParseResults` of accessing fields by results name. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">expr: ParserElement</span><span class="s2">, </span><span class="s1">asdict: bool = </span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">super().__init__(expr)</span>
        <span class="s1">self.saveAsList = </span><span class="s2">True</span>
        <span class="s1">self._asPythonDict = asdict</span>

    <span class="s2">def </span><span class="s1">postParse(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">tokenlist):</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">tok </span><span class="s2">in </span><span class="s1">enumerate(tokenlist):</span>
            <span class="s2">if </span><span class="s1">len(tok) == </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s2">continue</span>

            <span class="s1">ikey = tok[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">isinstance(ikey</span><span class="s2">, </span><span class="s1">int):</span>
                <span class="s1">ikey = str(ikey).strip()</span>

            <span class="s2">if </span><span class="s1">len(tok) == </span><span class="s3">1</span><span class="s1">:</span>
                <span class="s1">tokenlist[ikey] = _ParseResultsWithOffset(</span><span class="s5">&quot;&quot;</span><span class="s2">, </span><span class="s1">i)</span>

            <span class="s2">elif </span><span class="s1">len(tok) == </span><span class="s3">2 </span><span class="s2">and not </span><span class="s1">isinstance(tok[</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ParseResults):</span>
                <span class="s1">tokenlist[ikey] = _ParseResultsWithOffset(tok[</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">i)</span>

            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">dictvalue = tok.copy()  </span><span class="s0"># ParseResults(i)</span>
                <span class="s2">except </span><span class="s1">Exception:</span>
                    <span class="s1">exc = TypeError(</span>
                        <span class="s5">&quot;could not extract dict values from parsed results&quot;</span>
                        <span class="s5">&quot; - Dict expression must contain Grouped expressions&quot;</span>
                    <span class="s1">)</span>
                    <span class="s2">raise </span><span class="s1">exc </span><span class="s2">from None</span>

                <span class="s2">del </span><span class="s1">dictvalue[</span><span class="s3">0</span><span class="s1">]</span>

                <span class="s2">if </span><span class="s1">len(dictvalue) != </span><span class="s3">1 </span><span class="s2">or </span><span class="s1">(</span>
                    <span class="s1">isinstance(dictvalue</span><span class="s2">, </span><span class="s1">ParseResults) </span><span class="s2">and </span><span class="s1">dictvalue.haskeys()</span>
                <span class="s1">):</span>
                    <span class="s1">tokenlist[ikey] = _ParseResultsWithOffset(dictvalue</span><span class="s2">, </span><span class="s1">i)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">tokenlist[ikey] = _ParseResultsWithOffset(dictvalue[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">i)</span>

        <span class="s2">if </span><span class="s1">self._asPythonDict:</span>
            <span class="s2">return </span><span class="s1">[tokenlist.as_dict()] </span><span class="s2">if </span><span class="s1">self.resultsName </span><span class="s2">else </span><span class="s1">tokenlist.as_dict()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[tokenlist] </span><span class="s2">if </span><span class="s1">self.resultsName </span><span class="s2">else </span><span class="s1">tokenlist</span>


<span class="s2">class </span><span class="s1">Suppress(TokenConverter):</span>
    <span class="s4">&quot;&quot;&quot;Converter for ignoring the results of a parsed expression. 
 
    Example:: 
 
        source = &quot;a, b, c,d&quot; 
        wd = Word(alphas) 
        wd_list1 = wd + (',' + wd)[...] 
        print(wd_list1.parse_string(source)) 
 
        # often, delimiters that are useful during parsing are just in the 
        # way afterward - use Suppress to keep them out of the parsed output 
        wd_list2 = wd + (Suppress(',') + wd)[...] 
        print(wd_list2.parse_string(source)) 
 
        # Skipped text (using '...') can be suppressed as well 
        source = &quot;lead in START relevant text END trailing text&quot; 
        start_marker = Keyword(&quot;START&quot;) 
        end_marker = Keyword(&quot;END&quot;) 
        find_body = Suppress(...) + start_marker + ... + end_marker 
        print(find_body.parse_string(source) 
 
    prints:: 
 
        ['a', ',', 'b', ',', 'c', ',', 'd'] 
        ['a', 'b', 'c', 'd'] 
        ['START', 'relevant text ', 'END'] 
 
    (See also :class:`delimited_list`.) 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">expr: Union[ParserElement</span><span class="s2">, </span><span class="s1">str]</span><span class="s2">, </span><span class="s1">savelist: bool = </span><span class="s2">False</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">expr </span><span class="s2">is </span><span class="s1">...:</span>
            <span class="s1">expr = _PendingSkip(NoMatch())</span>
        <span class="s1">super().__init__(expr)</span>

    <span class="s2">def </span><span class="s1">__add__(self</span><span class="s2">, </span><span class="s1">other) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">isinstance(self.expr</span><span class="s2">, </span><span class="s1">_PendingSkip):</span>
            <span class="s2">return </span><span class="s1">Suppress(SkipTo(other)) + other</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">super().__add__(other)</span>

    <span class="s2">def </span><span class="s1">__sub__(self</span><span class="s2">, </span><span class="s1">other) -&gt; </span><span class="s5">&quot;ParserElement&quot;</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">isinstance(self.expr</span><span class="s2">, </span><span class="s1">_PendingSkip):</span>
            <span class="s2">return </span><span class="s1">Suppress(SkipTo(other)) - other</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">super().__sub__(other)</span>

    <span class="s2">def </span><span class="s1">postParse(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">tokenlist):</span>
        <span class="s2">return </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">suppress(self) -&gt; ParserElement:</span>
        <span class="s2">return </span><span class="s1">self</span>


<span class="s2">def </span><span class="s1">trace_parse_action(f: ParseAction) -&gt; ParseAction:</span>
    <span class="s4">&quot;&quot;&quot;Decorator for debugging parse actions. 
 
    When the parse action is called, this decorator will print 
    ``&quot;&gt;&gt; entering method-name(line:&lt;current_source_line&gt;, &lt;parse_location&gt;, &lt;matched_tokens&gt;)&quot;``. 
    When the parse action completes, the decorator will print 
    ``&quot;&lt;&lt;&quot;`` followed by the returned value, or any exception that the parse action raised. 
 
    Example:: 
 
        wd = Word(alphas) 
 
        @trace_parse_action 
        def remove_duplicate_chars(tokens): 
            return ''.join(sorted(set(''.join(tokens)))) 
 
        wds = wd[1, ...].set_parse_action(remove_duplicate_chars) 
        print(wds.parse_string(&quot;slkdjs sld sldd sdlf sdljf&quot;)) 
 
    prints:: 
 
        &gt;&gt;entering remove_duplicate_chars(line: 'slkdjs sld sldd sdlf sdljf', 0, (['slkdjs', 'sld', 'sldd', 'sdlf', 'sdljf'], {})) 
        &lt;&lt;leaving remove_duplicate_chars (ret: 'dfjkls') 
        ['dfjkls'] 
    &quot;&quot;&quot;</span>
    <span class="s1">f = _trim_arity(f)</span>

    <span class="s2">def </span><span class="s1">z(*paArgs):</span>
        <span class="s1">thisFunc = f.__name__</span>
        <span class="s1">s</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">t = paArgs[-</span><span class="s3">3</span><span class="s1">:]</span>
        <span class="s2">if </span><span class="s1">len(paArgs) &gt; </span><span class="s3">3</span><span class="s1">:</span>
            <span class="s1">thisFunc = paArgs[</span><span class="s3">0</span><span class="s1">].__class__.__name__ + </span><span class="s5">&quot;.&quot; </span><span class="s1">+ thisFunc</span>
        <span class="s1">sys.stderr.write(</span>
            <span class="s5">&quot;&gt;&gt;entering {}(line: {!r}, {}, {!r})</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s1">.format(thisFunc</span><span class="s2">, </span><span class="s1">line(l</span><span class="s2">, </span><span class="s1">s)</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">t)</span>
        <span class="s1">)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">ret = f(*paArgs)</span>
        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">exc:</span>
            <span class="s1">sys.stderr.write(</span><span class="s5">&quot;&lt;&lt;leaving {} (exception: {})</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s1">.format(thisFunc</span><span class="s2">, </span><span class="s1">exc))</span>
            <span class="s2">raise</span>
        <span class="s1">sys.stderr.write(</span><span class="s5">&quot;&lt;&lt;leaving {} (ret: {!r})</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s1">.format(thisFunc</span><span class="s2">, </span><span class="s1">ret))</span>
        <span class="s2">return </span><span class="s1">ret</span>

    <span class="s1">z.__name__ = f.__name__</span>
    <span class="s2">return </span><span class="s1">z</span>


<span class="s0"># convenience constants for positional expressions</span>
<span class="s1">empty = Empty().set_name(</span><span class="s5">&quot;empty&quot;</span><span class="s1">)</span>
<span class="s1">line_start = LineStart().set_name(</span><span class="s5">&quot;line_start&quot;</span><span class="s1">)</span>
<span class="s1">line_end = LineEnd().set_name(</span><span class="s5">&quot;line_end&quot;</span><span class="s1">)</span>
<span class="s1">string_start = StringStart().set_name(</span><span class="s5">&quot;string_start&quot;</span><span class="s1">)</span>
<span class="s1">string_end = StringEnd().set_name(</span><span class="s5">&quot;string_end&quot;</span><span class="s1">)</span>

<span class="s1">_escapedPunc = Word(_bslash</span><span class="s2">, </span><span class="s5">r&quot;\[]-*.$+^?()~ &quot;</span><span class="s2">, </span><span class="s1">exact=</span><span class="s3">2</span><span class="s1">).set_parse_action(</span>
    <span class="s2">lambda </span><span class="s1">s</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">t: t[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">1</span><span class="s1">]</span>
<span class="s1">)</span>
<span class="s1">_escapedHexChar = Regex(</span><span class="s5">r&quot;\\0?[xX][0-9a-fA-F]+&quot;</span><span class="s1">).set_parse_action(</span>
    <span class="s2">lambda </span><span class="s1">s</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">t: chr(int(t[</span><span class="s3">0</span><span class="s1">].lstrip(</span><span class="s5">r&quot;\0x&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s3">16</span><span class="s1">))</span>
<span class="s1">)</span>
<span class="s1">_escapedOctChar = Regex(</span><span class="s5">r&quot;\\0[0-7]+&quot;</span><span class="s1">).set_parse_action(</span>
    <span class="s2">lambda </span><span class="s1">s</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">t: chr(int(t[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s3">8</span><span class="s1">))</span>
<span class="s1">)</span>
<span class="s1">_singleChar = (</span>
    <span class="s1">_escapedPunc | _escapedHexChar | _escapedOctChar | CharsNotIn(</span><span class="s5">r&quot;\]&quot;</span><span class="s2">, </span><span class="s1">exact=</span><span class="s3">1</span><span class="s1">)</span>
<span class="s1">)</span>
<span class="s1">_charRange = Group(_singleChar + Suppress(</span><span class="s5">&quot;-&quot;</span><span class="s1">) + _singleChar)</span>
<span class="s1">_reBracketExpr = (</span>
    <span class="s1">Literal(</span><span class="s5">&quot;[&quot;</span><span class="s1">)</span>
    <span class="s1">+ Opt(</span><span class="s5">&quot;^&quot;</span><span class="s1">).set_results_name(</span><span class="s5">&quot;negate&quot;</span><span class="s1">)</span>
    <span class="s1">+ Group(OneOrMore(_charRange | _singleChar)).set_results_name(</span><span class="s5">&quot;body&quot;</span><span class="s1">)</span>
    <span class="s1">+ </span><span class="s5">&quot;]&quot;</span>
<span class="s1">)</span>


<span class="s2">def </span><span class="s1">srange(s: str) -&gt; str:</span>
    <span class="s4">r&quot;&quot;&quot;Helper to easily define string ranges for use in :class:`Word` 
    construction. Borrows syntax from regexp ``'[]'`` string range 
    definitions:: 
 
        srange(&quot;[0-9]&quot;)   -&gt; &quot;0123456789&quot; 
        srange(&quot;[a-z]&quot;)   -&gt; &quot;abcdefghijklmnopqrstuvwxyz&quot; 
        srange(&quot;[a-z$_]&quot;) -&gt; &quot;abcdefghijklmnopqrstuvwxyz$_&quot; 
 
    The input string must be enclosed in []'s, and the returned string 
    is the expanded character set joined into a single string. The 
    values enclosed in the []'s may be: 
 
    - a single character 
    - an escaped character with a leading backslash (such as ``\-`` 
      or ``\]``) 
    - an escaped hex character with a leading ``'\x'`` 
      (``\x21``, which is a ``'!'`` character) (``\0x##`` 
      is also supported for backwards compatibility) 
    - an escaped octal character with a leading ``'\0'`` 
      (``\041``, which is a ``'!'`` character) 
    - a range of any of the above, separated by a dash (``'a-z'``, 
      etc.) 
    - any combination of the above (``'aeiouy'``, 
      ``'a-zA-Z0-9_$'``, etc.) 
    &quot;&quot;&quot;</span>
    <span class="s1">_expanded = (</span>
        <span class="s2">lambda </span><span class="s1">p: p</span>
        <span class="s2">if not </span><span class="s1">isinstance(p</span><span class="s2">, </span><span class="s1">ParseResults)</span>
        <span class="s2">else </span><span class="s5">&quot;&quot;</span><span class="s1">.join(chr(c) </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">range(ord(p[</span><span class="s3">0</span><span class="s1">])</span><span class="s2">, </span><span class="s1">ord(p[</span><span class="s3">1</span><span class="s1">]) + </span><span class="s3">1</span><span class="s1">))</span>
    <span class="s1">)</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s5">&quot;&quot;</span><span class="s1">.join(_expanded(part) </span><span class="s2">for </span><span class="s1">part </span><span class="s2">in </span><span class="s1">_reBracketExpr.parse_string(s).body)</span>
    <span class="s2">except </span><span class="s1">Exception:</span>
        <span class="s2">return </span><span class="s5">&quot;&quot;</span>


<span class="s2">def </span><span class="s1">token_map(func</span><span class="s2">, </span><span class="s1">*args) -&gt; ParseAction:</span>
    <span class="s4">&quot;&quot;&quot;Helper to define a parse action by mapping a function to all 
    elements of a :class:`ParseResults` list. If any additional args are passed, 
    they are forwarded to the given function as additional arguments 
    after the token, as in 
    ``hex_integer = Word(hexnums).set_parse_action(token_map(int, 16))``, 
    which will convert the parsed data to an integer using base 16. 
 
    Example (compare the last to example in :class:`ParserElement.transform_string`:: 
 
        hex_ints = Word(hexnums)[1, ...].set_parse_action(token_map(int, 16)) 
        hex_ints.run_tests(''' 
            00 11 22 aa FF 0a 0d 1a 
            ''') 
 
        upperword = Word(alphas).set_parse_action(token_map(str.upper)) 
        upperword[1, ...].run_tests(''' 
            my kingdom for a horse 
            ''') 
 
        wd = Word(alphas).set_parse_action(token_map(str.title)) 
        wd[1, ...].set_parse_action(' '.join).run_tests(''' 
            now is the winter of our discontent made glorious summer by this sun of york 
            ''') 
 
    prints:: 
 
        00 11 22 aa FF 0a 0d 1a 
        [0, 17, 34, 170, 255, 10, 13, 26] 
 
        my kingdom for a horse 
        ['MY', 'KINGDOM', 'FOR', 'A', 'HORSE'] 
 
        now is the winter of our discontent made glorious summer by this sun of york 
        ['Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York'] 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">pa(s</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s2">return </span><span class="s1">[func(tokn</span><span class="s2">, </span><span class="s1">*args) </span><span class="s2">for </span><span class="s1">tokn </span><span class="s2">in </span><span class="s1">t]</span>

    <span class="s1">func_name = getattr(func</span><span class="s2">, </span><span class="s5">&quot;__name__&quot;</span><span class="s2">, </span><span class="s1">getattr(func</span><span class="s2">, </span><span class="s5">&quot;__class__&quot;</span><span class="s1">).__name__)</span>
    <span class="s1">pa.__name__ = func_name</span>

    <span class="s2">return </span><span class="s1">pa</span>


<span class="s2">def </span><span class="s1">autoname_elements() -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Utility to simplify mass-naming of parser elements, for 
    generating railroad diagram with named subdiagrams. 
    &quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">var </span><span class="s2">in </span><span class="s1">sys._getframe().f_back.f_locals.items():</span>
        <span class="s2">if </span><span class="s1">isinstance(var</span><span class="s2">, </span><span class="s1">ParserElement) </span><span class="s2">and not </span><span class="s1">var.customName:</span>
            <span class="s1">var.set_name(name)</span>


<span class="s1">dbl_quoted_string = Combine(</span>
    <span class="s1">Regex(</span><span class="s5">r'&quot;(?:[^&quot;\n\r\\]|(?:&quot;&quot;)|(?:\\(?:[^x]|x[0-9a-fA-F]+)))*'</span><span class="s1">) + </span><span class="s5">'&quot;'</span>
<span class="s1">).set_name(</span><span class="s5">&quot;string enclosed in double quotes&quot;</span><span class="s1">)</span>

<span class="s1">sgl_quoted_string = Combine(</span>
    <span class="s1">Regex(</span><span class="s5">r&quot;'(?:[^'\n\r\\]|(?:'')|(?:\\(?:[^x]|x[0-9a-fA-F]+)))*&quot;</span><span class="s1">) + </span><span class="s5">&quot;'&quot;</span>
<span class="s1">).set_name(</span><span class="s5">&quot;string enclosed in single quotes&quot;</span><span class="s1">)</span>

<span class="s1">quoted_string = Combine(</span>
    <span class="s1">Regex(</span><span class="s5">r'&quot;(?:[^&quot;\n\r\\]|(?:&quot;&quot;)|(?:\\(?:[^x]|x[0-9a-fA-F]+)))*'</span><span class="s1">) + </span><span class="s5">'&quot;'</span>
    <span class="s1">| Regex(</span><span class="s5">r&quot;'(?:[^'\n\r\\]|(?:'')|(?:\\(?:[^x]|x[0-9a-fA-F]+)))*&quot;</span><span class="s1">) + </span><span class="s5">&quot;'&quot;</span>
<span class="s1">).set_name(</span><span class="s5">&quot;quotedString using single or double quotes&quot;</span><span class="s1">)</span>

<span class="s1">unicode_string = Combine(</span><span class="s5">&quot;u&quot; </span><span class="s1">+ quoted_string.copy()).set_name(</span><span class="s5">&quot;unicode string literal&quot;</span><span class="s1">)</span>


<span class="s1">alphas8bit = srange(</span><span class="s5">r&quot;[\0xc0-\0xd6\0xd8-\0xf6\0xf8-\0xff]&quot;</span><span class="s1">)</span>
<span class="s1">punc8bit = srange(</span><span class="s5">r&quot;[\0xa1-\0xbf\0xd7\0xf7]&quot;</span><span class="s1">)</span>

<span class="s0"># build list of built-in expressions, for future reference if a global default value</span>
<span class="s0"># gets updated</span>
<span class="s1">_builtin_exprs: List[ParserElement] = [</span>
    <span class="s1">v </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">vars().values() </span><span class="s2">if </span><span class="s1">isinstance(v</span><span class="s2">, </span><span class="s1">ParserElement)</span>
<span class="s1">]</span>

<span class="s0"># backward compatibility names</span>
<span class="s1">tokenMap = token_map</span>
<span class="s1">conditionAsParseAction = condition_as_parse_action</span>
<span class="s1">nullDebugAction = null_debug_action</span>
<span class="s1">sglQuotedString = sgl_quoted_string</span>
<span class="s1">dblQuotedString = dbl_quoted_string</span>
<span class="s1">quotedString = quoted_string</span>
<span class="s1">unicodeString = unicode_string</span>
<span class="s1">lineStart = line_start</span>
<span class="s1">lineEnd = line_end</span>
<span class="s1">stringStart = string_start</span>
<span class="s1">stringEnd = string_end</span>
<span class="s1">traceParseAction = trace_parse_action</span>
</pre>
</body>
</html>