<html>
<head>
<title>editable_wheel.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
editable_wheel.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Create a wheel that, when installed, will make the source package 'editable' 
(add it to the interpreter's path, including metadata) per PEP 660. Replaces 
'setup.py develop'. 
 
.. note:: 
   One of the mechanisms briefly mentioned in PEP 660 to implement editable installs is 
   to create a separated directory inside ``build`` and use a .pth file to point to that 
   directory. In the context of this file such directory is referred as 
   *auxiliary build directory* or ``auxiliary_dir``. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">shutil</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">traceback</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">contextlib </span><span class="s2">import </span><span class="s1">suppress</span>
<span class="s2">from </span><span class="s1">enum </span><span class="s2">import </span><span class="s1">Enum</span>
<span class="s2">from </span><span class="s1">inspect </span><span class="s2">import </span><span class="s1">cleandoc</span>
<span class="s2">from </span><span class="s1">itertools </span><span class="s2">import </span><span class="s1">chain</span>
<span class="s2">from </span><span class="s1">pathlib </span><span class="s2">import </span><span class="s1">Path</span>
<span class="s2">from </span><span class="s1">tempfile </span><span class="s2">import </span><span class="s1">TemporaryDirectory</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s2">,</span>
    <span class="s1">Dict</span><span class="s2">,</span>
    <span class="s1">Iterable</span><span class="s2">,</span>
    <span class="s1">Iterator</span><span class="s2">,</span>
    <span class="s1">List</span><span class="s2">,</span>
    <span class="s1">Mapping</span><span class="s2">,</span>
    <span class="s1">Optional</span><span class="s2">,</span>
    <span class="s1">Tuple</span><span class="s2">,</span>
    <span class="s1">TypeVar</span><span class="s2">,</span>
    <span class="s1">Union</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">from </span><span class="s1">setuptools </span><span class="s2">import </span><span class="s1">Command</span><span class="s2">, </span><span class="s1">SetuptoolsDeprecationWarning</span><span class="s2">, </span><span class="s1">errors</span><span class="s2">, </span><span class="s1">namespaces</span>
<span class="s2">from </span><span class="s1">setuptools.command.build_py </span><span class="s2">import </span><span class="s1">build_py </span><span class="s2">as </span><span class="s1">build_py_cls</span>
<span class="s2">from </span><span class="s1">setuptools.discovery </span><span class="s2">import </span><span class="s1">find_package_path</span>
<span class="s2">from </span><span class="s1">setuptools.dist </span><span class="s2">import </span><span class="s1">Distribution</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s2">from </span><span class="s1">wheel.wheelfile </span><span class="s2">import </span><span class="s1">WheelFile  </span><span class="s3"># noqa</span>

<span class="s2">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s4">3</span><span class="s2">, </span><span class="s4">8</span><span class="s1">):</span>
    <span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Protocol</span>
<span class="s2">elif </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s2">from </span><span class="s1">typing_extensions </span><span class="s2">import </span><span class="s1">Protocol</span>
<span class="s2">else</span><span class="s1">:</span>
    <span class="s2">from </span><span class="s1">abc </span><span class="s2">import </span><span class="s1">ABC </span><span class="s2">as </span><span class="s1">Protocol</span>

<span class="s1">_Path = Union[str</span><span class="s2">, </span><span class="s1">Path]</span>
<span class="s1">_P = TypeVar(</span><span class="s5">&quot;_P&quot;</span><span class="s2">, </span><span class="s1">bound=_Path)</span>
<span class="s1">_logger = logging.getLogger(__name__)</span>


<span class="s2">class </span><span class="s1">_EditableMode(Enum):</span>
    <span class="s0">&quot;&quot;&quot; 
    Possible editable installation modes: 
    `lenient` (new files automatically added to the package - DEFAULT); 
    `strict` (requires a new installation when files are added/removed); or 
    `compat` (attempts to emulate `python setup.py develop` - DEPRECATED). 
    &quot;&quot;&quot;</span>

    <span class="s1">STRICT = </span><span class="s5">&quot;strict&quot;</span>
    <span class="s1">LENIENT = </span><span class="s5">&quot;lenient&quot;</span>
    <span class="s1">COMPAT = </span><span class="s5">&quot;compat&quot;  </span><span class="s3"># TODO: Remove `compat` after Dec/2022.</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">convert(cls</span><span class="s2">, </span><span class="s1">mode: Optional[str]) -&gt; </span><span class="s5">&quot;_EditableMode&quot;</span><span class="s1">:</span>
        <span class="s2">if not </span><span class="s1">mode:</span>
            <span class="s2">return </span><span class="s1">_EditableMode.LENIENT  </span><span class="s3"># default</span>

        <span class="s1">_mode = mode.upper()</span>
        <span class="s2">if </span><span class="s1">_mode </span><span class="s2">not in </span><span class="s1">_EditableMode.__members__:</span>
            <span class="s2">raise </span><span class="s1">errors.OptionError(</span><span class="s5">f&quot;Invalid editable mode: </span><span class="s2">{</span><span class="s1">mode</span><span class="s2">!r}</span><span class="s5">. Try: 'strict'.&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">_mode == </span><span class="s5">&quot;COMPAT&quot;</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s5">&quot;&quot;&quot; 
            The 'compat' editable mode is transitional and will be removed 
            in future versions of `setuptools`. 
            Please adapt your code accordingly to use either the 'strict' or the 
            'lenient' modes. 
 
            For more information, please check: 
            https://setuptools.pypa.io/en/latest/userguide/development_mode.html 
            &quot;&quot;&quot;</span>
            <span class="s1">warnings.warn(msg</span><span class="s2">, </span><span class="s1">SetuptoolsDeprecationWarning)</span>

        <span class="s2">return </span><span class="s1">_EditableMode[_mode]</span>


<span class="s1">_STRICT_WARNING = </span><span class="s5">&quot;&quot;&quot; 
New or renamed files may not be automatically picked up without a new installation. 
&quot;&quot;&quot;</span>

<span class="s1">_LENIENT_WARNING = </span><span class="s5">&quot;&quot;&quot; 
Options like `package-data`, `include/exclude-package-data` or 
`packages.find.exclude/include` may have no effect. 
&quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">editable_wheel(Command):</span>
    <span class="s0">&quot;&quot;&quot;Build 'editable' wheel for development. 
    (This command is reserved for internal use of setuptools). 
    &quot;&quot;&quot;</span>

    <span class="s1">description = </span><span class="s5">&quot;create a PEP 660 'editable' wheel&quot;</span>

    <span class="s1">user_options = [</span>
        <span class="s1">(</span><span class="s5">&quot;dist-dir=&quot;</span><span class="s2">, </span><span class="s5">&quot;d&quot;</span><span class="s2">, </span><span class="s5">&quot;directory to put final built distributions in&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s5">&quot;dist-info-dir=&quot;</span><span class="s2">, </span><span class="s5">&quot;I&quot;</span><span class="s2">, </span><span class="s5">&quot;path to a pre-build .dist-info directory&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s5">&quot;mode=&quot;</span><span class="s2">, None, </span><span class="s1">cleandoc(_EditableMode.__doc__ </span><span class="s2">or </span><span class="s5">&quot;&quot;</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">]</span>

    <span class="s2">def </span><span class="s1">initialize_options(self):</span>
        <span class="s1">self.dist_dir = </span><span class="s2">None</span>
        <span class="s1">self.dist_info_dir = </span><span class="s2">None</span>
        <span class="s1">self.project_dir = </span><span class="s2">None</span>
        <span class="s1">self.mode = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">finalize_options(self):</span>
        <span class="s1">dist = self.distribution</span>
        <span class="s1">self.project_dir = dist.src_root </span><span class="s2">or </span><span class="s1">os.curdir</span>
        <span class="s1">self.package_dir = dist.package_dir </span><span class="s2">or </span><span class="s1">{}</span>
        <span class="s1">self.dist_dir = Path(self.dist_dir </span><span class="s2">or </span><span class="s1">os.path.join(self.project_dir</span><span class="s2">, </span><span class="s5">&quot;dist&quot;</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">run(self):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self.dist_dir.mkdir(exist_ok=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">self._ensure_dist_info()</span>

            <span class="s3"># Add missing dist_info files</span>
            <span class="s1">self.reinitialize_command(</span><span class="s5">&quot;bdist_wheel&quot;</span><span class="s1">)</span>
            <span class="s1">bdist_wheel = self.get_finalized_command(</span><span class="s5">&quot;bdist_wheel&quot;</span><span class="s1">)</span>
            <span class="s1">bdist_wheel.write_wheelfile(self.dist_info_dir)</span>

            <span class="s1">self._create_wheel_file(bdist_wheel)</span>
        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">ex:</span>
            <span class="s1">traceback.print_exc()</span>
            <span class="s1">msg = </span><span class="s5">&quot;&quot;&quot; 
            Support for editable installs via PEP 660 was recently introduced 
            in `setuptools`. If you are seeing this error, please report to: 
 
            https://github.com/pypa/setuptools/issues 
 
            Meanwhile you can try the legacy behavior by setting an 
            environment variable and trying to install again: 
 
            SETUPTOOLS_ENABLE_FEATURES=&quot;legacy-editable&quot; 
            &quot;&quot;&quot;</span>
            <span class="s2">raise </span><span class="s1">errors.InternalError(cleandoc(msg)) </span><span class="s2">from </span><span class="s1">ex</span>

    <span class="s2">def </span><span class="s1">_ensure_dist_info(self):</span>
        <span class="s2">if </span><span class="s1">self.dist_info_dir </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">dist_info = self.reinitialize_command(</span><span class="s5">&quot;dist_info&quot;</span><span class="s1">)</span>
            <span class="s1">dist_info.output_dir = self.dist_dir</span>
            <span class="s1">dist_info.ensure_finalized()</span>
            <span class="s1">dist_info.run()</span>
            <span class="s1">self.dist_info_dir = dist_info.dist_info_dir</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">str(self.dist_info_dir).endswith(</span><span class="s5">&quot;.dist-info&quot;</span><span class="s1">)</span>
            <span class="s2">assert </span><span class="s1">Path(self.dist_info_dir</span><span class="s2">, </span><span class="s5">&quot;METADATA&quot;</span><span class="s1">).exists()</span>

    <span class="s2">def </span><span class="s1">_install_namespaces(self</span><span class="s2">, </span><span class="s1">installation_dir</span><span class="s2">, </span><span class="s1">pth_prefix):</span>
        <span class="s3"># XXX: Only required to support the deprecated namespace practice</span>
        <span class="s1">dist = self.distribution</span>
        <span class="s2">if not </span><span class="s1">dist.namespace_packages:</span>
            <span class="s2">return</span>

        <span class="s1">src_root = Path(self.project_dir</span><span class="s2">, </span><span class="s1">self.package_dir.get(</span><span class="s5">&quot;&quot;</span><span class="s2">, </span><span class="s5">&quot;.&quot;</span><span class="s1">)).resolve()</span>
        <span class="s1">installer = _NamespaceInstaller(dist</span><span class="s2">, </span><span class="s1">installation_dir</span><span class="s2">, </span><span class="s1">pth_prefix</span><span class="s2">, </span><span class="s1">src_root)</span>
        <span class="s1">installer.install_namespaces()</span>

    <span class="s2">def </span><span class="s1">_find_egg_info_dir(self) -&gt; Optional[str]:</span>
        <span class="s1">parent_dir = Path(self.dist_info_dir).parent </span><span class="s2">if </span><span class="s1">self.dist_info_dir </span><span class="s2">else </span><span class="s1">Path()</span>
        <span class="s1">candidates = map(str</span><span class="s2">, </span><span class="s1">parent_dir.glob(</span><span class="s5">&quot;*.egg-info&quot;</span><span class="s1">))</span>
        <span class="s2">return </span><span class="s1">next(candidates</span><span class="s2">, None</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_configure_build(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">name: str</span><span class="s2">, </span><span class="s1">unpacked_wheel: _Path</span><span class="s2">, </span><span class="s1">build_lib: _Path</span><span class="s2">, </span><span class="s1">tmp_dir: _Path</span>
    <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Configure commands to behave in the following ways: 
 
        - Build commands can write to ``build_lib`` if they really want to... 
          (but this folder is expected to be ignored and modules are expected to live 
          in the project directory...) 
        - Binary extensions should be built in-place (editable_mode = True) 
        - Data/header/script files are not part of the &quot;editable&quot; specification 
          so they are written directly to the unpacked_wheel directory. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Non-editable files (data, headers, scripts) are written directly to the</span>
        <span class="s3"># unpacked_wheel</span>

        <span class="s1">dist = self.distribution</span>
        <span class="s1">wheel = str(unpacked_wheel)</span>
        <span class="s1">build_lib = str(build_lib)</span>
        <span class="s1">data = str(Path(unpacked_wheel</span><span class="s2">, </span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s5">.data&quot;</span><span class="s2">, </span><span class="s5">&quot;data&quot;</span><span class="s1">))</span>
        <span class="s1">headers = str(Path(unpacked_wheel</span><span class="s2">, </span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s5">.data&quot;</span><span class="s2">, </span><span class="s5">&quot;headers&quot;</span><span class="s1">))</span>
        <span class="s1">scripts = str(Path(unpacked_wheel</span><span class="s2">, </span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s5">.data&quot;</span><span class="s2">, </span><span class="s5">&quot;scripts&quot;</span><span class="s1">))</span>

        <span class="s3"># egg-info may be generated again to create a manifest (used for package data)</span>
        <span class="s1">egg_info = dist.reinitialize_command(</span><span class="s5">&quot;egg_info&quot;</span><span class="s2">, </span><span class="s1">reinit_subcommands=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">egg_info.egg_base = str(tmp_dir)</span>
        <span class="s1">egg_info.ignore_egg_info_in_manifest = </span><span class="s2">True</span>

        <span class="s1">build = dist.reinitialize_command(</span><span class="s5">&quot;build&quot;</span><span class="s2">, </span><span class="s1">reinit_subcommands=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">install = dist.reinitialize_command(</span><span class="s5">&quot;install&quot;</span><span class="s2">, </span><span class="s1">reinit_subcommands=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s1">build.build_platlib = build.build_purelib = build.build_lib = build_lib</span>
        <span class="s1">install.install_purelib = install.install_platlib = install.install_lib = wheel</span>
        <span class="s1">install.install_scripts = build.build_scripts = scripts</span>
        <span class="s1">install.install_headers = headers</span>
        <span class="s1">install.install_data = data</span>

        <span class="s1">install_scripts = dist.get_command_obj(</span><span class="s5">&quot;install_scripts&quot;</span><span class="s1">)</span>
        <span class="s1">install_scripts.no_ep = </span><span class="s2">True</span>

        <span class="s1">build.build_temp = str(tmp_dir)</span>

        <span class="s1">build_py = dist.get_command_obj(</span><span class="s5">&quot;build_py&quot;</span><span class="s1">)</span>
        <span class="s1">build_py.compile = </span><span class="s2">False</span>
        <span class="s1">build_py.existing_egg_info_dir = self._find_egg_info_dir()</span>

        <span class="s1">self._set_editable_mode()</span>

        <span class="s1">build.ensure_finalized()</span>
        <span class="s1">install.ensure_finalized()</span>

    <span class="s2">def </span><span class="s1">_set_editable_mode(self):</span>
        <span class="s0">&quot;&quot;&quot;Set the ``editable_mode`` flag in the build sub-commands&quot;&quot;&quot;</span>
        <span class="s1">dist = self.distribution</span>
        <span class="s1">build = dist.get_command_obj(</span><span class="s5">&quot;build&quot;</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">cmd_name </span><span class="s2">in </span><span class="s1">build.get_sub_commands():</span>
            <span class="s1">cmd = dist.get_command_obj(cmd_name)</span>
            <span class="s2">if </span><span class="s1">hasattr(cmd</span><span class="s2">, </span><span class="s5">&quot;editable_mode&quot;</span><span class="s1">):</span>
                <span class="s1">cmd.editable_mode = </span><span class="s2">True</span>
            <span class="s2">elif </span><span class="s1">hasattr(cmd</span><span class="s2">, </span><span class="s5">&quot;inplace&quot;</span><span class="s1">):</span>
                <span class="s1">cmd.inplace = </span><span class="s2">True  </span><span class="s3"># backward compatibility with distutils</span>

    <span class="s2">def </span><span class="s1">_collect_build_outputs(self) -&gt; Tuple[List[str]</span><span class="s2">, </span><span class="s1">Dict[str</span><span class="s2">, </span><span class="s1">str]]:</span>
        <span class="s1">files: List[str] = []</span>
        <span class="s1">mapping: Dict[str</span><span class="s2">, </span><span class="s1">str] = {}</span>
        <span class="s1">build = self.get_finalized_command(</span><span class="s5">&quot;build&quot;</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">cmd_name </span><span class="s2">in </span><span class="s1">build.get_sub_commands():</span>
            <span class="s1">cmd = self.get_finalized_command(cmd_name)</span>
            <span class="s2">if </span><span class="s1">hasattr(cmd</span><span class="s2">, </span><span class="s5">&quot;get_outputs&quot;</span><span class="s1">):</span>
                <span class="s1">files.extend(cmd.get_outputs() </span><span class="s2">or </span><span class="s1">[])</span>
            <span class="s2">if </span><span class="s1">hasattr(cmd</span><span class="s2">, </span><span class="s5">&quot;get_output_mapping&quot;</span><span class="s1">):</span>
                <span class="s1">mapping.update(cmd.get_output_mapping() </span><span class="s2">or </span><span class="s1">{})</span>

        <span class="s2">return </span><span class="s1">files</span><span class="s2">, </span><span class="s1">mapping</span>

    <span class="s2">def </span><span class="s1">_run_build_commands(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">dist_name: str</span><span class="s2">, </span><span class="s1">unpacked_wheel: _Path</span><span class="s2">, </span><span class="s1">build_lib: _Path</span><span class="s2">, </span><span class="s1">tmp_dir: _Path</span>
    <span class="s1">) -&gt; Tuple[List[str]</span><span class="s2">, </span><span class="s1">Dict[str</span><span class="s2">, </span><span class="s1">str]]:</span>
        <span class="s1">self._configure_build(dist_name</span><span class="s2">, </span><span class="s1">unpacked_wheel</span><span class="s2">, </span><span class="s1">build_lib</span><span class="s2">, </span><span class="s1">tmp_dir)</span>
        <span class="s1">self._run_build_subcommands()</span>
        <span class="s1">files</span><span class="s2">, </span><span class="s1">mapping = self._collect_build_outputs()</span>
        <span class="s1">self._run_install(</span><span class="s5">&quot;headers&quot;</span><span class="s1">)</span>
        <span class="s1">self._run_install(</span><span class="s5">&quot;scripts&quot;</span><span class="s1">)</span>
        <span class="s1">self._run_install(</span><span class="s5">&quot;data&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">files</span><span class="s2">, </span><span class="s1">mapping</span>

    <span class="s2">def </span><span class="s1">_run_build_subcommands(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Issue #3501 indicates that some plugins/customizations might rely on: 
 
        1. ``build_py`` not running 
        2. ``build_py`` always copying files to ``build_lib`` 
 
        However both these assumptions may be false in editable_wheel. 
        This method implements a temporary workaround to support the ecosystem 
        while the implementations catch up. 
        &quot;&quot;&quot;</span>
        <span class="s3"># TODO: Once plugins/customisations had the chance to catch up, replace</span>
        <span class="s3">#       `self._run_build_subcommands()` with `self.run_command(&quot;build&quot;)`.</span>
        <span class="s3">#       Also remove _safely_run, TestCustomBuildPy. Suggested date: Aug/2023.</span>
        <span class="s1">build: Command = self.get_finalized_command(</span><span class="s5">&quot;build&quot;</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">build.get_sub_commands():</span>
            <span class="s1">cmd = self.get_finalized_command(name)</span>
            <span class="s2">if </span><span class="s1">name == </span><span class="s5">&quot;build_py&quot; </span><span class="s2">and </span><span class="s1">type(cmd) != build_py_cls:</span>
                <span class="s1">self._safely_run(name)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.run_command(name)</span>

    <span class="s2">def </span><span class="s1">_safely_run(self</span><span class="s2">, </span><span class="s1">cmd_name: str):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.run_command(cmd_name)</span>
        <span class="s2">except </span><span class="s1">Exception:</span>
            <span class="s1">msg = </span><span class="s5">f&quot;&quot;&quot;</span><span class="s2">{</span><span class="s1">traceback.format_exc()</span><span class="s2">}\n</span>
            <span class="s5">If you are seeing this warning it is very likely that a setuptools</span>
            <span class="s5">plugin or customization overrides the `</span><span class="s2">{</span><span class="s1">cmd_name</span><span class="s2">}</span><span class="s5">` command, without</span>
            <span class="s5">taking into consideration how editable installs run build steps</span>
            <span class="s5">starting from v64.0.0.</span>

            <span class="s5">Plugin authors and developers relying on custom build steps are encouraged</span>
            <span class="s5">to update their `</span><span class="s2">{</span><span class="s1">cmd_name</span><span class="s2">}</span><span class="s5">` implementation considering the information in</span>
            <span class="s5">https://setuptools.pypa.io/en/latest/userguide/extension.html</span>
            <span class="s5">about editable installs.</span>

            <span class="s5">For the time being `setuptools` will silence this error and ignore</span>
            <span class="s5">the faulty command, but this behaviour will change in future versions.</span><span class="s2">\n</span>
            <span class="s5">&quot;&quot;&quot;</span>
            <span class="s1">warnings.warn(msg</span><span class="s2">, </span><span class="s1">SetuptoolsDeprecationWarning</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_create_wheel_file(self</span><span class="s2">, </span><span class="s1">bdist_wheel):</span>
        <span class="s2">from </span><span class="s1">wheel.wheelfile </span><span class="s2">import </span><span class="s1">WheelFile</span>

        <span class="s1">dist_info = self.get_finalized_command(</span><span class="s5">&quot;dist_info&quot;</span><span class="s1">)</span>
        <span class="s1">dist_name = dist_info.name</span>
        <span class="s1">tag = </span><span class="s5">&quot;-&quot;</span><span class="s1">.join(bdist_wheel.get_tag())</span>
        <span class="s1">build_tag = </span><span class="s5">&quot;0.editable&quot;  </span><span class="s3"># According to PEP 427 needs to start with digit</span>
        <span class="s1">archive_name = </span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">dist_name</span><span class="s2">}</span><span class="s5">-</span><span class="s2">{</span><span class="s1">build_tag</span><span class="s2">}</span><span class="s5">-</span><span class="s2">{</span><span class="s1">tag</span><span class="s2">}</span><span class="s5">.whl&quot;</span>
        <span class="s1">wheel_path = Path(self.dist_dir</span><span class="s2">, </span><span class="s1">archive_name)</span>
        <span class="s2">if </span><span class="s1">wheel_path.exists():</span>
            <span class="s1">wheel_path.unlink()</span>

        <span class="s1">unpacked_wheel = TemporaryDirectory(suffix=archive_name)</span>
        <span class="s1">build_lib = TemporaryDirectory(suffix=</span><span class="s5">&quot;.build-lib&quot;</span><span class="s1">)</span>
        <span class="s1">build_tmp = TemporaryDirectory(suffix=</span><span class="s5">&quot;.build-temp&quot;</span><span class="s1">)</span>

        <span class="s2">with </span><span class="s1">unpacked_wheel </span><span class="s2">as </span><span class="s1">unpacked</span><span class="s2">, </span><span class="s1">build_lib </span><span class="s2">as </span><span class="s1">lib</span><span class="s2">, </span><span class="s1">build_tmp </span><span class="s2">as </span><span class="s1">tmp:</span>
            <span class="s1">unpacked_dist_info = Path(unpacked</span><span class="s2">, </span><span class="s1">Path(self.dist_info_dir).name)</span>
            <span class="s1">shutil.copytree(self.dist_info_dir</span><span class="s2">, </span><span class="s1">unpacked_dist_info)</span>
            <span class="s1">self._install_namespaces(unpacked</span><span class="s2">, </span><span class="s1">dist_info.name)</span>
            <span class="s1">files</span><span class="s2">, </span><span class="s1">mapping = self._run_build_commands(dist_name</span><span class="s2">, </span><span class="s1">unpacked</span><span class="s2">, </span><span class="s1">lib</span><span class="s2">, </span><span class="s1">tmp)</span>
            <span class="s1">strategy = self._select_strategy(dist_name</span><span class="s2">, </span><span class="s1">tag</span><span class="s2">, </span><span class="s1">lib)</span>
            <span class="s2">with </span><span class="s1">strategy</span><span class="s2">, </span><span class="s1">WheelFile(wheel_path</span><span class="s2">, </span><span class="s5">&quot;w&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">wheel_obj:</span>
                <span class="s1">strategy(wheel_obj</span><span class="s2">, </span><span class="s1">files</span><span class="s2">, </span><span class="s1">mapping)</span>
                <span class="s1">wheel_obj.write_files(unpacked)</span>

        <span class="s2">return </span><span class="s1">wheel_path</span>

    <span class="s2">def </span><span class="s1">_run_install(self</span><span class="s2">, </span><span class="s1">category: str):</span>
        <span class="s1">has_category = getattr(self.distribution</span><span class="s2">, </span><span class="s5">f&quot;has_</span><span class="s2">{</span><span class="s1">category</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">has_category </span><span class="s2">and </span><span class="s1">has_category():</span>
            <span class="s1">_logger.info(</span><span class="s5">f&quot;Installing </span><span class="s2">{</span><span class="s1">category</span><span class="s2">} </span><span class="s5">as non editable&quot;</span><span class="s1">)</span>
            <span class="s1">self.run_command(</span><span class="s5">f&quot;install_</span><span class="s2">{</span><span class="s1">category</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_select_strategy(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">name: str</span><span class="s2">,</span>
        <span class="s1">tag: str</span><span class="s2">,</span>
        <span class="s1">build_lib: _Path</span><span class="s2">,</span>
    <span class="s1">) -&gt; </span><span class="s5">&quot;EditableStrategy&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Decides which strategy to use to implement an editable installation.&quot;&quot;&quot;</span>
        <span class="s1">build_name = </span><span class="s5">f&quot;__editable__.</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s5">-</span><span class="s2">{</span><span class="s1">tag</span><span class="s2">}</span><span class="s5">&quot;</span>
        <span class="s1">project_dir = Path(self.project_dir)</span>
        <span class="s1">mode = _EditableMode.convert(self.mode)</span>

        <span class="s2">if </span><span class="s1">mode </span><span class="s2">is </span><span class="s1">_EditableMode.STRICT:</span>
            <span class="s1">auxiliary_dir = _empty_dir(Path(self.project_dir</span><span class="s2">, </span><span class="s5">&quot;build&quot;</span><span class="s2">, </span><span class="s1">build_name))</span>
            <span class="s2">return </span><span class="s1">_LinkTree(self.distribution</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">auxiliary_dir</span><span class="s2">, </span><span class="s1">build_lib)</span>

        <span class="s1">packages = _find_packages(self.distribution)</span>
        <span class="s1">has_simple_layout = _simple_layout(packages</span><span class="s2">, </span><span class="s1">self.package_dir</span><span class="s2">, </span><span class="s1">project_dir)</span>
        <span class="s1">is_compat_mode = mode </span><span class="s2">is </span><span class="s1">_EditableMode.COMPAT</span>
        <span class="s2">if </span><span class="s1">set(self.package_dir) == {</span><span class="s5">&quot;&quot;</span><span class="s1">} </span><span class="s2">and </span><span class="s1">has_simple_layout </span><span class="s2">or </span><span class="s1">is_compat_mode:</span>
            <span class="s3"># src-layout(ish) is relatively safe for a simple pth file</span>
            <span class="s1">src_dir = self.package_dir.get(</span><span class="s5">&quot;&quot;</span><span class="s2">, </span><span class="s5">&quot;.&quot;</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">_StaticPth(self.distribution</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">[Path(project_dir</span><span class="s2">, </span><span class="s1">src_dir)])</span>

        <span class="s3"># Use a MetaPathFinder to avoid adding accidental top-level packages/modules</span>
        <span class="s2">return </span><span class="s1">_TopLevelFinder(self.distribution</span><span class="s2">, </span><span class="s1">name)</span>


<span class="s2">class </span><span class="s1">EditableStrategy(Protocol):</span>
    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">wheel: </span><span class="s5">&quot;WheelFile&quot;</span><span class="s2">, </span><span class="s1">files: List[str]</span><span class="s2">, </span><span class="s1">mapping: Dict[str</span><span class="s2">, </span><span class="s1">str]):</span>
        <span class="s1">...</span>

    <span class="s2">def </span><span class="s1">__enter__(self):</span>
        <span class="s1">...</span>

    <span class="s2">def </span><span class="s1">__exit__(self</span><span class="s2">, </span><span class="s1">_exc_type</span><span class="s2">, </span><span class="s1">_exc_value</span><span class="s2">, </span><span class="s1">_traceback):</span>
        <span class="s1">...</span>


<span class="s2">class </span><span class="s1">_StaticPth:</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">dist: Distribution</span><span class="s2">, </span><span class="s1">name: str</span><span class="s2">, </span><span class="s1">path_entries: List[Path]):</span>
        <span class="s1">self.dist = dist</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.path_entries = path_entries</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">wheel: </span><span class="s5">&quot;WheelFile&quot;</span><span class="s2">, </span><span class="s1">files: List[str]</span><span class="s2">, </span><span class="s1">mapping: Dict[str</span><span class="s2">, </span><span class="s1">str]):</span>
        <span class="s1">entries = </span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s1">.join((str(p.resolve()) </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self.path_entries))</span>
        <span class="s1">contents = bytes(</span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">entries</span><span class="s2">}\n</span><span class="s5">&quot;</span><span class="s2">, </span><span class="s5">&quot;utf-8&quot;</span><span class="s1">)</span>
        <span class="s1">wheel.writestr(</span><span class="s5">f&quot;__editable__.</span><span class="s2">{</span><span class="s1">self.name</span><span class="s2">}</span><span class="s5">.pth&quot;</span><span class="s2">, </span><span class="s1">contents)</span>

    <span class="s2">def </span><span class="s1">__enter__(self):</span>
        <span class="s1">msg = </span><span class="s5">f&quot;&quot;&quot;</span>
        <span class="s5">Editable install will be performed using .pth file to extend `sys.path` with:</span>
        <span class="s2">{</span><span class="s1">list(map(os.fspath</span><span class="s2">, </span><span class="s1">self.path_entries))</span><span class="s2">!r}</span>
        <span class="s5">&quot;&quot;&quot;</span>
        <span class="s1">_logger.warning(msg + _LENIENT_WARNING)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__exit__(self</span><span class="s2">, </span><span class="s1">_exc_type</span><span class="s2">, </span><span class="s1">_exc_value</span><span class="s2">, </span><span class="s1">_traceback):</span>
        <span class="s1">...</span>


<span class="s2">class </span><span class="s1">_LinkTree(_StaticPth):</span>
    <span class="s0">&quot;&quot;&quot; 
    Creates a ``.pth`` file that points to a link tree in the ``auxiliary_dir``. 
 
    This strategy will only link files (not dirs), so it can be implemented in 
    any OS, even if that means using hardlinks instead of symlinks. 
 
    By collocating ``auxiliary_dir`` and the original source code, limitations 
    with hardlinks should be avoided. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">dist: Distribution</span><span class="s2">,</span>
        <span class="s1">name: str</span><span class="s2">,</span>
        <span class="s1">auxiliary_dir: _Path</span><span class="s2">,</span>
        <span class="s1">build_lib: _Path</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">self.auxiliary_dir = Path(auxiliary_dir)</span>
        <span class="s1">self.build_lib = Path(build_lib).resolve()</span>
        <span class="s1">self._file = dist.get_command_obj(</span><span class="s5">&quot;build_py&quot;</span><span class="s1">).copy_file</span>
        <span class="s1">super().__init__(dist</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">[self.auxiliary_dir])</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">wheel: </span><span class="s5">&quot;WheelFile&quot;</span><span class="s2">, </span><span class="s1">files: List[str]</span><span class="s2">, </span><span class="s1">mapping: Dict[str</span><span class="s2">, </span><span class="s1">str]):</span>
        <span class="s1">self._create_links(files</span><span class="s2">, </span><span class="s1">mapping)</span>
        <span class="s1">super().__call__(wheel</span><span class="s2">, </span><span class="s1">files</span><span class="s2">, </span><span class="s1">mapping)</span>

    <span class="s2">def </span><span class="s1">_normalize_output(self</span><span class="s2">, </span><span class="s1">file: str) -&gt; Optional[str]:</span>
        <span class="s3"># Files relative to build_lib will be normalized to None</span>
        <span class="s2">with </span><span class="s1">suppress(ValueError):</span>
            <span class="s1">path = Path(file).resolve().relative_to(self.build_lib)</span>
            <span class="s2">return </span><span class="s1">str(path).replace(os.sep</span><span class="s2">, </span><span class="s5">'/'</span><span class="s1">)</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">_create_file(self</span><span class="s2">, </span><span class="s1">relative_output: str</span><span class="s2">, </span><span class="s1">src_file: str</span><span class="s2">, </span><span class="s1">link=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">dest = self.auxiliary_dir / relative_output</span>
        <span class="s2">if not </span><span class="s1">dest.parent.is_dir():</span>
            <span class="s1">dest.parent.mkdir(parents=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">self._file(src_file</span><span class="s2">, </span><span class="s1">dest</span><span class="s2">, </span><span class="s1">link=link)</span>

    <span class="s2">def </span><span class="s1">_create_links(self</span><span class="s2">, </span><span class="s1">outputs</span><span class="s2">, </span><span class="s1">output_mapping):</span>
        <span class="s1">self.auxiliary_dir.mkdir(parents=</span><span class="s2">True, </span><span class="s1">exist_ok=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">link_type = </span><span class="s5">&quot;sym&quot; </span><span class="s2">if </span><span class="s1">_can_symlink_files(self.auxiliary_dir) </span><span class="s2">else </span><span class="s5">&quot;hard&quot;</span>
        <span class="s1">mappings = {</span>
            <span class="s1">self._normalize_output(k): v</span>
            <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">output_mapping.items()</span>
        <span class="s1">}</span>
        <span class="s1">mappings.pop(</span><span class="s2">None, None</span><span class="s1">)  </span><span class="s3"># remove files that are not relative to build_lib</span>

        <span class="s2">for </span><span class="s1">output </span><span class="s2">in </span><span class="s1">outputs:</span>
            <span class="s1">relative = self._normalize_output(output)</span>
            <span class="s2">if </span><span class="s1">relative </span><span class="s2">and </span><span class="s1">relative </span><span class="s2">not in </span><span class="s1">mappings:</span>
                <span class="s1">self._create_file(relative</span><span class="s2">, </span><span class="s1">output)</span>

        <span class="s2">for </span><span class="s1">relative</span><span class="s2">, </span><span class="s1">src </span><span class="s2">in </span><span class="s1">mappings.items():</span>
            <span class="s1">self._create_file(relative</span><span class="s2">, </span><span class="s1">src</span><span class="s2">, </span><span class="s1">link=link_type)</span>

    <span class="s2">def </span><span class="s1">__enter__(self):</span>
        <span class="s1">msg = </span><span class="s5">&quot;Strict editable install will be performed using a link tree.</span><span class="s2">\n</span><span class="s5">&quot;</span>
        <span class="s1">_logger.warning(msg + _STRICT_WARNING)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__exit__(self</span><span class="s2">, </span><span class="s1">_exc_type</span><span class="s2">, </span><span class="s1">_exc_value</span><span class="s2">, </span><span class="s1">_traceback):</span>
        <span class="s1">msg = </span><span class="s5">f&quot;&quot;&quot;</span><span class="s2">\n</span>
        <span class="s5">Strict editable installation performed using the auxiliary directory:</span>
            <span class="s2">{</span><span class="s1">self.auxiliary_dir</span><span class="s2">}</span>

        <span class="s5">Please be careful to not remove this directory, otherwise you might not be able</span>
        <span class="s5">to import/use your package.</span>
        <span class="s5">&quot;&quot;&quot;</span>
        <span class="s1">warnings.warn(msg</span><span class="s2">, </span><span class="s1">InformationOnly)</span>


<span class="s2">class </span><span class="s1">_TopLevelFinder:</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">dist: Distribution</span><span class="s2">, </span><span class="s1">name: str):</span>
        <span class="s1">self.dist = dist</span>
        <span class="s1">self.name = name</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">wheel: </span><span class="s5">&quot;WheelFile&quot;</span><span class="s2">, </span><span class="s1">files: List[str]</span><span class="s2">, </span><span class="s1">mapping: Dict[str</span><span class="s2">, </span><span class="s1">str]):</span>
        <span class="s1">src_root = self.dist.src_root </span><span class="s2">or </span><span class="s1">os.curdir</span>
        <span class="s1">top_level = chain(_find_packages(self.dist)</span><span class="s2">, </span><span class="s1">_find_top_level_modules(self.dist))</span>
        <span class="s1">package_dir = self.dist.package_dir </span><span class="s2">or </span><span class="s1">{}</span>
        <span class="s1">roots = _find_package_roots(top_level</span><span class="s2">, </span><span class="s1">package_dir</span><span class="s2">, </span><span class="s1">src_root)</span>

        <span class="s1">namespaces_: Dict[str</span><span class="s2">, </span><span class="s1">List[str]] = dict(chain(</span>
            <span class="s1">_find_namespaces(self.dist.packages </span><span class="s2">or </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">roots)</span><span class="s2">,</span>
            <span class="s1">((ns</span><span class="s2">, </span><span class="s1">[]) </span><span class="s2">for </span><span class="s1">ns </span><span class="s2">in </span><span class="s1">_find_virtual_namespaces(roots))</span><span class="s2">,</span>
        <span class="s1">))</span>

        <span class="s1">name = </span><span class="s5">f&quot;__editable__.</span><span class="s2">{</span><span class="s1">self.name</span><span class="s2">}</span><span class="s5">.finder&quot;</span>
        <span class="s1">finder = _make_identifier(name)</span>
        <span class="s1">content = bytes(_finder_template(name</span><span class="s2">, </span><span class="s1">roots</span><span class="s2">, </span><span class="s1">namespaces_)</span><span class="s2">, </span><span class="s5">&quot;utf-8&quot;</span><span class="s1">)</span>
        <span class="s1">wheel.writestr(</span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">finder</span><span class="s2">}</span><span class="s5">.py&quot;</span><span class="s2">, </span><span class="s1">content)</span>

        <span class="s1">content = bytes(</span><span class="s5">f&quot;import </span><span class="s2">{</span><span class="s1">finder</span><span class="s2">}</span><span class="s5">; </span><span class="s2">{</span><span class="s1">finder</span><span class="s2">}</span><span class="s5">.install()&quot;</span><span class="s2">, </span><span class="s5">&quot;utf-8&quot;</span><span class="s1">)</span>
        <span class="s1">wheel.writestr(</span><span class="s5">f&quot;__editable__.</span><span class="s2">{</span><span class="s1">self.name</span><span class="s2">}</span><span class="s5">.pth&quot;</span><span class="s2">, </span><span class="s1">content)</span>

    <span class="s2">def </span><span class="s1">__enter__(self):</span>
        <span class="s1">msg = </span><span class="s5">&quot;Editable install will be performed using a meta path finder.</span><span class="s2">\n</span><span class="s5">&quot;</span>
        <span class="s1">_logger.warning(msg + _LENIENT_WARNING)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__exit__(self</span><span class="s2">, </span><span class="s1">_exc_type</span><span class="s2">, </span><span class="s1">_exc_value</span><span class="s2">, </span><span class="s1">_traceback):</span>
        <span class="s1">msg = </span><span class="s5">&quot;&quot;&quot;</span><span class="s2">\n</span>
        <span class="s5">Please be careful with folders in your working directory with the same 
        name as your package as they may take precedence during imports. 
        &quot;&quot;&quot;</span>
        <span class="s1">warnings.warn(msg</span><span class="s2">, </span><span class="s1">InformationOnly)</span>


<span class="s2">def </span><span class="s1">_can_symlink_files(base_dir: Path) -&gt; bool:</span>
    <span class="s2">with </span><span class="s1">TemporaryDirectory(dir=str(base_dir.resolve())) </span><span class="s2">as </span><span class="s1">tmp:</span>
        <span class="s1">path1</span><span class="s2">, </span><span class="s1">path2 = Path(tmp</span><span class="s2">, </span><span class="s5">&quot;file1.txt&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Path(tmp</span><span class="s2">, </span><span class="s5">&quot;file2.txt&quot;</span><span class="s1">)</span>
        <span class="s1">path1.write_text(</span><span class="s5">&quot;file1&quot;</span><span class="s2">, </span><span class="s1">encoding=</span><span class="s5">&quot;utf-8&quot;</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">suppress(AttributeError</span><span class="s2">, </span><span class="s1">NotImplementedError</span><span class="s2">, </span><span class="s1">OSError):</span>
            <span class="s1">os.symlink(path1</span><span class="s2">, </span><span class="s1">path2)</span>
            <span class="s2">if </span><span class="s1">path2.is_symlink() </span><span class="s2">and </span><span class="s1">path2.read_text(encoding=</span><span class="s5">&quot;utf-8&quot;</span><span class="s1">) == </span><span class="s5">&quot;file1&quot;</span><span class="s1">:</span>
                <span class="s2">return True</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">os.link(path1</span><span class="s2">, </span><span class="s1">path2)  </span><span class="s3"># Ensure hard links can be created</span>
        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">ex:</span>
            <span class="s1">msg = (</span>
                <span class="s5">&quot;File system does not seem to support either symlinks or hard links. &quot;</span>
                <span class="s5">&quot;Strict editable installs require one of them to be supported.&quot;</span>
            <span class="s1">)</span>
            <span class="s2">raise </span><span class="s1">LinksNotSupported(msg) </span><span class="s2">from </span><span class="s1">ex</span>
        <span class="s2">return False</span>


<span class="s2">def </span><span class="s1">_simple_layout(</span>
    <span class="s1">packages: Iterable[str]</span><span class="s2">, </span><span class="s1">package_dir: Dict[str</span><span class="s2">, </span><span class="s1">str]</span><span class="s2">, </span><span class="s1">project_dir: Path</span>
<span class="s1">) -&gt; bool:</span>
    <span class="s0">&quot;&quot;&quot;Return ``True`` if: 
    - all packages are contained by the same parent directory, **and** 
    - all packages become importable if the parent directory is added to ``sys.path``. 
 
    &gt;&gt;&gt; _simple_layout(['a'], {&quot;&quot;: &quot;src&quot;}, &quot;/tmp/myproj&quot;) 
    True 
    &gt;&gt;&gt; _simple_layout(['a', 'a.b'], {&quot;&quot;: &quot;src&quot;}, &quot;/tmp/myproj&quot;) 
    True 
    &gt;&gt;&gt; _simple_layout(['a', 'a.b'], {}, &quot;/tmp/myproj&quot;) 
    True 
    &gt;&gt;&gt; _simple_layout(['a', 'a.a1', 'a.a1.a2', 'b'], {&quot;&quot;: &quot;src&quot;}, &quot;/tmp/myproj&quot;) 
    True 
    &gt;&gt;&gt; _simple_layout(['a', 'a.a1', 'a.a1.a2', 'b'], {&quot;a&quot;: &quot;a&quot;, &quot;b&quot;: &quot;b&quot;}, &quot;.&quot;) 
    True 
    &gt;&gt;&gt; _simple_layout(['a', 'a.a1', 'a.a1.a2', 'b'], {&quot;a&quot;: &quot;_a&quot;, &quot;b&quot;: &quot;_b&quot;}, &quot;.&quot;) 
    False 
    &gt;&gt;&gt; _simple_layout(['a', 'a.a1', 'a.a1.a2', 'b'], {&quot;a&quot;: &quot;_a&quot;}, &quot;/tmp/myproj&quot;) 
    False 
    &gt;&gt;&gt; _simple_layout(['a', 'a.a1', 'a.a1.a2', 'b'], {&quot;a.a1.a2&quot;: &quot;_a2&quot;}, &quot;.&quot;) 
    False 
    &gt;&gt;&gt; _simple_layout(['a', 'a.b'], {&quot;&quot;: &quot;src&quot;, &quot;a.b&quot;: &quot;_ab&quot;}, &quot;/tmp/myproj&quot;) 
    False 
    &gt;&gt;&gt; # Special cases, no packages yet: 
    &gt;&gt;&gt; _simple_layout([], {&quot;&quot;: &quot;src&quot;}, &quot;/tmp/myproj&quot;) 
    True 
    &gt;&gt;&gt; _simple_layout([], {&quot;a&quot;: &quot;_a&quot;, &quot;&quot;: &quot;src&quot;}, &quot;/tmp/myproj&quot;) 
    False 
    &quot;&quot;&quot;</span>
    <span class="s1">layout = {</span>
        <span class="s1">pkg: find_package_path(pkg</span><span class="s2">, </span><span class="s1">package_dir</span><span class="s2">, </span><span class="s1">project_dir)</span>
        <span class="s2">for </span><span class="s1">pkg </span><span class="s2">in </span><span class="s1">packages</span>
    <span class="s1">}</span>
    <span class="s2">if not </span><span class="s1">layout:</span>
        <span class="s2">return </span><span class="s1">set(package_dir) </span><span class="s2">in </span><span class="s1">({}</span><span class="s2">, </span><span class="s1">{</span><span class="s5">&quot;&quot;</span><span class="s1">})</span>
    <span class="s1">parent = os.path.commonpath([_parent_path(k</span><span class="s2">, </span><span class="s1">v) </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">layout.items()])</span>
    <span class="s2">return </span><span class="s1">all(</span>
        <span class="s1">_normalize_path(Path(parent</span><span class="s2">, </span><span class="s1">*key.split(</span><span class="s5">'.'</span><span class="s1">))) == _normalize_path(value)</span>
        <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">layout.items()</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">_parent_path(pkg</span><span class="s2">, </span><span class="s1">pkg_path):</span>
    <span class="s0">&quot;&quot;&quot;Infer the parent path containing a package, that if added to ``sys.path`` would 
    allow importing that package. 
    When ``pkg`` is directly mapped into a directory with a different name, return its 
    own path. 
    &gt;&gt;&gt; _parent_path(&quot;a&quot;, &quot;src/a&quot;) 
    'src' 
    &gt;&gt;&gt; _parent_path(&quot;b&quot;, &quot;src/c&quot;) 
    'src/c' 
    &quot;&quot;&quot;</span>
    <span class="s1">parent = pkg_path[:-len(pkg)] </span><span class="s2">if </span><span class="s1">pkg_path.endswith(pkg) </span><span class="s2">else </span><span class="s1">pkg_path</span>
    <span class="s2">return </span><span class="s1">parent.rstrip(</span><span class="s5">&quot;/&quot; </span><span class="s1">+ os.sep)</span>


<span class="s2">def </span><span class="s1">_find_packages(dist: Distribution) -&gt; Iterator[str]:</span>
    <span class="s2">yield from </span><span class="s1">iter(dist.packages </span><span class="s2">or </span><span class="s1">[])</span>

    <span class="s1">py_modules = dist.py_modules </span><span class="s2">or </span><span class="s1">[]</span>
    <span class="s1">nested_modules = [mod </span><span class="s2">for </span><span class="s1">mod </span><span class="s2">in </span><span class="s1">py_modules </span><span class="s2">if </span><span class="s5">&quot;.&quot; </span><span class="s2">in </span><span class="s1">mod]</span>
    <span class="s2">if </span><span class="s1">dist.ext_package:</span>
        <span class="s2">yield </span><span class="s1">dist.ext_package</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">ext_modules = dist.ext_modules </span><span class="s2">or </span><span class="s1">[]</span>
        <span class="s1">nested_modules += [x.name </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">ext_modules </span><span class="s2">if </span><span class="s5">&quot;.&quot; </span><span class="s2">in </span><span class="s1">x.name]</span>

    <span class="s2">for </span><span class="s1">module </span><span class="s2">in </span><span class="s1">nested_modules:</span>
        <span class="s1">package</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_ = module.rpartition(</span><span class="s5">&quot;.&quot;</span><span class="s1">)</span>
        <span class="s2">yield </span><span class="s1">package</span>


<span class="s2">def </span><span class="s1">_find_top_level_modules(dist: Distribution) -&gt; Iterator[str]:</span>
    <span class="s1">py_modules = dist.py_modules </span><span class="s2">or </span><span class="s1">[]</span>
    <span class="s2">yield from </span><span class="s1">(mod </span><span class="s2">for </span><span class="s1">mod </span><span class="s2">in </span><span class="s1">py_modules </span><span class="s2">if </span><span class="s5">&quot;.&quot; </span><span class="s2">not in </span><span class="s1">mod)</span>

    <span class="s2">if not </span><span class="s1">dist.ext_package:</span>
        <span class="s1">ext_modules = dist.ext_modules </span><span class="s2">or </span><span class="s1">[]</span>
        <span class="s2">yield from </span><span class="s1">(x.name </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">ext_modules </span><span class="s2">if </span><span class="s5">&quot;.&quot; </span><span class="s2">not in </span><span class="s1">x.name)</span>


<span class="s2">def </span><span class="s1">_find_package_roots(</span>
    <span class="s1">packages: Iterable[str]</span><span class="s2">,</span>
    <span class="s1">package_dir: Mapping[str</span><span class="s2">, </span><span class="s1">str]</span><span class="s2">,</span>
    <span class="s1">src_root: _Path</span><span class="s2">,</span>
<span class="s1">) -&gt; Dict[str</span><span class="s2">, </span><span class="s1">str]:</span>
    <span class="s1">pkg_roots: Dict[str</span><span class="s2">, </span><span class="s1">str] = {</span>
        <span class="s1">pkg: _absolute_root(find_package_path(pkg</span><span class="s2">, </span><span class="s1">package_dir</span><span class="s2">, </span><span class="s1">src_root))</span>
        <span class="s2">for </span><span class="s1">pkg </span><span class="s2">in </span><span class="s1">sorted(packages)</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">_remove_nested(pkg_roots)</span>


<span class="s2">def </span><span class="s1">_absolute_root(path: _Path) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;Works for packages and top-level modules&quot;&quot;&quot;</span>
    <span class="s1">path_ = Path(path)</span>
    <span class="s1">parent = path_.parent</span>

    <span class="s2">if </span><span class="s1">path_.exists():</span>
        <span class="s2">return </span><span class="s1">str(path_.resolve())</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">str(parent.resolve() / path_.name)</span>


<span class="s2">def </span><span class="s1">_find_virtual_namespaces(pkg_roots: Dict[str</span><span class="s2">, </span><span class="s1">str]) -&gt; Iterator[str]:</span>
    <span class="s0">&quot;&quot;&quot;By carefully designing ``package_dir``, it is possible to implement the logical 
    structure of PEP 420 in a package without the corresponding directories. 
 
    Moreover a parent package can be purposefully/accidentally skipped in the discovery 
    phase (e.g. ``find_packages(include=[&quot;mypkg.*&quot;])``, when ``mypkg.foo`` is included 
    by ``mypkg`` itself is not). 
    We consider this case to also be a virtual namespace (ignoring the original 
    directory) to emulate a non-editable installation. 
 
    This function will try to find these kinds of namespaces. 
    &quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">pkg </span><span class="s2">in </span><span class="s1">pkg_roots:</span>
        <span class="s2">if </span><span class="s5">&quot;.&quot; </span><span class="s2">not in </span><span class="s1">pkg:</span>
            <span class="s2">continue</span>
        <span class="s1">parts = pkg.split(</span><span class="s5">&quot;.&quot;</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(parts) - </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">partial_name = </span><span class="s5">&quot;.&quot;</span><span class="s1">.join(parts[:i])</span>
            <span class="s1">path = Path(find_package_path(partial_name</span><span class="s2">, </span><span class="s1">pkg_roots</span><span class="s2">, </span><span class="s5">&quot;&quot;</span><span class="s1">))</span>
            <span class="s2">if not </span><span class="s1">path.exists() </span><span class="s2">or </span><span class="s1">partial_name </span><span class="s2">not in </span><span class="s1">pkg_roots:</span>
                <span class="s3"># partial_name not in pkg_roots ==&gt; purposefully/accidentally skipped</span>
                <span class="s2">yield </span><span class="s1">partial_name</span>


<span class="s2">def </span><span class="s1">_find_namespaces(</span>
    <span class="s1">packages: List[str]</span><span class="s2">, </span><span class="s1">pkg_roots: Dict[str</span><span class="s2">, </span><span class="s1">str]</span>
<span class="s1">) -&gt; Iterator[Tuple[str</span><span class="s2">, </span><span class="s1">List[str]]]:</span>
    <span class="s2">for </span><span class="s1">pkg </span><span class="s2">in </span><span class="s1">packages:</span>
        <span class="s1">path = find_package_path(pkg</span><span class="s2">, </span><span class="s1">pkg_roots</span><span class="s2">, </span><span class="s5">&quot;&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">Path(path).exists() </span><span class="s2">and not </span><span class="s1">Path(path</span><span class="s2">, </span><span class="s5">&quot;__init__.py&quot;</span><span class="s1">).exists():</span>
            <span class="s2">yield </span><span class="s1">(pkg</span><span class="s2">, </span><span class="s1">[path])</span>


<span class="s2">def </span><span class="s1">_remove_nested(pkg_roots: Dict[str</span><span class="s2">, </span><span class="s1">str]) -&gt; Dict[str</span><span class="s2">, </span><span class="s1">str]:</span>
    <span class="s1">output = dict(pkg_roots.copy())</span>

    <span class="s2">for </span><span class="s1">pkg</span><span class="s2">, </span><span class="s1">path </span><span class="s2">in </span><span class="s1">reversed(list(pkg_roots.items())):</span>
        <span class="s2">if </span><span class="s1">any(</span>
            <span class="s1">pkg != other </span><span class="s2">and </span><span class="s1">_is_nested(pkg</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">other_path)</span>
            <span class="s2">for </span><span class="s1">other</span><span class="s2">, </span><span class="s1">other_path </span><span class="s2">in </span><span class="s1">pkg_roots.items()</span>
        <span class="s1">):</span>
            <span class="s1">output.pop(pkg)</span>

    <span class="s2">return </span><span class="s1">output</span>


<span class="s2">def </span><span class="s1">_is_nested(pkg: str</span><span class="s2">, </span><span class="s1">pkg_path: str</span><span class="s2">, </span><span class="s1">parent: str</span><span class="s2">, </span><span class="s1">parent_path: str) -&gt; bool:</span>
    <span class="s0">&quot;&quot;&quot; 
    Return ``True`` if ``pkg`` is nested inside ``parent`` both logically and in the 
    file system. 
    &gt;&gt;&gt; _is_nested(&quot;a.b&quot;, &quot;path/a/b&quot;, &quot;a&quot;, &quot;path/a&quot;) 
    True 
    &gt;&gt;&gt; _is_nested(&quot;a.b&quot;, &quot;path/a/b&quot;, &quot;a&quot;, &quot;otherpath/a&quot;) 
    False 
    &gt;&gt;&gt; _is_nested(&quot;a.b&quot;, &quot;path/a/b&quot;, &quot;c&quot;, &quot;path/c&quot;) 
    False 
    &gt;&gt;&gt; _is_nested(&quot;a.a&quot;, &quot;path/a/a&quot;, &quot;a&quot;, &quot;path/a&quot;) 
    True 
    &gt;&gt;&gt; _is_nested(&quot;b.a&quot;, &quot;path/b/a&quot;, &quot;a&quot;, &quot;path/a&quot;) 
    False 
    &quot;&quot;&quot;</span>
    <span class="s1">norm_pkg_path = _normalize_path(pkg_path)</span>
    <span class="s1">rest = pkg.replace(parent</span><span class="s2">, </span><span class="s5">&quot;&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">).strip(</span><span class="s5">&quot;.&quot;</span><span class="s1">).split(</span><span class="s5">&quot;.&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">(</span>
        <span class="s1">pkg.startswith(parent)</span>
        <span class="s2">and </span><span class="s1">norm_pkg_path == _normalize_path(Path(parent_path</span><span class="s2">, </span><span class="s1">*rest))</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">_normalize_path(filename: _Path) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;Normalize a file/dir name for comparison purposes&quot;&quot;&quot;</span>
    <span class="s3"># See pkg_resources.normalize_path</span>
    <span class="s1">file = os.path.abspath(filename) </span><span class="s2">if </span><span class="s1">sys.platform == </span><span class="s5">'cygwin' </span><span class="s2">else </span><span class="s1">filename</span>
    <span class="s2">return </span><span class="s1">os.path.normcase(os.path.realpath(os.path.normpath(file)))</span>


<span class="s2">def </span><span class="s1">_empty_dir(dir_: _P) -&gt; _P:</span>
    <span class="s0">&quot;&quot;&quot;Create a directory ensured to be empty. Existing files may be removed.&quot;&quot;&quot;</span>
    <span class="s1">shutil.rmtree(dir_</span><span class="s2">, </span><span class="s1">ignore_errors=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">os.makedirs(dir_)</span>
    <span class="s2">return </span><span class="s1">dir_</span>


<span class="s2">def </span><span class="s1">_make_identifier(name: str) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;Make a string safe to be used as Python identifier. 
    &gt;&gt;&gt; _make_identifier(&quot;12abc&quot;) 
    '_12abc' 
    &gt;&gt;&gt; _make_identifier(&quot;__editable__.myns.pkg-78.9.3_local&quot;) 
    '__editable___myns_pkg_78_9_3_local' 
    &quot;&quot;&quot;</span>
    <span class="s1">safe = re.sub(</span><span class="s5">r'\W|^(?=\d)'</span><span class="s2">, </span><span class="s5">'_'</span><span class="s2">, </span><span class="s1">name)</span>
    <span class="s2">assert </span><span class="s1">safe.isidentifier()</span>
    <span class="s2">return </span><span class="s1">safe</span>


<span class="s2">class </span><span class="s1">_NamespaceInstaller(namespaces.Installer):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">distribution</span><span class="s2">, </span><span class="s1">installation_dir</span><span class="s2">, </span><span class="s1">editable_name</span><span class="s2">, </span><span class="s1">src_root):</span>
        <span class="s1">self.distribution = distribution</span>
        <span class="s1">self.src_root = src_root</span>
        <span class="s1">self.installation_dir = installation_dir</span>
        <span class="s1">self.editable_name = editable_name</span>
        <span class="s1">self.outputs = []</span>
        <span class="s1">self.dry_run = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">_get_target(self):</span>
        <span class="s0">&quot;&quot;&quot;Installation target.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">os.path.join(self.installation_dir</span><span class="s2">, </span><span class="s1">self.editable_name)</span>

    <span class="s2">def </span><span class="s1">_get_root(self):</span>
        <span class="s0">&quot;&quot;&quot;Where the modules/packages should be loaded from.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">repr(str(self.src_root))</span>


<span class="s1">_FINDER_TEMPLATE = </span><span class="s5">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s5">import sys 
from importlib.machinery import ModuleSpec 
from importlib.machinery import all_suffixes as module_suffixes 
from importlib.util import spec_from_file_location 
from itertools import chain 
from pathlib import Path 
 
MAPPING = {mapping!r} 
NAMESPACES = {namespaces!r} 
PATH_PLACEHOLDER = {name!r} + &quot;.__path_hook__&quot; 
 
 
class _EditableFinder:  # MetaPathFinder 
    @classmethod 
    def find_spec(cls, fullname, path=None, target=None): 
        for pkg, pkg_path in reversed(list(MAPPING.items())): 
            if fullname == pkg or fullname.startswith(f&quot;{{pkg}}.&quot;): 
                rest = fullname.replace(pkg, &quot;&quot;, 1).strip(&quot;.&quot;).split(&quot;.&quot;) 
                return cls._find_spec(fullname, Path(pkg_path, *rest)) 
 
        return None 
 
    @classmethod 
    def _find_spec(cls, fullname, candidate_path): 
        init = candidate_path / &quot;__init__.py&quot; 
        candidates = (candidate_path.with_suffix(x) for x in module_suffixes()) 
        for candidate in chain([init], candidates): 
            if candidate.exists(): 
                return spec_from_file_location(fullname, candidate) 
 
 
class _EditableNamespaceFinder:  # PathEntryFinder 
    @classmethod 
    def _path_hook(cls, path): 
        if path == PATH_PLACEHOLDER: 
            return cls 
        raise ImportError 
 
    @classmethod 
    def _paths(cls, fullname): 
        # Ensure __path__ is not empty for the spec to be considered a namespace. 
        return NAMESPACES[fullname] or MAPPING.get(fullname) or [PATH_PLACEHOLDER] 
 
    @classmethod 
    def find_spec(cls, fullname, target=None): 
        if fullname in NAMESPACES: 
            spec = ModuleSpec(fullname, None, is_package=True) 
            spec.submodule_search_locations = cls._paths(fullname) 
            return spec 
        return None 
 
    @classmethod 
    def find_module(cls, fullname): 
        return None 
 
 
def install(): 
    if not any(finder == _EditableFinder for finder in sys.meta_path): 
        sys.meta_path.append(_EditableFinder) 
 
    if not NAMESPACES: 
        return 
 
    if not any(hook == _EditableNamespaceFinder._path_hook for hook in sys.path_hooks): 
        # PathEntryFinder is needed to create NamespaceSpec without private APIS 
        sys.path_hooks.append(_EditableNamespaceFinder._path_hook) 
    if PATH_PLACEHOLDER not in sys.path: 
        sys.path.append(PATH_PLACEHOLDER)  # Used just to trigger the path hook 
&quot;&quot;&quot;</span>


<span class="s2">def </span><span class="s1">_finder_template(</span>
    <span class="s1">name: str</span><span class="s2">, </span><span class="s1">mapping: Mapping[str</span><span class="s2">, </span><span class="s1">str]</span><span class="s2">, </span><span class="s1">namespaces: Dict[str</span><span class="s2">, </span><span class="s1">List[str]]</span>
<span class="s1">) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;Create a string containing the code for the``MetaPathFinder`` and 
    ``PathEntryFinder``. 
    &quot;&quot;&quot;</span>
    <span class="s1">mapping = dict(sorted(mapping.items()</span><span class="s2">, </span><span class="s1">key=</span><span class="s2">lambda </span><span class="s1">p: p[</span><span class="s4">0</span><span class="s1">]))</span>
    <span class="s2">return </span><span class="s1">_FINDER_TEMPLATE.format(name=name</span><span class="s2">, </span><span class="s1">mapping=mapping</span><span class="s2">, </span><span class="s1">namespaces=namespaces)</span>


<span class="s2">class </span><span class="s1">InformationOnly(UserWarning):</span>
    <span class="s0">&quot;&quot;&quot;Currently there is no clear way of displaying messages to the users 
    that use the setuptools backend directly via ``pip``. 
    The only thing that might work is a warning, although it is not the 
    most appropriate tool for the job... 
    &quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">LinksNotSupported(errors.FileError):</span>
    <span class="s0">&quot;&quot;&quot;File system does not seem to support either symlinks or hard links.&quot;&quot;&quot;</span>
</pre>
</body>
</html>