<html>
<head>
<title>expand.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
expand.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Utility functions to expand configuration directives or special values 
(such glob patterns). 
 
We can split the process of interpreting configuration files into 2 steps: 
 
1. The parsing the file contents from strings to value objects 
   that can be understand by Python (for example a string with a comma 
   separated list of keywords into an actual Python list of strings). 
 
2. The expansion (or post-processing) of these values according to the 
   semantics ``setuptools`` assign to them (for example a configuration field 
   with the ``file:`` directive should be expanded from a list of file paths to 
   a single string with the contents of those files concatenated) 
 
This module focus on the second step, and therefore allow sharing the expansion 
functions among several configuration file formats. 
 
**PRIVATE MODULE**: API reserved for setuptools internal usage only. 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">ast</span>
<span class="s2">import </span><span class="s1">importlib</span>
<span class="s2">import </span><span class="s1">io</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">pathlib</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">glob </span><span class="s2">import </span><span class="s1">iglob</span>
<span class="s2">from </span><span class="s1">configparser </span><span class="s2">import </span><span class="s1">ConfigParser</span>
<span class="s2">from </span><span class="s1">importlib.machinery </span><span class="s2">import </span><span class="s1">ModuleSpec</span>
<span class="s2">from </span><span class="s1">itertools </span><span class="s2">import </span><span class="s1">chain</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s2">,</span>
    <span class="s1">Callable</span><span class="s2">,</span>
    <span class="s1">Dict</span><span class="s2">,</span>
    <span class="s1">Iterable</span><span class="s2">,</span>
    <span class="s1">Iterator</span><span class="s2">,</span>
    <span class="s1">List</span><span class="s2">,</span>
    <span class="s1">Mapping</span><span class="s2">,</span>
    <span class="s1">Optional</span><span class="s2">,</span>
    <span class="s1">Tuple</span><span class="s2">,</span>
    <span class="s1">TypeVar</span><span class="s2">,</span>
    <span class="s1">Union</span><span class="s2">,</span>
    <span class="s1">cast</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pathlib </span><span class="s2">import </span><span class="s1">Path</span>
<span class="s2">from </span><span class="s1">types </span><span class="s2">import </span><span class="s1">ModuleType</span>

<span class="s2">from </span><span class="s1">distutils.errors </span><span class="s2">import </span><span class="s1">DistutilsOptionError</span>

<span class="s2">from </span><span class="s1">.._path </span><span class="s2">import </span><span class="s1">same_path </span><span class="s2">as </span><span class="s1">_same_path</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s2">from </span><span class="s1">setuptools.dist </span><span class="s2">import </span><span class="s1">Distribution  </span><span class="s3"># noqa</span>
    <span class="s2">from </span><span class="s1">setuptools.discovery </span><span class="s2">import </span><span class="s1">ConfigDiscovery  </span><span class="s3"># noqa</span>
    <span class="s2">from </span><span class="s1">distutils.dist </span><span class="s2">import </span><span class="s1">DistributionMetadata  </span><span class="s3"># noqa</span>

<span class="s1">chain_iter = chain.from_iterable</span>
<span class="s1">_Path = Union[str</span><span class="s2">, </span><span class="s1">os.PathLike]</span>
<span class="s1">_K = TypeVar(</span><span class="s4">&quot;_K&quot;</span><span class="s1">)</span>
<span class="s1">_V = TypeVar(</span><span class="s4">&quot;_V&quot;</span><span class="s2">, </span><span class="s1">covariant=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">StaticModule:</span>
    <span class="s0">&quot;&quot;&quot;Proxy to a module object that avoids executing arbitrary code.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name: str</span><span class="s2">, </span><span class="s1">spec: ModuleSpec):</span>
        <span class="s1">module = ast.parse(pathlib.Path(spec.origin).read_bytes())</span>
        <span class="s1">vars(self).update(locals())</span>
        <span class="s2">del </span><span class="s1">self.self</span>

    <span class="s2">def </span><span class="s1">_find_assignments(self) -&gt; Iterator[Tuple[ast.AST</span><span class="s2">, </span><span class="s1">ast.AST]]:</span>
        <span class="s2">for </span><span class="s1">statement </span><span class="s2">in </span><span class="s1">self.module.body:</span>
            <span class="s2">if </span><span class="s1">isinstance(statement</span><span class="s2">, </span><span class="s1">ast.Assign):</span>
                <span class="s2">yield from </span><span class="s1">((target</span><span class="s2">, </span><span class="s1">statement.value) </span><span class="s2">for </span><span class="s1">target </span><span class="s2">in </span><span class="s1">statement.targets)</span>
            <span class="s2">elif </span><span class="s1">isinstance(statement</span><span class="s2">, </span><span class="s1">ast.AnnAssign) </span><span class="s2">and </span><span class="s1">statement.value:</span>
                <span class="s2">yield </span><span class="s1">(statement.target</span><span class="s2">, </span><span class="s1">statement.value)</span>

    <span class="s2">def </span><span class="s1">__getattr__(self</span><span class="s2">, </span><span class="s1">attr):</span>
        <span class="s0">&quot;&quot;&quot;Attempt to load an attribute &quot;statically&quot;, via :func:`ast.literal_eval`.&quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">next(</span>
                <span class="s1">ast.literal_eval(value)</span>
                <span class="s2">for </span><span class="s1">target</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">self._find_assignments()</span>
                <span class="s2">if </span><span class="s1">isinstance(target</span><span class="s2">, </span><span class="s1">ast.Name) </span><span class="s2">and </span><span class="s1">target.id == attr</span>
            <span class="s1">)</span>
        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">raise </span><span class="s1">AttributeError(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">self.name</span><span class="s2">} </span><span class="s4">has no attribute </span><span class="s2">{</span><span class="s1">attr</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">) </span><span class="s2">from </span><span class="s1">e</span>


<span class="s2">def </span><span class="s1">glob_relative(</span>
    <span class="s1">patterns: Iterable[str]</span><span class="s2">, </span><span class="s1">root_dir: Optional[_Path] = </span><span class="s2">None</span>
<span class="s1">) -&gt; List[str]:</span>
    <span class="s0">&quot;&quot;&quot;Expand the list of glob patterns, but preserving relative paths. 
 
    :param list[str] patterns: List of glob patterns 
    :param str root_dir: Path to which globs should be relative 
                         (current directory by default) 
    :rtype: list 
    &quot;&quot;&quot;</span>
    <span class="s1">glob_characters = {</span><span class="s4">'*'</span><span class="s2">, </span><span class="s4">'?'</span><span class="s2">, </span><span class="s4">'['</span><span class="s2">, </span><span class="s4">']'</span><span class="s2">, </span><span class="s4">'{'</span><span class="s2">, </span><span class="s4">'}'</span><span class="s1">}</span>
    <span class="s1">expanded_values = []</span>
    <span class="s1">root_dir = root_dir </span><span class="s2">or </span><span class="s1">os.getcwd()</span>
    <span class="s2">for </span><span class="s1">value </span><span class="s2">in </span><span class="s1">patterns:</span>

        <span class="s3"># Has globby characters?</span>
        <span class="s2">if </span><span class="s1">any(char </span><span class="s2">in </span><span class="s1">value </span><span class="s2">for </span><span class="s1">char </span><span class="s2">in </span><span class="s1">glob_characters):</span>
            <span class="s3"># then expand the glob pattern while keeping paths *relative*:</span>
            <span class="s1">glob_path = os.path.abspath(os.path.join(root_dir</span><span class="s2">, </span><span class="s1">value))</span>
            <span class="s1">expanded_values.extend(sorted(</span>
                <span class="s1">os.path.relpath(path</span><span class="s2">, </span><span class="s1">root_dir).replace(os.sep</span><span class="s2">, </span><span class="s4">&quot;/&quot;</span><span class="s1">)</span>
                <span class="s2">for </span><span class="s1">path </span><span class="s2">in </span><span class="s1">iglob(glob_path</span><span class="s2">, </span><span class="s1">recursive=</span><span class="s2">True</span><span class="s1">)))</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># take the value as-is</span>
            <span class="s1">path = os.path.relpath(value</span><span class="s2">, </span><span class="s1">root_dir).replace(os.sep</span><span class="s2">, </span><span class="s4">&quot;/&quot;</span><span class="s1">)</span>
            <span class="s1">expanded_values.append(path)</span>

    <span class="s2">return </span><span class="s1">expanded_values</span>


<span class="s2">def </span><span class="s1">read_files(filepaths: Union[str</span><span class="s2">, </span><span class="s1">bytes</span><span class="s2">, </span><span class="s1">Iterable[_Path]]</span><span class="s2">, </span><span class="s1">root_dir=</span><span class="s2">None</span><span class="s1">) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;Return the content of the files concatenated using ``\n`` as str 
 
    This function is sandboxed and won't reach anything outside ``root_dir`` 
 
    (By default ``root_dir`` is the current directory). 
    &quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">setuptools.extern.more_itertools </span><span class="s2">import </span><span class="s1">always_iterable</span>

    <span class="s1">root_dir = os.path.abspath(root_dir </span><span class="s2">or </span><span class="s1">os.getcwd())</span>
    <span class="s1">_filepaths = (os.path.join(root_dir</span><span class="s2">, </span><span class="s1">path) </span><span class="s2">for </span><span class="s1">path </span><span class="s2">in </span><span class="s1">always_iterable(filepaths))</span>
    <span class="s2">return </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s1">.join(</span>
        <span class="s1">_read_file(path)</span>
        <span class="s2">for </span><span class="s1">path </span><span class="s2">in </span><span class="s1">_filter_existing_files(_filepaths)</span>
        <span class="s2">if </span><span class="s1">_assert_local(path</span><span class="s2">, </span><span class="s1">root_dir)</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">_filter_existing_files(filepaths: Iterable[_Path]) -&gt; Iterator[_Path]:</span>
    <span class="s2">for </span><span class="s1">path </span><span class="s2">in </span><span class="s1">filepaths:</span>
        <span class="s2">if </span><span class="s1">os.path.isfile(path):</span>
            <span class="s2">yield </span><span class="s1">path</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span><span class="s4">f&quot;File </span><span class="s2">{</span><span class="s1">path</span><span class="s2">!r} </span><span class="s4">cannot be found&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_read_file(filepath: Union[bytes</span><span class="s2">, </span><span class="s1">_Path]) -&gt; str:</span>
    <span class="s2">with </span><span class="s1">io.open(filepath</span><span class="s2">, </span><span class="s1">encoding=</span><span class="s4">'utf-8'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
        <span class="s2">return </span><span class="s1">f.read()</span>


<span class="s2">def </span><span class="s1">_assert_local(filepath: _Path</span><span class="s2">, </span><span class="s1">root_dir: str):</span>
    <span class="s2">if </span><span class="s1">Path(os.path.abspath(root_dir)) </span><span class="s2">not in </span><span class="s1">Path(os.path.abspath(filepath)).parents:</span>
        <span class="s1">msg = </span><span class="s4">f&quot;Cannot access </span><span class="s2">{</span><span class="s1">filepath</span><span class="s2">!r} </span><span class="s4">(or anything outside </span><span class="s2">{</span><span class="s1">root_dir</span><span class="s2">!r}</span><span class="s4">)&quot;</span>
        <span class="s2">raise </span><span class="s1">DistutilsOptionError(msg)</span>

    <span class="s2">return True</span>


<span class="s2">def </span><span class="s1">read_attr(</span>
    <span class="s1">attr_desc: str</span><span class="s2">,</span>
    <span class="s1">package_dir: Optional[Mapping[str</span><span class="s2">, </span><span class="s1">str]] = </span><span class="s2">None,</span>
    <span class="s1">root_dir: Optional[_Path] = </span><span class="s2">None</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Reads the value of an attribute from a module. 
 
    This function will try to read the attributed statically first 
    (via :func:`ast.literal_eval`), and only evaluate the module if it fails. 
 
    Examples: 
        read_attr(&quot;package.attr&quot;) 
        read_attr(&quot;package.module.attr&quot;) 
 
    :param str attr_desc: Dot-separated string describing how to reach the 
        attribute (see examples above) 
    :param dict[str, str] package_dir: Mapping of package names to their 
        location in disk (represented by paths relative to ``root_dir``). 
    :param str root_dir: Path to directory containing all the packages in 
        ``package_dir`` (current directory by default). 
    :rtype: str 
    &quot;&quot;&quot;</span>
    <span class="s1">root_dir = root_dir </span><span class="s2">or </span><span class="s1">os.getcwd()</span>
    <span class="s1">attrs_path = attr_desc.strip().split(</span><span class="s4">'.'</span><span class="s1">)</span>
    <span class="s1">attr_name = attrs_path.pop()</span>
    <span class="s1">module_name = </span><span class="s4">'.'</span><span class="s1">.join(attrs_path)</span>
    <span class="s1">module_name = module_name </span><span class="s2">or </span><span class="s4">'__init__'</span>
    <span class="s1">_parent_path</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">module_name = _find_module(module_name</span><span class="s2">, </span><span class="s1">package_dir</span><span class="s2">, </span><span class="s1">root_dir)</span>
    <span class="s1">spec = _find_spec(module_name</span><span class="s2">, </span><span class="s1">path)</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">getattr(StaticModule(module_name</span><span class="s2">, </span><span class="s1">spec)</span><span class="s2">, </span><span class="s1">attr_name)</span>
    <span class="s2">except </span><span class="s1">Exception:</span>
        <span class="s3"># fallback to evaluate module</span>
        <span class="s1">module = _load_spec(spec</span><span class="s2">, </span><span class="s1">module_name)</span>
        <span class="s2">return </span><span class="s1">getattr(module</span><span class="s2">, </span><span class="s1">attr_name)</span>


<span class="s2">def </span><span class="s1">_find_spec(module_name: str</span><span class="s2">, </span><span class="s1">module_path: Optional[_Path]) -&gt; ModuleSpec:</span>
    <span class="s1">spec = importlib.util.spec_from_file_location(module_name</span><span class="s2">, </span><span class="s1">module_path)</span>
    <span class="s1">spec = spec </span><span class="s2">or </span><span class="s1">importlib.util.find_spec(module_name)</span>

    <span class="s2">if </span><span class="s1">spec </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ModuleNotFoundError(module_name)</span>

    <span class="s2">return </span><span class="s1">spec</span>


<span class="s2">def </span><span class="s1">_load_spec(spec: ModuleSpec</span><span class="s2">, </span><span class="s1">module_name: str) -&gt; ModuleType:</span>
    <span class="s1">name = getattr(spec</span><span class="s2">, </span><span class="s4">&quot;__name__&quot;</span><span class="s2">, </span><span class="s1">module_name)</span>
    <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">sys.modules:</span>
        <span class="s2">return </span><span class="s1">sys.modules[name]</span>
    <span class="s1">module = importlib.util.module_from_spec(spec)</span>
    <span class="s1">sys.modules[name] = module  </span><span class="s3"># cache (it also ensures `==` works on loaded items)</span>
    <span class="s1">spec.loader.exec_module(module)  </span><span class="s3"># type: ignore</span>
    <span class="s2">return </span><span class="s1">module</span>


<span class="s2">def </span><span class="s1">_find_module(</span>
    <span class="s1">module_name: str</span><span class="s2">, </span><span class="s1">package_dir: Optional[Mapping[str</span><span class="s2">, </span><span class="s1">str]]</span><span class="s2">, </span><span class="s1">root_dir: _Path</span>
<span class="s1">) -&gt; Tuple[_Path</span><span class="s2">, </span><span class="s1">Optional[str]</span><span class="s2">, </span><span class="s1">str]:</span>
    <span class="s0">&quot;&quot;&quot;Given a module (that could normally be imported by ``module_name`` 
    after the build is complete), find the path to the parent directory where 
    it is contained and the canonical name that could be used to import it 
    considering the ``package_dir`` in the build configuration and ``root_dir`` 
    &quot;&quot;&quot;</span>
    <span class="s1">parent_path = root_dir</span>
    <span class="s1">module_parts = module_name.split(</span><span class="s4">'.'</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">package_dir:</span>
        <span class="s2">if </span><span class="s1">module_parts[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">package_dir:</span>
            <span class="s3"># A custom path was specified for the module we want to import</span>
            <span class="s1">custom_path = package_dir[module_parts[</span><span class="s5">0</span><span class="s1">]]</span>
            <span class="s1">parts = custom_path.rsplit(</span><span class="s4">'/'</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">len(parts) &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">parent_path = os.path.join(root_dir</span><span class="s2">, </span><span class="s1">parts[</span><span class="s5">0</span><span class="s1">])</span>
                <span class="s1">parent_module = parts[</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">parent_module = custom_path</span>
            <span class="s1">module_name = </span><span class="s4">&quot;.&quot;</span><span class="s1">.join([parent_module</span><span class="s2">, </span><span class="s1">*module_parts[</span><span class="s5">1</span><span class="s1">:]])</span>
        <span class="s2">elif </span><span class="s4">'' </span><span class="s2">in </span><span class="s1">package_dir:</span>
            <span class="s3"># A custom parent directory was specified for all root modules</span>
            <span class="s1">parent_path = os.path.join(root_dir</span><span class="s2">, </span><span class="s1">package_dir[</span><span class="s4">''</span><span class="s1">])</span>

    <span class="s1">path_start = os.path.join(parent_path</span><span class="s2">, </span><span class="s1">*module_name.split(</span><span class="s4">&quot;.&quot;</span><span class="s1">))</span>
    <span class="s1">candidates = chain(</span>
        <span class="s1">(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">path_start</span><span class="s2">}</span><span class="s4">.py&quot;</span><span class="s2">, </span><span class="s1">os.path.join(path_start</span><span class="s2">, </span><span class="s4">&quot;__init__.py&quot;</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">iglob(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">path_start</span><span class="s2">}</span><span class="s4">.*&quot;</span><span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">module_path = next((x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">candidates </span><span class="s2">if </span><span class="s1">os.path.isfile(x))</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">parent_path</span><span class="s2">, </span><span class="s1">module_path</span><span class="s2">, </span><span class="s1">module_name</span>


<span class="s2">def </span><span class="s1">resolve_class(</span>
    <span class="s1">qualified_class_name: str</span><span class="s2">,</span>
    <span class="s1">package_dir: Optional[Mapping[str</span><span class="s2">, </span><span class="s1">str]] = </span><span class="s2">None,</span>
    <span class="s1">root_dir: Optional[_Path] = </span><span class="s2">None</span>
<span class="s1">) -&gt; Callable:</span>
    <span class="s0">&quot;&quot;&quot;Given a qualified class name, return the associated class object&quot;&quot;&quot;</span>
    <span class="s1">root_dir = root_dir </span><span class="s2">or </span><span class="s1">os.getcwd()</span>
    <span class="s1">idx = qualified_class_name.rfind(</span><span class="s4">'.'</span><span class="s1">)</span>
    <span class="s1">class_name = qualified_class_name[idx + </span><span class="s5">1 </span><span class="s1">:]</span>
    <span class="s1">pkg_name = qualified_class_name[:idx]</span>

    <span class="s1">_parent_path</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">module_name = _find_module(pkg_name</span><span class="s2">, </span><span class="s1">package_dir</span><span class="s2">, </span><span class="s1">root_dir)</span>
    <span class="s1">module = _load_spec(_find_spec(module_name</span><span class="s2">, </span><span class="s1">path)</span><span class="s2">, </span><span class="s1">module_name)</span>
    <span class="s2">return </span><span class="s1">getattr(module</span><span class="s2">, </span><span class="s1">class_name)</span>


<span class="s2">def </span><span class="s1">cmdclass(</span>
    <span class="s1">values: Dict[str</span><span class="s2">, </span><span class="s1">str]</span><span class="s2">,</span>
    <span class="s1">package_dir: Optional[Mapping[str</span><span class="s2">, </span><span class="s1">str]] = </span><span class="s2">None,</span>
    <span class="s1">root_dir: Optional[_Path] = </span><span class="s2">None</span>
<span class="s1">) -&gt; Dict[str</span><span class="s2">, </span><span class="s1">Callable]:</span>
    <span class="s0">&quot;&quot;&quot;Given a dictionary mapping command names to strings for qualified class 
    names, apply :func:`resolve_class` to the dict values. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">{k: resolve_class(v</span><span class="s2">, </span><span class="s1">package_dir</span><span class="s2">, </span><span class="s1">root_dir) </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">values.items()}</span>


<span class="s2">def </span><span class="s1">find_packages(</span>
    <span class="s1">*</span><span class="s2">,</span>
    <span class="s1">namespaces=</span><span class="s2">True,</span>
    <span class="s1">fill_package_dir: Optional[Dict[str</span><span class="s2">, </span><span class="s1">str]] = </span><span class="s2">None,</span>
    <span class="s1">root_dir: Optional[_Path] = </span><span class="s2">None,</span>
    <span class="s1">**kwargs</span>
<span class="s1">) -&gt; List[str]:</span>
    <span class="s0">&quot;&quot;&quot;Works similarly to :func:`setuptools.find_packages`, but with all 
    arguments given as keyword arguments. Moreover, ``where`` can be given 
    as a list (the results will be simply concatenated). 
 
    When the additional keyword argument ``namespaces`` is ``True``, it will 
    behave like :func:`setuptools.find_namespace_packages`` (i.e. include 
    implicit namespaces as per :pep:`420`). 
 
    The ``where`` argument will be considered relative to ``root_dir`` (or the current 
    working directory when ``root_dir`` is not given). 
 
    If the ``fill_package_dir`` argument is passed, this function will consider it as a 
    similar data structure to the ``package_dir`` configuration parameter add fill-in 
    any missing package location. 
 
    :rtype: list 
    &quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">setuptools.discovery </span><span class="s2">import </span><span class="s1">construct_package_dir</span>
    <span class="s2">from </span><span class="s1">setuptools.extern.more_itertools </span><span class="s2">import </span><span class="s1">unique_everseen</span><span class="s2">, </span><span class="s1">always_iterable</span>

    <span class="s2">if </span><span class="s1">namespaces:</span>
        <span class="s2">from </span><span class="s1">setuptools.discovery </span><span class="s2">import </span><span class="s1">PEP420PackageFinder </span><span class="s2">as </span><span class="s1">PackageFinder</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">from </span><span class="s1">setuptools.discovery </span><span class="s2">import </span><span class="s1">PackageFinder  </span><span class="s3"># type: ignore</span>

    <span class="s1">root_dir = root_dir </span><span class="s2">or </span><span class="s1">os.curdir</span>
    <span class="s1">where = kwargs.pop(</span><span class="s4">'where'</span><span class="s2">, </span><span class="s1">[</span><span class="s4">'.'</span><span class="s1">])</span>
    <span class="s1">packages: List[str] = []</span>
    <span class="s1">fill_package_dir = {} </span><span class="s2">if </span><span class="s1">fill_package_dir </span><span class="s2">is None else </span><span class="s1">fill_package_dir</span>
    <span class="s1">search = list(unique_everseen(always_iterable(where)))</span>

    <span class="s2">if </span><span class="s1">len(search) == </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">all(</span><span class="s2">not </span><span class="s1">_same_path(search[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">(</span><span class="s4">&quot;.&quot;</span><span class="s2">, </span><span class="s1">root_dir)):</span>
        <span class="s1">fill_package_dir.setdefault(</span><span class="s4">&quot;&quot;</span><span class="s2">, </span><span class="s1">search[</span><span class="s5">0</span><span class="s1">])</span>

    <span class="s2">for </span><span class="s1">path </span><span class="s2">in </span><span class="s1">search:</span>
        <span class="s1">package_path = _nest_path(root_dir</span><span class="s2">, </span><span class="s1">path)</span>
        <span class="s1">pkgs = PackageFinder.find(package_path</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">packages.extend(pkgs)</span>
        <span class="s2">if </span><span class="s1">pkgs </span><span class="s2">and not </span><span class="s1">(</span>
            <span class="s1">fill_package_dir.get(</span><span class="s4">&quot;&quot;</span><span class="s1">) == path</span>
            <span class="s2">or </span><span class="s1">os.path.samefile(package_path</span><span class="s2">, </span><span class="s1">root_dir)</span>
        <span class="s1">):</span>
            <span class="s1">fill_package_dir.update(construct_package_dir(pkgs</span><span class="s2">, </span><span class="s1">path))</span>

    <span class="s2">return </span><span class="s1">packages</span>


<span class="s2">def </span><span class="s1">_nest_path(parent: _Path</span><span class="s2">, </span><span class="s1">path: _Path) -&gt; str:</span>
    <span class="s1">path = parent </span><span class="s2">if </span><span class="s1">path </span><span class="s2">in </span><span class="s1">{</span><span class="s4">&quot;.&quot;</span><span class="s2">, </span><span class="s4">&quot;&quot;</span><span class="s1">} </span><span class="s2">else </span><span class="s1">os.path.join(parent</span><span class="s2">, </span><span class="s1">path)</span>
    <span class="s2">return </span><span class="s1">os.path.normpath(path)</span>


<span class="s2">def </span><span class="s1">version(value: Union[Callable</span><span class="s2">, </span><span class="s1">Iterable[Union[str</span><span class="s2">, </span><span class="s1">int]]</span><span class="s2">, </span><span class="s1">str]) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;When getting the version directly from an attribute, 
    it should be normalised to string. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">callable(value):</span>
        <span class="s1">value = value()</span>

    <span class="s1">value = cast(Iterable[Union[str</span><span class="s2">, </span><span class="s1">int]]</span><span class="s2">, </span><span class="s1">value)</span>

    <span class="s2">if not </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s2">if </span><span class="s1">hasattr(value</span><span class="s2">, </span><span class="s4">'__iter__'</span><span class="s1">):</span>
            <span class="s1">value = </span><span class="s4">'.'</span><span class="s1">.join(map(str</span><span class="s2">, </span><span class="s1">value))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">value = </span><span class="s4">'%s' </span><span class="s1">% value</span>

    <span class="s2">return </span><span class="s1">value</span>


<span class="s2">def </span><span class="s1">canonic_package_data(package_data: dict) -&gt; dict:</span>
    <span class="s2">if </span><span class="s4">&quot;*&quot; </span><span class="s2">in </span><span class="s1">package_data:</span>
        <span class="s1">package_data[</span><span class="s4">&quot;&quot;</span><span class="s1">] = package_data.pop(</span><span class="s4">&quot;*&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">package_data</span>


<span class="s2">def </span><span class="s1">canonic_data_files(</span>
    <span class="s1">data_files: Union[list</span><span class="s2">, </span><span class="s1">dict]</span><span class="s2">, </span><span class="s1">root_dir: Optional[_Path] = </span><span class="s2">None</span>
<span class="s1">) -&gt; List[Tuple[str</span><span class="s2">, </span><span class="s1">List[str]]]:</span>
    <span class="s0">&quot;&quot;&quot;For compatibility with ``setup.py``, ``data_files`` should be a list 
    of pairs instead of a dict. 
 
    This function also expands glob patterns. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(data_files</span><span class="s2">, </span><span class="s1">list):</span>
        <span class="s2">return </span><span class="s1">data_files</span>

    <span class="s2">return </span><span class="s1">[</span>
        <span class="s1">(dest</span><span class="s2">, </span><span class="s1">glob_relative(patterns</span><span class="s2">, </span><span class="s1">root_dir))</span>
        <span class="s2">for </span><span class="s1">dest</span><span class="s2">, </span><span class="s1">patterns </span><span class="s2">in </span><span class="s1">data_files.items()</span>
    <span class="s1">]</span>


<span class="s2">def </span><span class="s1">entry_points(text: str</span><span class="s2">, </span><span class="s1">text_source=</span><span class="s4">&quot;entry-points&quot;</span><span class="s1">) -&gt; Dict[str</span><span class="s2">, </span><span class="s1">dict]:</span>
    <span class="s0">&quot;&quot;&quot;Given the contents of entry-points file, 
    process it into a 2-level dictionary (``dict[str, dict[str, str]]``). 
    The first level keys are entry-point groups, the second level keys are 
    entry-point names, and the second level values are references to objects 
    (that correspond to the entry-point value). 
    &quot;&quot;&quot;</span>
    <span class="s1">parser = ConfigParser(default_section=</span><span class="s2">None, </span><span class="s1">delimiters=(</span><span class="s4">&quot;=&quot;</span><span class="s2">,</span><span class="s1">))  </span><span class="s3"># type: ignore</span>
    <span class="s1">parser.optionxform = str  </span><span class="s3"># case sensitive</span>
    <span class="s1">parser.read_string(text</span><span class="s2">, </span><span class="s1">text_source)</span>
    <span class="s1">groups = {k: dict(v.items()) </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">parser.items()}</span>
    <span class="s1">groups.pop(parser.default_section</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">groups</span>


<span class="s2">class </span><span class="s1">EnsurePackagesDiscovered:</span>
    <span class="s0">&quot;&quot;&quot;Some expand functions require all the packages to already be discovered before 
    they run, e.g. :func:`read_attr`, :func:`resolve_class`, :func:`cmdclass`. 
 
    Therefore in some cases we will need to run autodiscovery during the evaluation of 
    the configuration. However, it is better to postpone calling package discovery as 
    much as possible, because some parameters can influence it (e.g. ``package_dir``), 
    and those might not have been processed yet. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">distribution: </span><span class="s4">&quot;Distribution&quot;</span><span class="s1">):</span>
        <span class="s1">self._dist = distribution</span>
        <span class="s1">self._called = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">__call__(self):</span>
        <span class="s0">&quot;&quot;&quot;Trigger the automatic package discovery, if it is still necessary.&quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self._called:</span>
            <span class="s1">self._called = </span><span class="s2">True</span>
            <span class="s1">self._dist.set_defaults(name=</span><span class="s2">False</span><span class="s1">)  </span><span class="s3"># Skip name, we can still be parsing</span>

    <span class="s2">def </span><span class="s1">__enter__(self):</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__exit__(self</span><span class="s2">, </span><span class="s1">_exc_type</span><span class="s2">, </span><span class="s1">_exc_value</span><span class="s2">, </span><span class="s1">_traceback):</span>
        <span class="s2">if </span><span class="s1">self._called:</span>
            <span class="s1">self._dist.set_defaults.analyse_name()  </span><span class="s3"># Now we can set a default name</span>

    <span class="s2">def </span><span class="s1">_get_package_dir(self) -&gt; Mapping[str</span><span class="s2">, </span><span class="s1">str]:</span>
        <span class="s1">self()</span>
        <span class="s1">pkg_dir = self._dist.package_dir</span>
        <span class="s2">return </span><span class="s1">{} </span><span class="s2">if </span><span class="s1">pkg_dir </span><span class="s2">is None else </span><span class="s1">pkg_dir</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">package_dir(self) -&gt; Mapping[str</span><span class="s2">, </span><span class="s1">str]:</span>
        <span class="s0">&quot;&quot;&quot;Proxy to ``package_dir`` that may trigger auto-discovery when used.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">LazyMappingProxy(self._get_package_dir)</span>


<span class="s2">class </span><span class="s1">LazyMappingProxy(Mapping[_K</span><span class="s2">, </span><span class="s1">_V]):</span>
    <span class="s0">&quot;&quot;&quot;Mapping proxy that delays resolving the target object, until really needed. 
 
    &gt;&gt;&gt; def obtain_mapping(): 
    ...     print(&quot;Running expensive function!&quot;) 
    ...     return {&quot;key&quot;: &quot;value&quot;, &quot;other key&quot;: &quot;other value&quot;} 
    &gt;&gt;&gt; mapping = LazyMappingProxy(obtain_mapping) 
    &gt;&gt;&gt; mapping[&quot;key&quot;] 
    Running expensive function! 
    'value' 
    &gt;&gt;&gt; mapping[&quot;other key&quot;] 
    'other value' 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">obtain_mapping_value: Callable[[]</span><span class="s2">, </span><span class="s1">Mapping[_K</span><span class="s2">, </span><span class="s1">_V]]):</span>
        <span class="s1">self._obtain = obtain_mapping_value</span>
        <span class="s1">self._value: Optional[Mapping[_K</span><span class="s2">, </span><span class="s1">_V]] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">_target(self) -&gt; Mapping[_K</span><span class="s2">, </span><span class="s1">_V]:</span>
        <span class="s2">if </span><span class="s1">self._value </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._value = self._obtain()</span>
        <span class="s2">return </span><span class="s1">self._value</span>

    <span class="s2">def </span><span class="s1">__getitem__(self</span><span class="s2">, </span><span class="s1">key: _K) -&gt; _V:</span>
        <span class="s2">return </span><span class="s1">self._target()[key]</span>

    <span class="s2">def </span><span class="s1">__len__(self) -&gt; int:</span>
        <span class="s2">return </span><span class="s1">len(self._target())</span>

    <span class="s2">def </span><span class="s1">__iter__(self) -&gt; Iterator[_K]:</span>
        <span class="s2">return </span><span class="s1">iter(self._target())</span>
</pre>
</body>
</html>