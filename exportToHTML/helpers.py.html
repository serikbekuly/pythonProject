<html>
<head>
<title>helpers.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
helpers.py</font>
</center></td></tr></table>
<pre><span class="s0"># helpers.py</span>
<span class="s2">import </span><span class="s1">html.entities</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">typing</span>

<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">__diag__</span>
<span class="s2">from </span><span class="s1">.core </span><span class="s2">import </span><span class="s1">*</span>
<span class="s2">from </span><span class="s1">.util </span><span class="s2">import </span><span class="s1">_bslash</span><span class="s2">, </span><span class="s1">_flatten</span><span class="s2">, </span><span class="s1">_escape_regex_range_chars</span>


<span class="s0">#</span>
<span class="s0"># global helpers</span>
<span class="s0">#</span>
<span class="s2">def </span><span class="s1">delimited_list(</span>
    <span class="s1">expr: Union[str</span><span class="s2">, </span><span class="s1">ParserElement]</span><span class="s2">,</span>
    <span class="s1">delim: Union[str</span><span class="s2">, </span><span class="s1">ParserElement] = </span><span class="s3">&quot;,&quot;</span><span class="s2">,</span>
    <span class="s1">combine: bool = </span><span class="s2">False,</span>
    <span class="s1">min: typing.Optional[int] = </span><span class="s2">None,</span>
    <span class="s1">max: typing.Optional[int] = </span><span class="s2">None,</span>
    <span class="s1">*</span><span class="s2">,</span>
    <span class="s1">allow_trailing_delim: bool = </span><span class="s2">False,</span>
<span class="s1">) -&gt; ParserElement:</span>
    <span class="s4">&quot;&quot;&quot;Helper to define a delimited list of expressions - the delimiter 
    defaults to ','. By default, the list elements and delimiters can 
    have intervening whitespace, and comments, but this can be 
    overridden by passing ``combine=True`` in the constructor. If 
    ``combine`` is set to ``True``, the matching tokens are 
    returned as a single token string, with the delimiters included; 
    otherwise, the matching tokens are returned as a list of tokens, 
    with the delimiters suppressed. 
 
    If ``allow_trailing_delim`` is set to True, then the list may end with 
    a delimiter. 
 
    Example:: 
 
        delimited_list(Word(alphas)).parse_string(&quot;aa,bb,cc&quot;) # -&gt; ['aa', 'bb', 'cc'] 
        delimited_list(Word(hexnums), delim=':', combine=True).parse_string(&quot;AA:BB:CC:DD:EE&quot;) # -&gt; ['AA:BB:CC:DD:EE'] 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(expr</span><span class="s2">, </span><span class="s1">str_type):</span>
        <span class="s1">expr = ParserElement._literalStringClass(expr)</span>

    <span class="s1">dlName = </span><span class="s3">&quot;{expr} [{delim} {expr}]...{end}&quot;</span><span class="s1">.format(</span>
        <span class="s1">expr=str(expr.copy().streamline())</span><span class="s2">,</span>
        <span class="s1">delim=str(delim)</span><span class="s2">,</span>
        <span class="s1">end=</span><span class="s3">&quot; [{}]&quot;</span><span class="s1">.format(str(delim)) </span><span class="s2">if </span><span class="s1">allow_trailing_delim </span><span class="s2">else </span><span class="s3">&quot;&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s2">if not </span><span class="s1">combine:</span>
        <span class="s1">delim = Suppress(delim)</span>

    <span class="s2">if </span><span class="s1">min </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">min &lt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;min must be greater than 0&quot;</span><span class="s1">)</span>
        <span class="s1">min -= </span><span class="s5">1</span>
    <span class="s2">if </span><span class="s1">max </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">min </span><span class="s2">is not None and </span><span class="s1">max &lt;= min:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;max must be greater than, or equal to min&quot;</span><span class="s1">)</span>
        <span class="s1">max -= </span><span class="s5">1</span>
    <span class="s1">delimited_list_expr = expr + (delim + expr)[min</span><span class="s2">, </span><span class="s1">max]</span>

    <span class="s2">if </span><span class="s1">allow_trailing_delim:</span>
        <span class="s1">delimited_list_expr += Opt(delim)</span>

    <span class="s2">if </span><span class="s1">combine:</span>
        <span class="s2">return </span><span class="s1">Combine(delimited_list_expr).set_name(dlName)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">delimited_list_expr.set_name(dlName)</span>


<span class="s2">def </span><span class="s1">counted_array(</span>
    <span class="s1">expr: ParserElement</span><span class="s2">,</span>
    <span class="s1">int_expr: typing.Optional[ParserElement] = </span><span class="s2">None,</span>
    <span class="s1">*</span><span class="s2">,</span>
    <span class="s1">intExpr: typing.Optional[ParserElement] = </span><span class="s2">None,</span>
<span class="s1">) -&gt; ParserElement:</span>
    <span class="s4">&quot;&quot;&quot;Helper to define a counted list of expressions. 
 
    This helper defines a pattern of the form:: 
 
        integer expr expr expr... 
 
    where the leading integer tells how many expr expressions follow. 
    The matched tokens returns the array of expr tokens as a list - the 
    leading count token is suppressed. 
 
    If ``int_expr`` is specified, it should be a pyparsing expression 
    that produces an integer value. 
 
    Example:: 
 
        counted_array(Word(alphas)).parse_string('2 ab cd ef')  # -&gt; ['ab', 'cd'] 
 
        # in this parser, the leading integer value is given in binary, 
        # '10' indicating that 2 values are in the array 
        binary_constant = Word('01').set_parse_action(lambda t: int(t[0], 2)) 
        counted_array(Word(alphas), int_expr=binary_constant).parse_string('10 ab cd ef')  # -&gt; ['ab', 'cd'] 
 
        # if other fields must be parsed after the count but before the 
        # list items, give the fields results names and they will 
        # be preserved in the returned ParseResults: 
        count_with_metadata = integer + Word(alphas)(&quot;type&quot;) 
        typed_array = counted_array(Word(alphanums), int_expr=count_with_metadata)(&quot;items&quot;) 
        result = typed_array.parse_string(&quot;3 bool True True False&quot;) 
        print(result.dump()) 
 
        # prints 
        # ['True', 'True', 'False'] 
        # - items: ['True', 'True', 'False'] 
        # - type: 'bool' 
    &quot;&quot;&quot;</span>
    <span class="s1">intExpr = intExpr </span><span class="s2">or </span><span class="s1">int_expr</span>
    <span class="s1">array_expr = Forward()</span>

    <span class="s2">def </span><span class="s1">count_field_parse_action(s</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s2">nonlocal </span><span class="s1">array_expr</span>
        <span class="s1">n = t[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">array_expr &lt;&lt;= (expr * n) </span><span class="s2">if </span><span class="s1">n </span><span class="s2">else </span><span class="s1">Empty()</span>
        <span class="s0"># clear list contents, but keep any named results</span>
        <span class="s2">del </span><span class="s1">t[:]</span>

    <span class="s2">if </span><span class="s1">intExpr </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">intExpr = Word(nums).set_parse_action(</span><span class="s2">lambda </span><span class="s1">t: int(t[</span><span class="s5">0</span><span class="s1">]))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">intExpr = intExpr.copy()</span>
    <span class="s1">intExpr.set_name(</span><span class="s3">&quot;arrayLen&quot;</span><span class="s1">)</span>
    <span class="s1">intExpr.add_parse_action(count_field_parse_action</span><span class="s2">, </span><span class="s1">call_during_try=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">(intExpr + array_expr).set_name(</span><span class="s3">&quot;(len) &quot; </span><span class="s1">+ str(expr) + </span><span class="s3">&quot;...&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">match_previous_literal(expr: ParserElement) -&gt; ParserElement:</span>
    <span class="s4">&quot;&quot;&quot;Helper to define an expression that is indirectly defined from 
    the tokens matched in a previous expression, that is, it looks for 
    a 'repeat' of a previous expression.  For example:: 
 
        first = Word(nums) 
        second = match_previous_literal(first) 
        match_expr = first + &quot;:&quot; + second 
 
    will match ``&quot;1:1&quot;``, but not ``&quot;1:2&quot;``.  Because this 
    matches a previous literal, will also match the leading 
    ``&quot;1:1&quot;`` in ``&quot;1:10&quot;``. If this is not desired, use 
    :class:`match_previous_expr`. Do *not* use with packrat parsing 
    enabled. 
    &quot;&quot;&quot;</span>
    <span class="s1">rep = Forward()</span>

    <span class="s2">def </span><span class="s1">copy_token_to_repeater(s</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s2">if </span><span class="s1">t:</span>
            <span class="s2">if </span><span class="s1">len(t) == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">rep &lt;&lt; t[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s0"># flatten t tokens</span>
                <span class="s1">tflat = _flatten(t.as_list())</span>
                <span class="s1">rep &lt;&lt; And(Literal(tt) </span><span class="s2">for </span><span class="s1">tt </span><span class="s2">in </span><span class="s1">tflat)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">rep &lt;&lt; Empty()</span>

    <span class="s1">expr.add_parse_action(copy_token_to_repeater</span><span class="s2">, </span><span class="s1">callDuringTry=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">rep.set_name(</span><span class="s3">&quot;(prev) &quot; </span><span class="s1">+ str(expr))</span>
    <span class="s2">return </span><span class="s1">rep</span>


<span class="s2">def </span><span class="s1">match_previous_expr(expr: ParserElement) -&gt; ParserElement:</span>
    <span class="s4">&quot;&quot;&quot;Helper to define an expression that is indirectly defined from 
    the tokens matched in a previous expression, that is, it looks for 
    a 'repeat' of a previous expression.  For example:: 
 
        first = Word(nums) 
        second = match_previous_expr(first) 
        match_expr = first + &quot;:&quot; + second 
 
    will match ``&quot;1:1&quot;``, but not ``&quot;1:2&quot;``.  Because this 
    matches by expressions, will *not* match the leading ``&quot;1:1&quot;`` 
    in ``&quot;1:10&quot;``; the expressions are evaluated first, and then 
    compared, so ``&quot;1&quot;`` is compared with ``&quot;10&quot;``. Do *not* use 
    with packrat parsing enabled. 
    &quot;&quot;&quot;</span>
    <span class="s1">rep = Forward()</span>
    <span class="s1">e2 = expr.copy()</span>
    <span class="s1">rep &lt;&lt;= e2</span>

    <span class="s2">def </span><span class="s1">copy_token_to_repeater(s</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">matchTokens = _flatten(t.as_list())</span>

        <span class="s2">def </span><span class="s1">must_match_these_tokens(s</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">t):</span>
            <span class="s1">theseTokens = _flatten(t.as_list())</span>
            <span class="s2">if </span><span class="s1">theseTokens != matchTokens:</span>
                <span class="s2">raise </span><span class="s1">ParseException(</span>
                    <span class="s1">s</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s3">&quot;Expected {}, found{}&quot;</span><span class="s1">.format(matchTokens</span><span class="s2">, </span><span class="s1">theseTokens)</span>
                <span class="s1">)</span>

        <span class="s1">rep.set_parse_action(must_match_these_tokens</span><span class="s2">, </span><span class="s1">callDuringTry=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s1">expr.add_parse_action(copy_token_to_repeater</span><span class="s2">, </span><span class="s1">callDuringTry=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">rep.set_name(</span><span class="s3">&quot;(prev) &quot; </span><span class="s1">+ str(expr))</span>
    <span class="s2">return </span><span class="s1">rep</span>


<span class="s2">def </span><span class="s1">one_of(</span>
    <span class="s1">strs: Union[typing.Iterable[str]</span><span class="s2">, </span><span class="s1">str]</span><span class="s2">,</span>
    <span class="s1">caseless: bool = </span><span class="s2">False,</span>
    <span class="s1">use_regex: bool = </span><span class="s2">True,</span>
    <span class="s1">as_keyword: bool = </span><span class="s2">False,</span>
    <span class="s1">*</span><span class="s2">,</span>
    <span class="s1">useRegex: bool = </span><span class="s2">True,</span>
    <span class="s1">asKeyword: bool = </span><span class="s2">False,</span>
<span class="s1">) -&gt; ParserElement:</span>
    <span class="s4">&quot;&quot;&quot;Helper to quickly define a set of alternative :class:`Literal` s, 
    and makes sure to do longest-first testing when there is a conflict, 
    regardless of the input order, but returns 
    a :class:`MatchFirst` for best performance. 
 
    Parameters: 
 
    - ``strs`` - a string of space-delimited literals, or a collection of 
      string literals 
    - ``caseless`` - treat all literals as caseless - (default= ``False``) 
    - ``use_regex`` - as an optimization, will 
      generate a :class:`Regex` object; otherwise, will generate 
      a :class:`MatchFirst` object (if ``caseless=True`` or ``asKeyword=True``, or if 
      creating a :class:`Regex` raises an exception) - (default= ``True``) 
    - ``as_keyword`` - enforce :class:`Keyword`-style matching on the 
      generated expressions - (default= ``False``) 
    - ``asKeyword`` and ``useRegex`` are retained for pre-PEP8 compatibility, 
      but will be removed in a future release 
 
    Example:: 
 
        comp_oper = one_of(&quot;&lt; = &gt; &lt;= &gt;= !=&quot;) 
        var = Word(alphas) 
        number = Word(nums) 
        term = var | number 
        comparison_expr = term + comp_oper + term 
        print(comparison_expr.search_string(&quot;B = 12  AA=23 B&lt;=AA AA&gt;12&quot;)) 
 
    prints:: 
 
        [['B', '=', '12'], ['AA', '=', '23'], ['B', '&lt;=', 'AA'], ['AA', '&gt;', '12']] 
    &quot;&quot;&quot;</span>
    <span class="s1">asKeyword = asKeyword </span><span class="s2">or </span><span class="s1">as_keyword</span>
    <span class="s1">useRegex = useRegex </span><span class="s2">and </span><span class="s1">use_regex</span>

    <span class="s2">if </span><span class="s1">(</span>
        <span class="s1">isinstance(caseless</span><span class="s2">, </span><span class="s1">str_type)</span>
        <span class="s2">and </span><span class="s1">__diag__.warn_on_multiple_string_args_to_oneof</span>
    <span class="s1">):</span>
        <span class="s1">warnings.warn(</span>
            <span class="s3">&quot;More than one string argument passed to one_of, pass&quot;</span>
            <span class="s3">&quot; choices as a list or space-delimited string&quot;</span><span class="s2">,</span>
            <span class="s1">stacklevel=</span><span class="s5">2</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">if </span><span class="s1">caseless:</span>
        <span class="s1">isequal = </span><span class="s2">lambda </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b: a.upper() == b.upper()</span>
        <span class="s1">masks = </span><span class="s2">lambda </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b: b.upper().startswith(a.upper())</span>
        <span class="s1">parseElementClass = CaselessKeyword </span><span class="s2">if </span><span class="s1">asKeyword </span><span class="s2">else </span><span class="s1">CaselessLiteral</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">isequal = </span><span class="s2">lambda </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b: a == b</span>
        <span class="s1">masks = </span><span class="s2">lambda </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b: b.startswith(a)</span>
        <span class="s1">parseElementClass = Keyword </span><span class="s2">if </span><span class="s1">asKeyword </span><span class="s2">else </span><span class="s1">Literal</span>

    <span class="s1">symbols: List[str] = []</span>
    <span class="s2">if </span><span class="s1">isinstance(strs</span><span class="s2">, </span><span class="s1">str_type):</span>
        <span class="s1">symbols = strs.split()</span>
    <span class="s2">elif </span><span class="s1">isinstance(strs</span><span class="s2">, </span><span class="s1">Iterable):</span>
        <span class="s1">symbols = list(strs)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Invalid argument to one_of, expected string or iterable&quot;</span><span class="s1">)</span>
    <span class="s2">if not </span><span class="s1">symbols:</span>
        <span class="s2">return </span><span class="s1">NoMatch()</span>

    <span class="s0"># reorder given symbols to take care to avoid masking longer choices with shorter ones</span>
    <span class="s0"># (but only if the given symbols are not just single characters)</span>
    <span class="s2">if </span><span class="s1">any(len(sym) &gt; </span><span class="s5">1 </span><span class="s2">for </span><span class="s1">sym </span><span class="s2">in </span><span class="s1">symbols):</span>
        <span class="s1">i = </span><span class="s5">0</span>
        <span class="s2">while </span><span class="s1">i &lt; len(symbols) - </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">cur = symbols[i]</span>
            <span class="s2">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">other </span><span class="s2">in </span><span class="s1">enumerate(symbols[i + </span><span class="s5">1 </span><span class="s1">:]):</span>
                <span class="s2">if </span><span class="s1">isequal(other</span><span class="s2">, </span><span class="s1">cur):</span>
                    <span class="s2">del </span><span class="s1">symbols[i + j + </span><span class="s5">1</span><span class="s1">]</span>
                    <span class="s2">break</span>
                <span class="s2">elif </span><span class="s1">masks(cur</span><span class="s2">, </span><span class="s1">other):</span>
                    <span class="s2">del </span><span class="s1">symbols[i + j + </span><span class="s5">1</span><span class="s1">]</span>
                    <span class="s1">symbols.insert(i</span><span class="s2">, </span><span class="s1">other)</span>
                    <span class="s2">break</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">i += </span><span class="s5">1</span>

    <span class="s2">if </span><span class="s1">useRegex:</span>
        <span class="s1">re_flags: int = re.IGNORECASE </span><span class="s2">if </span><span class="s1">caseless </span><span class="s2">else </span><span class="s5">0</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">all(len(sym) == </span><span class="s5">1 </span><span class="s2">for </span><span class="s1">sym </span><span class="s2">in </span><span class="s1">symbols):</span>
                <span class="s0"># symbols are just single characters, create range regex pattern</span>
                <span class="s1">patt = </span><span class="s3">&quot;[{}]&quot;</span><span class="s1">.format(</span>
                    <span class="s3">&quot;&quot;</span><span class="s1">.join(_escape_regex_range_chars(sym) </span><span class="s2">for </span><span class="s1">sym </span><span class="s2">in </span><span class="s1">symbols)</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">patt = </span><span class="s3">&quot;|&quot;</span><span class="s1">.join(re.escape(sym) </span><span class="s2">for </span><span class="s1">sym </span><span class="s2">in </span><span class="s1">symbols)</span>

            <span class="s0"># wrap with \b word break markers if defining as keywords</span>
            <span class="s2">if </span><span class="s1">asKeyword:</span>
                <span class="s1">patt = </span><span class="s3">r&quot;\b(?:{})\b&quot;</span><span class="s1">.format(patt)</span>

            <span class="s1">ret = Regex(patt</span><span class="s2">, </span><span class="s1">flags=re_flags).set_name(</span><span class="s3">&quot; | &quot;</span><span class="s1">.join(symbols))</span>

            <span class="s2">if </span><span class="s1">caseless:</span>
                <span class="s0"># add parse action to return symbols as specified, not in random</span>
                <span class="s0"># casing as found in input string</span>
                <span class="s1">symbol_map = {sym.lower(): sym </span><span class="s2">for </span><span class="s1">sym </span><span class="s2">in </span><span class="s1">symbols}</span>
                <span class="s1">ret.add_parse_action(</span><span class="s2">lambda </span><span class="s1">s</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">t: symbol_map[t[</span><span class="s5">0</span><span class="s1">].lower()])</span>

            <span class="s2">return </span><span class="s1">ret</span>

        <span class="s2">except </span><span class="s1">re.error:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s3">&quot;Exception creating Regex for one_of, building MatchFirst&quot;</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s5">2</span>
            <span class="s1">)</span>

    <span class="s0"># last resort, just use MatchFirst</span>
    <span class="s2">return </span><span class="s1">MatchFirst(parseElementClass(sym) </span><span class="s2">for </span><span class="s1">sym </span><span class="s2">in </span><span class="s1">symbols).set_name(</span>
        <span class="s3">&quot; | &quot;</span><span class="s1">.join(symbols)</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">dict_of(key: ParserElement</span><span class="s2">, </span><span class="s1">value: ParserElement) -&gt; ParserElement:</span>
    <span class="s4">&quot;&quot;&quot;Helper to easily and clearly define a dictionary by specifying 
    the respective patterns for the key and value.  Takes care of 
    defining the :class:`Dict`, :class:`ZeroOrMore`, and 
    :class:`Group` tokens in the proper order.  The key pattern 
    can include delimiting markers or punctuation, as long as they are 
    suppressed, thereby leaving the significant key text.  The value 
    pattern can include named results, so that the :class:`Dict` results 
    can include named token fields. 
 
    Example:: 
 
        text = &quot;shape: SQUARE posn: upper left color: light blue texture: burlap&quot; 
        attr_expr = (label + Suppress(':') + OneOrMore(data_word, stop_on=label).set_parse_action(' '.join)) 
        print(attr_expr[1, ...].parse_string(text).dump()) 
 
        attr_label = label 
        attr_value = Suppress(':') + OneOrMore(data_word, stop_on=label).set_parse_action(' '.join) 
 
        # similar to Dict, but simpler call format 
        result = dict_of(attr_label, attr_value).parse_string(text) 
        print(result.dump()) 
        print(result['shape']) 
        print(result.shape)  # object attribute access works too 
        print(result.as_dict()) 
 
    prints:: 
 
        [['shape', 'SQUARE'], ['posn', 'upper left'], ['color', 'light blue'], ['texture', 'burlap']] 
        - color: 'light blue' 
        - posn: 'upper left' 
        - shape: 'SQUARE' 
        - texture: 'burlap' 
        SQUARE 
        SQUARE 
        {'color': 'light blue', 'shape': 'SQUARE', 'posn': 'upper left', 'texture': 'burlap'} 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">Dict(OneOrMore(Group(key + value)))</span>


<span class="s2">def </span><span class="s1">original_text_for(</span>
    <span class="s1">expr: ParserElement</span><span class="s2">, </span><span class="s1">as_string: bool = </span><span class="s2">True, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">asString: bool = </span><span class="s2">True</span>
<span class="s1">) -&gt; ParserElement:</span>
    <span class="s4">&quot;&quot;&quot;Helper to return the original, untokenized text for a given 
    expression.  Useful to restore the parsed fields of an HTML start 
    tag into the raw tag text itself, or to revert separate tokens with 
    intervening whitespace back to the original matching input text. By 
    default, returns astring containing the original parsed text. 
 
    If the optional ``as_string`` argument is passed as 
    ``False``, then the return value is 
    a :class:`ParseResults` containing any results names that 
    were originally matched, and a single token containing the original 
    matched text from the input string.  So if the expression passed to 
    :class:`original_text_for` contains expressions with defined 
    results names, you must set ``as_string`` to ``False`` if you 
    want to preserve those results name values. 
 
    The ``asString`` pre-PEP8 argument is retained for compatibility, 
    but will be removed in a future release. 
 
    Example:: 
 
        src = &quot;this is test &lt;b&gt; bold &lt;i&gt;text&lt;/i&gt; &lt;/b&gt; normal text &quot; 
        for tag in (&quot;b&quot;, &quot;i&quot;): 
            opener, closer = make_html_tags(tag) 
            patt = original_text_for(opener + SkipTo(closer) + closer) 
            print(patt.search_string(src)[0]) 
 
    prints:: 
 
        ['&lt;b&gt; bold &lt;i&gt;text&lt;/i&gt; &lt;/b&gt;'] 
        ['&lt;i&gt;text&lt;/i&gt;'] 
    &quot;&quot;&quot;</span>
    <span class="s1">asString = asString </span><span class="s2">and </span><span class="s1">as_string</span>

    <span class="s1">locMarker = Empty().set_parse_action(</span><span class="s2">lambda </span><span class="s1">s</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">t: loc)</span>
    <span class="s1">endlocMarker = locMarker.copy()</span>
    <span class="s1">endlocMarker.callPreparse = </span><span class="s2">False</span>
    <span class="s1">matchExpr = locMarker(</span><span class="s3">&quot;_original_start&quot;</span><span class="s1">) + expr + endlocMarker(</span><span class="s3">&quot;_original_end&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">asString:</span>
        <span class="s1">extractText = </span><span class="s2">lambda </span><span class="s1">s</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">t: s[t._original_start : t._original_end]</span>
    <span class="s2">else</span><span class="s1">:</span>

        <span class="s2">def </span><span class="s1">extractText(s</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">t):</span>
            <span class="s1">t[:] = [s[t.pop(</span><span class="s3">&quot;_original_start&quot;</span><span class="s1">) : t.pop(</span><span class="s3">&quot;_original_end&quot;</span><span class="s1">)]]</span>

    <span class="s1">matchExpr.set_parse_action(extractText)</span>
    <span class="s1">matchExpr.ignoreExprs = expr.ignoreExprs</span>
    <span class="s1">matchExpr.suppress_warning(Diagnostics.warn_ungrouped_named_tokens_in_collection)</span>
    <span class="s2">return </span><span class="s1">matchExpr</span>


<span class="s2">def </span><span class="s1">ungroup(expr: ParserElement) -&gt; ParserElement:</span>
    <span class="s4">&quot;&quot;&quot;Helper to undo pyparsing's default grouping of And expressions, 
    even if all but one are non-empty. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">TokenConverter(expr).add_parse_action(</span><span class="s2">lambda </span><span class="s1">t: t[</span><span class="s5">0</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">locatedExpr(expr: ParserElement) -&gt; ParserElement:</span>
    <span class="s4">&quot;&quot;&quot; 
    (DEPRECATED - future code should use the Located class) 
    Helper to decorate a returned token with its starting and ending 
    locations in the input string. 
 
    This helper adds the following results names: 
 
    - ``locn_start`` - location where matched expression begins 
    - ``locn_end`` - location where matched expression ends 
    - ``value`` - the actual parsed results 
 
    Be careful if the input text contains ``&lt;TAB&gt;`` characters, you 
    may want to call :class:`ParserElement.parseWithTabs` 
 
    Example:: 
 
        wd = Word(alphas) 
        for match in locatedExpr(wd).searchString(&quot;ljsdf123lksdjjf123lkkjj1222&quot;): 
            print(match) 
 
    prints:: 
 
        [[0, 'ljsdf', 5]] 
        [[8, 'lksdjjf', 15]] 
        [[18, 'lkkjj', 23]] 
    &quot;&quot;&quot;</span>
    <span class="s1">locator = Empty().set_parse_action(</span><span class="s2">lambda </span><span class="s1">ss</span><span class="s2">, </span><span class="s1">ll</span><span class="s2">, </span><span class="s1">tt: ll)</span>
    <span class="s2">return </span><span class="s1">Group(</span>
        <span class="s1">locator(</span><span class="s3">&quot;locn_start&quot;</span><span class="s1">)</span>
        <span class="s1">+ expr(</span><span class="s3">&quot;value&quot;</span><span class="s1">)</span>
        <span class="s1">+ locator.copy().leaveWhitespace()(</span><span class="s3">&quot;locn_end&quot;</span><span class="s1">)</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">nested_expr(</span>
    <span class="s1">opener: Union[str</span><span class="s2">, </span><span class="s1">ParserElement] = </span><span class="s3">&quot;(&quot;</span><span class="s2">,</span>
    <span class="s1">closer: Union[str</span><span class="s2">, </span><span class="s1">ParserElement] = </span><span class="s3">&quot;)&quot;</span><span class="s2">,</span>
    <span class="s1">content: typing.Optional[ParserElement] = </span><span class="s2">None,</span>
    <span class="s1">ignore_expr: ParserElement = quoted_string()</span><span class="s2">,</span>
    <span class="s1">*</span><span class="s2">,</span>
    <span class="s1">ignoreExpr: ParserElement = quoted_string()</span><span class="s2">,</span>
<span class="s1">) -&gt; ParserElement:</span>
    <span class="s4">&quot;&quot;&quot;Helper method for defining nested lists enclosed in opening and 
    closing delimiters (``&quot;(&quot;`` and ``&quot;)&quot;`` are the default). 
 
    Parameters: 
    - ``opener`` - opening character for a nested list 
      (default= ``&quot;(&quot;``); can also be a pyparsing expression 
    - ``closer`` - closing character for a nested list 
      (default= ``&quot;)&quot;``); can also be a pyparsing expression 
    - ``content`` - expression for items within the nested lists 
      (default= ``None``) 
    - ``ignore_expr`` - expression for ignoring opening and closing delimiters 
      (default= :class:`quoted_string`) 
    - ``ignoreExpr`` - this pre-PEP8 argument is retained for compatibility 
      but will be removed in a future release 
 
    If an expression is not provided for the content argument, the 
    nested expression will capture all whitespace-delimited content 
    between delimiters as a list of separate values. 
 
    Use the ``ignore_expr`` argument to define expressions that may 
    contain opening or closing characters that should not be treated as 
    opening or closing characters for nesting, such as quoted_string or 
    a comment expression.  Specify multiple expressions using an 
    :class:`Or` or :class:`MatchFirst`. The default is 
    :class:`quoted_string`, but if no expressions are to be ignored, then 
    pass ``None`` for this argument. 
 
    Example:: 
 
        data_type = one_of(&quot;void int short long char float double&quot;) 
        decl_data_type = Combine(data_type + Opt(Word('*'))) 
        ident = Word(alphas+'_', alphanums+'_') 
        number = pyparsing_common.number 
        arg = Group(decl_data_type + ident) 
        LPAR, RPAR = map(Suppress, &quot;()&quot;) 
 
        code_body = nested_expr('{', '}', ignore_expr=(quoted_string | c_style_comment)) 
 
        c_function = (decl_data_type(&quot;type&quot;) 
                      + ident(&quot;name&quot;) 
                      + LPAR + Opt(delimited_list(arg), [])(&quot;args&quot;) + RPAR 
                      + code_body(&quot;body&quot;)) 
        c_function.ignore(c_style_comment) 
 
        source_code = ''' 
            int is_odd(int x) { 
                return (x%2); 
            } 
 
            int dec_to_hex(char hchar) { 
                if (hchar &gt;= '0' &amp;&amp; hchar &lt;= '9') { 
                    return (ord(hchar)-ord('0')); 
                } else { 
                    return (10+ord(hchar)-ord('A')); 
                } 
            } 
        ''' 
        for func in c_function.search_string(source_code): 
            print(&quot;%(name)s (%(type)s) args: %(args)s&quot; % func) 
 
 
    prints:: 
 
        is_odd (int) args: [['int', 'x']] 
        dec_to_hex (int) args: [['char', 'hchar']] 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">ignoreExpr != ignore_expr:</span>
        <span class="s1">ignoreExpr = ignore_expr </span><span class="s2">if </span><span class="s1">ignoreExpr == quoted_string() </span><span class="s2">else </span><span class="s1">ignoreExpr</span>
    <span class="s2">if </span><span class="s1">opener == closer:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;opening and closing strings cannot be the same&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">content </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">isinstance(opener</span><span class="s2">, </span><span class="s1">str_type) </span><span class="s2">and </span><span class="s1">isinstance(closer</span><span class="s2">, </span><span class="s1">str_type):</span>
            <span class="s2">if </span><span class="s1">len(opener) == </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">len(closer) == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">ignoreExpr </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">content = Combine(</span>
                        <span class="s1">OneOrMore(</span>
                            <span class="s1">~ignoreExpr</span>
                            <span class="s1">+ CharsNotIn(</span>
                                <span class="s1">opener + closer + ParserElement.DEFAULT_WHITE_CHARS</span><span class="s2">,</span>
                                <span class="s1">exact=</span><span class="s5">1</span><span class="s2">,</span>
                            <span class="s1">)</span>
                        <span class="s1">)</span>
                    <span class="s1">).set_parse_action(</span><span class="s2">lambda </span><span class="s1">t: t[</span><span class="s5">0</span><span class="s1">].strip())</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">content = empty.copy() + CharsNotIn(</span>
                        <span class="s1">opener + closer + ParserElement.DEFAULT_WHITE_CHARS</span>
                    <span class="s1">).set_parse_action(</span><span class="s2">lambda </span><span class="s1">t: t[</span><span class="s5">0</span><span class="s1">].strip())</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">ignoreExpr </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">content = Combine(</span>
                        <span class="s1">OneOrMore(</span>
                            <span class="s1">~ignoreExpr</span>
                            <span class="s1">+ ~Literal(opener)</span>
                            <span class="s1">+ ~Literal(closer)</span>
                            <span class="s1">+ CharsNotIn(ParserElement.DEFAULT_WHITE_CHARS</span><span class="s2">, </span><span class="s1">exact=</span><span class="s5">1</span><span class="s1">)</span>
                        <span class="s1">)</span>
                    <span class="s1">).set_parse_action(</span><span class="s2">lambda </span><span class="s1">t: t[</span><span class="s5">0</span><span class="s1">].strip())</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">content = Combine(</span>
                        <span class="s1">OneOrMore(</span>
                            <span class="s1">~Literal(opener)</span>
                            <span class="s1">+ ~Literal(closer)</span>
                            <span class="s1">+ CharsNotIn(ParserElement.DEFAULT_WHITE_CHARS</span><span class="s2">, </span><span class="s1">exact=</span><span class="s5">1</span><span class="s1">)</span>
                        <span class="s1">)</span>
                    <span class="s1">).set_parse_action(</span><span class="s2">lambda </span><span class="s1">t: t[</span><span class="s5">0</span><span class="s1">].strip())</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;opening and closing arguments must be strings if no content expression is given&quot;</span>
            <span class="s1">)</span>
    <span class="s1">ret = Forward()</span>
    <span class="s2">if </span><span class="s1">ignoreExpr </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">ret &lt;&lt;= Group(</span>
            <span class="s1">Suppress(opener) + ZeroOrMore(ignoreExpr | ret | content) + Suppress(closer)</span>
        <span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">ret &lt;&lt;= Group(Suppress(opener) + ZeroOrMore(ret | content) + Suppress(closer))</span>
    <span class="s1">ret.set_name(</span><span class="s3">&quot;nested %s%s expression&quot; </span><span class="s1">% (opener</span><span class="s2">, </span><span class="s1">closer))</span>
    <span class="s2">return </span><span class="s1">ret</span>


<span class="s2">def </span><span class="s1">_makeTags(tagStr</span><span class="s2">, </span><span class="s1">xml</span><span class="s2">, </span><span class="s1">suppress_LT=Suppress(</span><span class="s3">&quot;&lt;&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">suppress_GT=Suppress(</span><span class="s3">&quot;&gt;&quot;</span><span class="s1">)):</span>
    <span class="s4">&quot;&quot;&quot;Internal helper to construct opening and closing tag expressions, given a tag name&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(tagStr</span><span class="s2">, </span><span class="s1">str_type):</span>
        <span class="s1">resname = tagStr</span>
        <span class="s1">tagStr = Keyword(tagStr</span><span class="s2">, </span><span class="s1">caseless=</span><span class="s2">not </span><span class="s1">xml)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">resname = tagStr.name</span>

    <span class="s1">tagAttrName = Word(alphas</span><span class="s2">, </span><span class="s1">alphanums + </span><span class="s3">&quot;_-:&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">xml:</span>
        <span class="s1">tagAttrValue = dbl_quoted_string.copy().set_parse_action(remove_quotes)</span>
        <span class="s1">openTag = (</span>
            <span class="s1">suppress_LT</span>
            <span class="s1">+ tagStr(</span><span class="s3">&quot;tag&quot;</span><span class="s1">)</span>
            <span class="s1">+ Dict(ZeroOrMore(Group(tagAttrName + Suppress(</span><span class="s3">&quot;=&quot;</span><span class="s1">) + tagAttrValue)))</span>
            <span class="s1">+ Opt(</span><span class="s3">&quot;/&quot;</span><span class="s2">, </span><span class="s1">default=[</span><span class="s2">False</span><span class="s1">])(</span><span class="s3">&quot;empty&quot;</span><span class="s1">).set_parse_action(</span>
                <span class="s2">lambda </span><span class="s1">s</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">t: t[</span><span class="s5">0</span><span class="s1">] == </span><span class="s3">&quot;/&quot;</span>
            <span class="s1">)</span>
            <span class="s1">+ suppress_GT</span>
        <span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">tagAttrValue = quoted_string.copy().set_parse_action(remove_quotes) | Word(</span>
            <span class="s1">printables</span><span class="s2">, </span><span class="s1">exclude_chars=</span><span class="s3">&quot;&gt;&quot;</span>
        <span class="s1">)</span>
        <span class="s1">openTag = (</span>
            <span class="s1">suppress_LT</span>
            <span class="s1">+ tagStr(</span><span class="s3">&quot;tag&quot;</span><span class="s1">)</span>
            <span class="s1">+ Dict(</span>
                <span class="s1">ZeroOrMore(</span>
                    <span class="s1">Group(</span>
                        <span class="s1">tagAttrName.set_parse_action(</span><span class="s2">lambda </span><span class="s1">t: t[</span><span class="s5">0</span><span class="s1">].lower())</span>
                        <span class="s1">+ Opt(Suppress(</span><span class="s3">&quot;=&quot;</span><span class="s1">) + tagAttrValue)</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s1">+ Opt(</span><span class="s3">&quot;/&quot;</span><span class="s2">, </span><span class="s1">default=[</span><span class="s2">False</span><span class="s1">])(</span><span class="s3">&quot;empty&quot;</span><span class="s1">).set_parse_action(</span>
                <span class="s2">lambda </span><span class="s1">s</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">t: t[</span><span class="s5">0</span><span class="s1">] == </span><span class="s3">&quot;/&quot;</span>
            <span class="s1">)</span>
            <span class="s1">+ suppress_GT</span>
        <span class="s1">)</span>
    <span class="s1">closeTag = Combine(Literal(</span><span class="s3">&quot;&lt;/&quot;</span><span class="s1">) + tagStr + </span><span class="s3">&quot;&gt;&quot;</span><span class="s2">, </span><span class="s1">adjacent=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s1">openTag.set_name(</span><span class="s3">&quot;&lt;%s&gt;&quot; </span><span class="s1">% resname)</span>
    <span class="s0"># add start&lt;tagname&gt; results name in parse action now that ungrouped names are not reported at two levels</span>
    <span class="s1">openTag.add_parse_action(</span>
        <span class="s2">lambda </span><span class="s1">t: t.__setitem__(</span>
            <span class="s3">&quot;start&quot; </span><span class="s1">+ </span><span class="s3">&quot;&quot;</span><span class="s1">.join(resname.replace(</span><span class="s3">&quot;:&quot;</span><span class="s2">, </span><span class="s3">&quot; &quot;</span><span class="s1">).title().split())</span><span class="s2">, </span><span class="s1">t.copy()</span>
        <span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">closeTag = closeTag(</span>
        <span class="s3">&quot;end&quot; </span><span class="s1">+ </span><span class="s3">&quot;&quot;</span><span class="s1">.join(resname.replace(</span><span class="s3">&quot;:&quot;</span><span class="s2">, </span><span class="s3">&quot; &quot;</span><span class="s1">).title().split())</span>
    <span class="s1">).set_name(</span><span class="s3">&quot;&lt;/%s&gt;&quot; </span><span class="s1">% resname)</span>
    <span class="s1">openTag.tag = resname</span>
    <span class="s1">closeTag.tag = resname</span>
    <span class="s1">openTag.tag_body = SkipTo(closeTag())</span>
    <span class="s2">return </span><span class="s1">openTag</span><span class="s2">, </span><span class="s1">closeTag</span>


<span class="s2">def </span><span class="s1">make_html_tags(</span>
    <span class="s1">tag_str: Union[str</span><span class="s2">, </span><span class="s1">ParserElement]</span>
<span class="s1">) -&gt; Tuple[ParserElement</span><span class="s2">, </span><span class="s1">ParserElement]:</span>
    <span class="s4">&quot;&quot;&quot;Helper to construct opening and closing tag expressions for HTML, 
    given a tag name. Matches tags in either upper or lower case, 
    attributes with namespaces and with quoted or unquoted values. 
 
    Example:: 
 
        text = '&lt;td&gt;More info at the &lt;a href=&quot;https://github.com/pyparsing/pyparsing/wiki&quot;&gt;pyparsing&lt;/a&gt; wiki page&lt;/td&gt;' 
        # make_html_tags returns pyparsing expressions for the opening and 
        # closing tags as a 2-tuple 
        a, a_end = make_html_tags(&quot;A&quot;) 
        link_expr = a + SkipTo(a_end)(&quot;link_text&quot;) + a_end 
 
        for link in link_expr.search_string(text): 
            # attributes in the &lt;A&gt; tag (like &quot;href&quot; shown here) are 
            # also accessible as named results 
            print(link.link_text, '-&gt;', link.href) 
 
    prints:: 
 
        pyparsing -&gt; https://github.com/pyparsing/pyparsing/wiki 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_makeTags(tag_str</span><span class="s2">, False</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">make_xml_tags(</span>
    <span class="s1">tag_str: Union[str</span><span class="s2">, </span><span class="s1">ParserElement]</span>
<span class="s1">) -&gt; Tuple[ParserElement</span><span class="s2">, </span><span class="s1">ParserElement]:</span>
    <span class="s4">&quot;&quot;&quot;Helper to construct opening and closing tag expressions for XML, 
    given a tag name. Matches tags only in the given upper/lower case. 
 
    Example: similar to :class:`make_html_tags` 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_makeTags(tag_str</span><span class="s2">, True</span><span class="s1">)</span>


<span class="s1">any_open_tag: ParserElement</span>
<span class="s1">any_close_tag: ParserElement</span>
<span class="s1">any_open_tag</span><span class="s2">, </span><span class="s1">any_close_tag = make_html_tags(</span>
    <span class="s1">Word(alphas</span><span class="s2">, </span><span class="s1">alphanums + </span><span class="s3">&quot;_:&quot;</span><span class="s1">).set_name(</span><span class="s3">&quot;any tag&quot;</span><span class="s1">)</span>
<span class="s1">)</span>

<span class="s1">_htmlEntityMap = {k.rstrip(</span><span class="s3">&quot;;&quot;</span><span class="s1">): v </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">html.entities.html5.items()}</span>
<span class="s1">common_html_entity = Regex(</span><span class="s3">&quot;&amp;(?P&lt;entity&gt;&quot; </span><span class="s1">+ </span><span class="s3">&quot;|&quot;</span><span class="s1">.join(_htmlEntityMap) + </span><span class="s3">&quot;);&quot;</span><span class="s1">).set_name(</span>
    <span class="s3">&quot;common HTML entity&quot;</span>
<span class="s1">)</span>


<span class="s2">def </span><span class="s1">replace_html_entity(t):</span>
    <span class="s4">&quot;&quot;&quot;Helper parser action to replace common HTML entities with their special characters&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_htmlEntityMap.get(t.entity)</span>


<span class="s2">class </span><span class="s1">OpAssoc(Enum):</span>
    <span class="s1">LEFT = </span><span class="s5">1</span>
    <span class="s1">RIGHT = </span><span class="s5">2</span>


<span class="s1">InfixNotationOperatorArgType = Union[</span>
    <span class="s1">ParserElement</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">Tuple[Union[ParserElement</span><span class="s2">, </span><span class="s1">str]</span><span class="s2">, </span><span class="s1">Union[ParserElement</span><span class="s2">, </span><span class="s1">str]]</span>
<span class="s1">]</span>
<span class="s1">InfixNotationOperatorSpec = Union[</span>
    <span class="s1">Tuple[</span>
        <span class="s1">InfixNotationOperatorArgType</span><span class="s2">,</span>
        <span class="s1">int</span><span class="s2">,</span>
        <span class="s1">OpAssoc</span><span class="s2">,</span>
        <span class="s1">typing.Optional[ParseAction]</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">Tuple[</span>
        <span class="s1">InfixNotationOperatorArgType</span><span class="s2">,</span>
        <span class="s1">int</span><span class="s2">,</span>
        <span class="s1">OpAssoc</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">]</span>


<span class="s2">def </span><span class="s1">infix_notation(</span>
    <span class="s1">base_expr: ParserElement</span><span class="s2">,</span>
    <span class="s1">op_list: List[InfixNotationOperatorSpec]</span><span class="s2">,</span>
    <span class="s1">lpar: Union[str</span><span class="s2">, </span><span class="s1">ParserElement] = Suppress(</span><span class="s3">&quot;(&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">rpar: Union[str</span><span class="s2">, </span><span class="s1">ParserElement] = Suppress(</span><span class="s3">&quot;)&quot;</span><span class="s1">)</span><span class="s2">,</span>
<span class="s1">) -&gt; ParserElement:</span>
    <span class="s4">&quot;&quot;&quot;Helper method for constructing grammars of expressions made up of 
    operators working in a precedence hierarchy.  Operators may be unary 
    or binary, left- or right-associative.  Parse actions can also be 
    attached to operator expressions. The generated parser will also 
    recognize the use of parentheses to override operator precedences 
    (see example below). 
 
    Note: if you define a deep operator list, you may see performance 
    issues when using infix_notation. See 
    :class:`ParserElement.enable_packrat` for a mechanism to potentially 
    improve your parser performance. 
 
    Parameters: 
    - ``base_expr`` - expression representing the most basic operand to 
      be used in the expression 
    - ``op_list`` - list of tuples, one for each operator precedence level 
      in the expression grammar; each tuple is of the form ``(op_expr, 
      num_operands, right_left_assoc, (optional)parse_action)``, where: 
 
      - ``op_expr`` is the pyparsing expression for the operator; may also 
        be a string, which will be converted to a Literal; if ``num_operands`` 
        is 3, ``op_expr`` is a tuple of two expressions, for the two 
        operators separating the 3 terms 
      - ``num_operands`` is the number of terms for this operator (must be 1, 
        2, or 3) 
      - ``right_left_assoc`` is the indicator whether the operator is right 
        or left associative, using the pyparsing-defined constants 
        ``OpAssoc.RIGHT`` and ``OpAssoc.LEFT``. 
      - ``parse_action`` is the parse action to be associated with 
        expressions matching this operator expression (the parse action 
        tuple member may be omitted); if the parse action is passed 
        a tuple or list of functions, this is equivalent to calling 
        ``set_parse_action(*fn)`` 
        (:class:`ParserElement.set_parse_action`) 
    - ``lpar`` - expression for matching left-parentheses; if passed as a 
      str, then will be parsed as Suppress(lpar). If lpar is passed as 
      an expression (such as ``Literal('(')``), then it will be kept in 
      the parsed results, and grouped with them. (default= ``Suppress('(')``) 
    - ``rpar`` - expression for matching right-parentheses; if passed as a 
      str, then will be parsed as Suppress(rpar). If rpar is passed as 
      an expression (such as ``Literal(')')``), then it will be kept in 
      the parsed results, and grouped with them. (default= ``Suppress(')')``) 
 
    Example:: 
 
        # simple example of four-function arithmetic with ints and 
        # variable names 
        integer = pyparsing_common.signed_integer 
        varname = pyparsing_common.identifier 
 
        arith_expr = infix_notation(integer | varname, 
            [ 
            ('-', 1, OpAssoc.RIGHT), 
            (one_of('* /'), 2, OpAssoc.LEFT), 
            (one_of('+ -'), 2, OpAssoc.LEFT), 
            ]) 
 
        arith_expr.run_tests(''' 
            5+3*6 
            (5+3)*6 
            -2--11 
            ''', full_dump=False) 
 
    prints:: 
 
        5+3*6 
        [[5, '+', [3, '*', 6]]] 
 
        (5+3)*6 
        [[[5, '+', 3], '*', 6]] 
 
        -2--11 
        [[['-', 2], '-', ['-', 11]]] 
    &quot;&quot;&quot;</span>
    <span class="s0"># captive version of FollowedBy that does not do parse actions or capture results names</span>
    <span class="s2">class </span><span class="s1">_FB(FollowedBy):</span>
        <span class="s2">def </span><span class="s1">parseImpl(self</span><span class="s2">, </span><span class="s1">instring</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">doActions=</span><span class="s2">True</span><span class="s1">):</span>
            <span class="s1">self.expr.try_parse(instring</span><span class="s2">, </span><span class="s1">loc)</span>
            <span class="s2">return </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">[]</span>

    <span class="s1">_FB.__name__ = </span><span class="s3">&quot;FollowedBy&gt;&quot;</span>

    <span class="s1">ret = Forward()</span>
    <span class="s2">if </span><span class="s1">isinstance(lpar</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s1">lpar = Suppress(lpar)</span>
    <span class="s2">if </span><span class="s1">isinstance(rpar</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s1">rpar = Suppress(rpar)</span>

    <span class="s0"># if lpar and rpar are not suppressed, wrap in group</span>
    <span class="s2">if not </span><span class="s1">(isinstance(rpar</span><span class="s2">, </span><span class="s1">Suppress) </span><span class="s2">and </span><span class="s1">isinstance(rpar</span><span class="s2">, </span><span class="s1">Suppress)):</span>
        <span class="s1">lastExpr = base_expr | Group(lpar + ret + rpar)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">lastExpr = base_expr | (lpar + ret + rpar)</span>

    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">operDef </span><span class="s2">in </span><span class="s1">enumerate(op_list):</span>
        <span class="s1">opExpr</span><span class="s2">, </span><span class="s1">arity</span><span class="s2">, </span><span class="s1">rightLeftAssoc</span><span class="s2">, </span><span class="s1">pa = (operDef + (</span><span class="s2">None,</span><span class="s1">))[:</span><span class="s5">4</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">isinstance(opExpr</span><span class="s2">, </span><span class="s1">str_type):</span>
            <span class="s1">opExpr = ParserElement._literalStringClass(opExpr)</span>
        <span class="s2">if </span><span class="s1">arity == </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">isinstance(opExpr</span><span class="s2">, </span><span class="s1">(tuple</span><span class="s2">, </span><span class="s1">list)) </span><span class="s2">or </span><span class="s1">len(opExpr) != </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;if numterms=3, opExpr must be a tuple or list of two expressions&quot;</span>
                <span class="s1">)</span>
            <span class="s1">opExpr1</span><span class="s2">, </span><span class="s1">opExpr2 = opExpr</span>
            <span class="s1">term_name = </span><span class="s3">&quot;{}{} term&quot;</span><span class="s1">.format(opExpr1</span><span class="s2">, </span><span class="s1">opExpr2)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">term_name = </span><span class="s3">&quot;{} term&quot;</span><span class="s1">.format(opExpr)</span>

        <span class="s2">if not </span><span class="s5">1 </span><span class="s1">&lt;= arity &lt;= </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;operator must be unary (1), binary (2), or ternary (3)&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">rightLeftAssoc </span><span class="s2">not in </span><span class="s1">(OpAssoc.LEFT</span><span class="s2">, </span><span class="s1">OpAssoc.RIGHT):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;operator must indicate right or left associativity&quot;</span><span class="s1">)</span>

        <span class="s1">thisExpr: Forward = Forward().set_name(term_name)</span>
        <span class="s2">if </span><span class="s1">rightLeftAssoc </span><span class="s2">is </span><span class="s1">OpAssoc.LEFT:</span>
            <span class="s2">if </span><span class="s1">arity == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">matchExpr = _FB(lastExpr + opExpr) + Group(lastExpr + opExpr[</span><span class="s5">1</span><span class="s2">, </span><span class="s1">...])</span>
            <span class="s2">elif </span><span class="s1">arity == </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">opExpr </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">matchExpr = _FB(lastExpr + opExpr + lastExpr) + Group(</span>
                        <span class="s1">lastExpr + (opExpr + lastExpr)[</span><span class="s5">1</span><span class="s2">, </span><span class="s1">...]</span>
                    <span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">matchExpr = _FB(lastExpr + lastExpr) + Group(lastExpr[</span><span class="s5">2</span><span class="s2">, </span><span class="s1">...])</span>
            <span class="s2">elif </span><span class="s1">arity == </span><span class="s5">3</span><span class="s1">:</span>
                <span class="s1">matchExpr = _FB(</span>
                    <span class="s1">lastExpr + opExpr1 + lastExpr + opExpr2 + lastExpr</span>
                <span class="s1">) + Group(lastExpr + OneOrMore(opExpr1 + lastExpr + opExpr2 + lastExpr))</span>
        <span class="s2">elif </span><span class="s1">rightLeftAssoc </span><span class="s2">is </span><span class="s1">OpAssoc.RIGHT:</span>
            <span class="s2">if </span><span class="s1">arity == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s0"># try to avoid LR with this extra test</span>
                <span class="s2">if not </span><span class="s1">isinstance(opExpr</span><span class="s2">, </span><span class="s1">Opt):</span>
                    <span class="s1">opExpr = Opt(opExpr)</span>
                <span class="s1">matchExpr = _FB(opExpr.expr + thisExpr) + Group(opExpr + thisExpr)</span>
            <span class="s2">elif </span><span class="s1">arity == </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">opExpr </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">matchExpr = _FB(lastExpr + opExpr + thisExpr) + Group(</span>
                        <span class="s1">lastExpr + (opExpr + thisExpr)[</span><span class="s5">1</span><span class="s2">, </span><span class="s1">...]</span>
                    <span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">matchExpr = _FB(lastExpr + thisExpr) + Group(</span>
                        <span class="s1">lastExpr + thisExpr[</span><span class="s5">1</span><span class="s2">, </span><span class="s1">...]</span>
                    <span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">arity == </span><span class="s5">3</span><span class="s1">:</span>
                <span class="s1">matchExpr = _FB(</span>
                    <span class="s1">lastExpr + opExpr1 + thisExpr + opExpr2 + thisExpr</span>
                <span class="s1">) + Group(lastExpr + opExpr1 + thisExpr + opExpr2 + thisExpr)</span>
        <span class="s2">if </span><span class="s1">pa:</span>
            <span class="s2">if </span><span class="s1">isinstance(pa</span><span class="s2">, </span><span class="s1">(tuple</span><span class="s2">, </span><span class="s1">list)):</span>
                <span class="s1">matchExpr.set_parse_action(*pa)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">matchExpr.set_parse_action(pa)</span>
        <span class="s1">thisExpr &lt;&lt;= (matchExpr | lastExpr).setName(term_name)</span>
        <span class="s1">lastExpr = thisExpr</span>
    <span class="s1">ret &lt;&lt;= lastExpr</span>
    <span class="s2">return </span><span class="s1">ret</span>


<span class="s2">def </span><span class="s1">indentedBlock(blockStatementExpr</span><span class="s2">, </span><span class="s1">indentStack</span><span class="s2">, </span><span class="s1">indent=</span><span class="s2">True, </span><span class="s1">backup_stacks=[]):</span>
    <span class="s4">&quot;&quot;&quot; 
    (DEPRECATED - use IndentedBlock class instead) 
    Helper method for defining space-delimited indentation blocks, 
    such as those used to define block statements in Python source code. 
 
    Parameters: 
 
    - ``blockStatementExpr`` - expression defining syntax of statement that 
      is repeated within the indented block 
    - ``indentStack`` - list created by caller to manage indentation stack 
      (multiple ``statementWithIndentedBlock`` expressions within a single 
      grammar should share a common ``indentStack``) 
    - ``indent`` - boolean indicating whether block must be indented beyond 
      the current level; set to ``False`` for block of left-most statements 
      (default= ``True``) 
 
    A valid block must contain at least one ``blockStatement``. 
 
    (Note that indentedBlock uses internal parse actions which make it 
    incompatible with packrat parsing.) 
 
    Example:: 
 
        data = ''' 
        def A(z): 
          A1 
          B = 100 
          G = A2 
          A2 
          A3 
        B 
        def BB(a,b,c): 
          BB1 
          def BBA(): 
            bba1 
            bba2 
            bba3 
        C 
        D 
        def spam(x,y): 
             def eggs(z): 
                 pass 
        ''' 
 
 
        indentStack = [1] 
        stmt = Forward() 
 
        identifier = Word(alphas, alphanums) 
        funcDecl = (&quot;def&quot; + identifier + Group(&quot;(&quot; + Opt(delimitedList(identifier)) + &quot;)&quot;) + &quot;:&quot;) 
        func_body = indentedBlock(stmt, indentStack) 
        funcDef = Group(funcDecl + func_body) 
 
        rvalue = Forward() 
        funcCall = Group(identifier + &quot;(&quot; + Opt(delimitedList(rvalue)) + &quot;)&quot;) 
        rvalue &lt;&lt; (funcCall | identifier | Word(nums)) 
        assignment = Group(identifier + &quot;=&quot; + rvalue) 
        stmt &lt;&lt; (funcDef | assignment | identifier) 
 
        module_body = stmt[1, ...] 
 
        parseTree = module_body.parseString(data) 
        parseTree.pprint() 
 
    prints:: 
 
        [['def', 
          'A', 
          ['(', 'z', ')'], 
          ':', 
          [['A1'], [['B', '=', '100']], [['G', '=', 'A2']], ['A2'], ['A3']]], 
         'B', 
         ['def', 
          'BB', 
          ['(', 'a', 'b', 'c', ')'], 
          ':', 
          [['BB1'], [['def', 'BBA', ['(', ')'], ':', [['bba1'], ['bba2'], ['bba3']]]]]], 
         'C', 
         'D', 
         ['def', 
          'spam', 
          ['(', 'x', 'y', ')'], 
          ':', 
          [[['def', 'eggs', ['(', 'z', ')'], ':', [['pass']]]]]]] 
    &quot;&quot;&quot;</span>
    <span class="s1">backup_stacks.append(indentStack[:])</span>

    <span class="s2">def </span><span class="s1">reset_stack():</span>
        <span class="s1">indentStack[:] = backup_stacks[-</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">checkPeerIndent(s</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s2">if </span><span class="s1">l &gt;= len(s):</span>
            <span class="s2">return</span>
        <span class="s1">curCol = col(l</span><span class="s2">, </span><span class="s1">s)</span>
        <span class="s2">if </span><span class="s1">curCol != indentStack[-</span><span class="s5">1</span><span class="s1">]:</span>
            <span class="s2">if </span><span class="s1">curCol &gt; indentStack[-</span><span class="s5">1</span><span class="s1">]:</span>
                <span class="s2">raise </span><span class="s1">ParseException(s</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s3">&quot;illegal nesting&quot;</span><span class="s1">)</span>
            <span class="s2">raise </span><span class="s1">ParseException(s</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s3">&quot;not a peer entry&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">checkSubIndent(s</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">curCol = col(l</span><span class="s2">, </span><span class="s1">s)</span>
        <span class="s2">if </span><span class="s1">curCol &gt; indentStack[-</span><span class="s5">1</span><span class="s1">]:</span>
            <span class="s1">indentStack.append(curCol)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ParseException(s</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s3">&quot;not a subentry&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">checkUnindent(s</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s2">if </span><span class="s1">l &gt;= len(s):</span>
            <span class="s2">return</span>
        <span class="s1">curCol = col(l</span><span class="s2">, </span><span class="s1">s)</span>
        <span class="s2">if not </span><span class="s1">(indentStack </span><span class="s2">and </span><span class="s1">curCol </span><span class="s2">in </span><span class="s1">indentStack):</span>
            <span class="s2">raise </span><span class="s1">ParseException(s</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s3">&quot;not an unindent&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">curCol &lt; indentStack[-</span><span class="s5">1</span><span class="s1">]:</span>
            <span class="s1">indentStack.pop()</span>

    <span class="s1">NL = OneOrMore(LineEnd().set_whitespace_chars(</span><span class="s3">&quot;</span><span class="s2">\t </span><span class="s3">&quot;</span><span class="s1">).suppress())</span>
    <span class="s1">INDENT = (Empty() + Empty().set_parse_action(checkSubIndent)).set_name(</span><span class="s3">&quot;INDENT&quot;</span><span class="s1">)</span>
    <span class="s1">PEER = Empty().set_parse_action(checkPeerIndent).set_name(</span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
    <span class="s1">UNDENT = Empty().set_parse_action(checkUnindent).set_name(</span><span class="s3">&quot;UNINDENT&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">indent:</span>
        <span class="s1">smExpr = Group(</span>
            <span class="s1">Opt(NL)</span>
            <span class="s1">+ INDENT</span>
            <span class="s1">+ OneOrMore(PEER + Group(blockStatementExpr) + Opt(NL))</span>
            <span class="s1">+ UNDENT</span>
        <span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">smExpr = Group(</span>
            <span class="s1">Opt(NL)</span>
            <span class="s1">+ OneOrMore(PEER + Group(blockStatementExpr) + Opt(NL))</span>
            <span class="s1">+ Opt(UNDENT)</span>
        <span class="s1">)</span>

    <span class="s0"># add a parse action to remove backup_stack from list of backups</span>
    <span class="s1">smExpr.add_parse_action(</span>
        <span class="s2">lambda</span><span class="s1">: backup_stacks.pop(-</span><span class="s5">1</span><span class="s1">) </span><span class="s2">and None if </span><span class="s1">backup_stacks </span><span class="s2">else None</span>
    <span class="s1">)</span>
    <span class="s1">smExpr.set_fail_action(</span><span class="s2">lambda </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">d: reset_stack())</span>
    <span class="s1">blockStatementExpr.ignore(_bslash + LineEnd())</span>
    <span class="s2">return </span><span class="s1">smExpr.set_name(</span><span class="s3">&quot;indented block&quot;</span><span class="s1">)</span>


<span class="s0"># it's easy to get these comment structures wrong - they're very common, so may as well make them available</span>
<span class="s1">c_style_comment = Combine(Regex(</span><span class="s3">r&quot;/\*(?:[^*]|\*(?!/))*&quot;</span><span class="s1">) + </span><span class="s3">&quot;*/&quot;</span><span class="s1">).set_name(</span>
    <span class="s3">&quot;C style comment&quot;</span>
<span class="s1">)</span>
<span class="s3">&quot;Comment of the form ``/* ... */``&quot;</span>

<span class="s1">html_comment = Regex(</span><span class="s3">r&quot;&lt;!--[\s\S]*?--&gt;&quot;</span><span class="s1">).set_name(</span><span class="s3">&quot;HTML comment&quot;</span><span class="s1">)</span>
<span class="s3">&quot;Comment of the form ``&lt;!-- ... --&gt;``&quot;</span>

<span class="s1">rest_of_line = Regex(</span><span class="s3">r&quot;.*&quot;</span><span class="s1">).leave_whitespace().set_name(</span><span class="s3">&quot;rest of line&quot;</span><span class="s1">)</span>
<span class="s1">dbl_slash_comment = Regex(</span><span class="s3">r&quot;//(?:\\\n|[^\n])*&quot;</span><span class="s1">).set_name(</span><span class="s3">&quot;// comment&quot;</span><span class="s1">)</span>
<span class="s3">&quot;Comment of the form ``// ... (to end of line)``&quot;</span>

<span class="s1">cpp_style_comment = Combine(</span>
    <span class="s1">Regex(</span><span class="s3">r&quot;/\*(?:[^*]|\*(?!/))*&quot;</span><span class="s1">) + </span><span class="s3">&quot;*/&quot; </span><span class="s1">| dbl_slash_comment</span>
<span class="s1">).set_name(</span><span class="s3">&quot;C++ style comment&quot;</span><span class="s1">)</span>
<span class="s3">&quot;Comment of either form :class:`c_style_comment` or :class:`dbl_slash_comment`&quot;</span>

<span class="s1">java_style_comment = cpp_style_comment</span>
<span class="s3">&quot;Same as :class:`cpp_style_comment`&quot;</span>

<span class="s1">python_style_comment = Regex(</span><span class="s3">r&quot;#.*&quot;</span><span class="s1">).set_name(</span><span class="s3">&quot;Python style comment&quot;</span><span class="s1">)</span>
<span class="s3">&quot;Comment of the form ``# ... (to end of line)``&quot;</span>


<span class="s0"># build list of built-in expressions, for future reference if a global default value</span>
<span class="s0"># gets updated</span>
<span class="s1">_builtin_exprs: List[ParserElement] = [</span>
    <span class="s1">v </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">vars().values() </span><span class="s2">if </span><span class="s1">isinstance(v</span><span class="s2">, </span><span class="s1">ParserElement)</span>
<span class="s1">]</span>


<span class="s0"># pre-PEP8 compatible names</span>
<span class="s1">delimitedList = delimited_list</span>
<span class="s1">countedArray = counted_array</span>
<span class="s1">matchPreviousLiteral = match_previous_literal</span>
<span class="s1">matchPreviousExpr = match_previous_expr</span>
<span class="s1">oneOf = one_of</span>
<span class="s1">dictOf = dict_of</span>
<span class="s1">originalTextFor = original_text_for</span>
<span class="s1">nestedExpr = nested_expr</span>
<span class="s1">makeHTMLTags = make_html_tags</span>
<span class="s1">makeXMLTags = make_xml_tags</span>
<span class="s1">anyOpenTag</span><span class="s2">, </span><span class="s1">anyCloseTag = any_open_tag</span><span class="s2">, </span><span class="s1">any_close_tag</span>
<span class="s1">commonHTMLEntity = common_html_entity</span>
<span class="s1">replaceHTMLEntity = replace_html_entity</span>
<span class="s1">opAssoc = OpAssoc</span>
<span class="s1">infixNotation = infix_notation</span>
<span class="s1">cStyleComment = c_style_comment</span>
<span class="s1">htmlComment = html_comment</span>
<span class="s1">restOfLine = rest_of_line</span>
<span class="s1">dblSlashComment = dbl_slash_comment</span>
<span class="s1">cppStyleComment = cpp_style_comment</span>
<span class="s1">javaStyleComment = java_style_comment</span>
<span class="s1">pythonStyleComment = python_style_comment</span>
</pre>
</body>
</html>