<html>
<head>
<title>html.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
html.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
    pygments.formatters.html 
    ~~~~~~~~~~~~~~~~~~~~~~~~ 
 
    Formatter for HTML output. 
 
    :copyright: Copyright 2006-2022 by the Pygments team, see AUTHORS. 
    :license: BSD, see LICENSE for details. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">os.path</span>
<span class="s2">from </span><span class="s1">io </span><span class="s2">import </span><span class="s1">StringIO</span>

<span class="s2">from </span><span class="s1">pip._vendor.pygments.formatter </span><span class="s2">import </span><span class="s1">Formatter</span>
<span class="s2">from </span><span class="s1">pip._vendor.pygments.token </span><span class="s2">import </span><span class="s1">Token</span><span class="s2">, </span><span class="s1">Text</span><span class="s2">, </span><span class="s1">STANDARD_TYPES</span>
<span class="s2">from </span><span class="s1">pip._vendor.pygments.util </span><span class="s2">import </span><span class="s1">get_bool_opt</span><span class="s2">, </span><span class="s1">get_int_opt</span><span class="s2">, </span><span class="s1">get_list_opt</span>

<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">import </span><span class="s1">ctags</span>
<span class="s2">except </span><span class="s1">ImportError:</span>
    <span class="s1">ctags = </span><span class="s2">None</span>

<span class="s1">__all__ = [</span><span class="s3">'HtmlFormatter'</span><span class="s1">]</span>


<span class="s1">_escape_html_table = {</span>
    <span class="s1">ord(</span><span class="s3">'&amp;'</span><span class="s1">): </span><span class="s3">'&amp;amp;'</span><span class="s2">,</span>
    <span class="s1">ord(</span><span class="s3">'&lt;'</span><span class="s1">): </span><span class="s3">'&amp;lt;'</span><span class="s2">,</span>
    <span class="s1">ord(</span><span class="s3">'&gt;'</span><span class="s1">): </span><span class="s3">'&amp;gt;'</span><span class="s2">,</span>
    <span class="s1">ord(</span><span class="s3">'&quot;'</span><span class="s1">): </span><span class="s3">'&amp;quot;'</span><span class="s2">,</span>
    <span class="s1">ord(</span><span class="s3">&quot;'&quot;</span><span class="s1">): </span><span class="s3">'&amp;#39;'</span><span class="s2">,</span>
<span class="s1">}</span>


<span class="s2">def </span><span class="s1">escape_html(text</span><span class="s2">, </span><span class="s1">table=_escape_html_table):</span>
    <span class="s0">&quot;&quot;&quot;Escape &amp;, &lt;, &gt; as well as single and double quotes for HTML.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">text.translate(table)</span>


<span class="s2">def </span><span class="s1">webify(color):</span>
    <span class="s2">if </span><span class="s1">color.startswith(</span><span class="s3">'calc'</span><span class="s1">) </span><span class="s2">or </span><span class="s1">color.startswith(</span><span class="s3">'var'</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">color</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s3">'#' </span><span class="s1">+ color</span>


<span class="s2">def </span><span class="s1">_get_ttype_class(ttype):</span>
    <span class="s1">fname = STANDARD_TYPES.get(ttype)</span>
    <span class="s2">if </span><span class="s1">fname:</span>
        <span class="s2">return </span><span class="s1">fname</span>
    <span class="s1">aname = </span><span class="s3">''</span>
    <span class="s2">while </span><span class="s1">fname </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">aname = </span><span class="s3">'-' </span><span class="s1">+ ttype[-</span><span class="s4">1</span><span class="s1">] + aname</span>
        <span class="s1">ttype = ttype.parent</span>
        <span class="s1">fname = STANDARD_TYPES.get(ttype)</span>
    <span class="s2">return </span><span class="s1">fname + aname</span>


<span class="s1">CSSFILE_TEMPLATE = </span><span class="s3">'''</span><span class="s2">\ 
</span><span class="s3">/* 
generated by Pygments &lt;https://pygments.org/&gt; 
Copyright 2006-2022 by the Pygments team. 
Licensed under the BSD license, see LICENSE for details. 
*/ 
%(styledefs)s 
'''</span>

<span class="s1">DOC_HEADER = </span><span class="s3">'''</span><span class="s2">\ 
</span><span class="s3">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; 
   &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt; 
&lt;!-- 
generated by Pygments &lt;https://pygments.org/&gt; 
Copyright 2006-2022 by the Pygments team. 
Licensed under the BSD license, see LICENSE for details. 
--&gt; 
&lt;html&gt; 
&lt;head&gt; 
  &lt;title&gt;%(title)s&lt;/title&gt; 
  &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=%(encoding)s&quot;&gt; 
  &lt;style type=&quot;text/css&quot;&gt; 
''' </span><span class="s1">+ CSSFILE_TEMPLATE + </span><span class="s3">''' 
  &lt;/style&gt; 
&lt;/head&gt; 
&lt;body&gt; 
&lt;h2&gt;%(title)s&lt;/h2&gt; 
 
'''</span>

<span class="s1">DOC_HEADER_EXTERNALCSS = </span><span class="s3">'''</span><span class="s2">\ 
</span><span class="s3">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; 
   &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt; 
 
&lt;html&gt; 
&lt;head&gt; 
  &lt;title&gt;%(title)s&lt;/title&gt; 
  &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=%(encoding)s&quot;&gt; 
  &lt;link rel=&quot;stylesheet&quot; href=&quot;%(cssfile)s&quot; type=&quot;text/css&quot;&gt; 
&lt;/head&gt; 
&lt;body&gt; 
&lt;h2&gt;%(title)s&lt;/h2&gt; 
 
'''</span>

<span class="s1">DOC_FOOTER = </span><span class="s3">'''</span><span class="s2">\ 
</span><span class="s3">&lt;/body&gt; 
&lt;/html&gt; 
'''</span>


<span class="s2">class </span><span class="s1">HtmlFormatter(Formatter):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Format tokens as HTML 4 ``&lt;span&gt;`` tags within a ``&lt;pre&gt;`` tag, wrapped 
    in a ``&lt;div&gt;`` tag. The ``&lt;div&gt;``'s CSS class can be set by the `cssclass` 
    option. 
 
    If the `linenos` option is set to ``&quot;table&quot;``, the ``&lt;pre&gt;`` is 
    additionally wrapped inside a ``&lt;table&gt;`` which has one row and two 
    cells: one containing the line numbers and one containing the code. 
    Example: 
 
    .. sourcecode:: html 
 
        &lt;div class=&quot;highlight&quot; &gt; 
        &lt;table&gt;&lt;tr&gt; 
          &lt;td class=&quot;linenos&quot; title=&quot;click to toggle&quot; 
            onclick=&quot;with (this.firstChild.style) 
                     { display = (display == '') ? 'none' : '' }&quot;&gt; 
            &lt;pre&gt;1 
            2&lt;/pre&gt; 
          &lt;/td&gt; 
          &lt;td class=&quot;code&quot;&gt; 
            &lt;pre&gt;&lt;span class=&quot;Ke&quot;&gt;def &lt;/span&gt;&lt;span class=&quot;NaFu&quot;&gt;foo&lt;/span&gt;(bar): 
              &lt;span class=&quot;Ke&quot;&gt;pass&lt;/span&gt; 
            &lt;/pre&gt; 
          &lt;/td&gt; 
        &lt;/tr&gt;&lt;/table&gt;&lt;/div&gt; 
 
    (whitespace added to improve clarity). 
 
    Wrapping can be disabled using the `nowrap` option. 
 
    A list of lines can be specified using the `hl_lines` option to make these 
    lines highlighted (as of Pygments 0.11). 
 
    With the `full` option, a complete HTML 4 document is output, including 
    the style definitions inside a ``&lt;style&gt;`` tag, or in a separate file if 
    the `cssfile` option is given. 
 
    When `tagsfile` is set to the path of a ctags index file, it is used to 
    generate hyperlinks from names to their definition.  You must enable 
    `lineanchors` and run ctags with the `-n` option for this to work.  The 
    `python-ctags` module from PyPI must be installed to use this feature; 
    otherwise a `RuntimeError` will be raised. 
 
    The `get_style_defs(arg='')` method of a `HtmlFormatter` returns a string 
    containing CSS rules for the CSS classes used by the formatter. The 
    argument `arg` can be used to specify additional CSS selectors that 
    are prepended to the classes. A call `fmter.get_style_defs('td .code')` 
    would result in the following CSS classes: 
 
    .. sourcecode:: css 
 
        td .code .kw { font-weight: bold; color: #00FF00 } 
        td .code .cm { color: #999999 } 
        ... 
 
    If you have Pygments 0.6 or higher, you can also pass a list or tuple to the 
    `get_style_defs()` method to request multiple prefixes for the tokens: 
 
    .. sourcecode:: python 
 
        formatter.get_style_defs(['div.syntax pre', 'pre.syntax']) 
 
    The output would then look like this: 
 
    .. sourcecode:: css 
 
        div.syntax pre .kw, 
        pre.syntax .kw { font-weight: bold; color: #00FF00 } 
        div.syntax pre .cm, 
        pre.syntax .cm { color: #999999 } 
        ... 
 
    Additional options accepted: 
 
    `nowrap` 
        If set to ``True``, don't wrap the tokens at all, not even inside a ``&lt;pre&gt;`` 
        tag. This disables most other options (default: ``False``). 
 
    `full` 
        Tells the formatter to output a &quot;full&quot; document, i.e. a complete 
        self-contained document (default: ``False``). 
 
    `title` 
        If `full` is true, the title that should be used to caption the 
        document (default: ``''``). 
 
    `style` 
        The style to use, can be a string or a Style subclass (default: 
        ``'default'``). This option has no effect if the `cssfile` 
        and `noclobber_cssfile` option are given and the file specified in 
        `cssfile` exists. 
 
    `noclasses` 
        If set to true, token ``&lt;span&gt;`` tags (as well as line number elements) 
        will not use CSS classes, but inline styles. This is not recommended 
        for larger pieces of code since it increases output size by quite a bit 
        (default: ``False``). 
 
    `classprefix` 
        Since the token types use relatively short class names, they may clash 
        with some of your own class names. In this case you can use the 
        `classprefix` option to give a string to prepend to all Pygments-generated 
        CSS class names for token types. 
        Note that this option also affects the output of `get_style_defs()`. 
 
    `cssclass` 
        CSS class for the wrapping ``&lt;div&gt;`` tag (default: ``'highlight'``). 
        If you set this option, the default selector for `get_style_defs()` 
        will be this class. 
 
        .. versionadded:: 0.9 
           If you select the ``'table'`` line numbers, the wrapping table will 
           have a CSS class of this string plus ``'table'``, the default is 
           accordingly ``'highlighttable'``. 
 
    `cssstyles` 
        Inline CSS styles for the wrapping ``&lt;div&gt;`` tag (default: ``''``). 
 
    `prestyles` 
        Inline CSS styles for the ``&lt;pre&gt;`` tag (default: ``''``). 
 
        .. versionadded:: 0.11 
 
    `cssfile` 
        If the `full` option is true and this option is given, it must be the 
        name of an external file. If the filename does not include an absolute 
        path, the file's path will be assumed to be relative to the main output 
        file's path, if the latter can be found. The stylesheet is then written 
        to this file instead of the HTML file. 
 
        .. versionadded:: 0.6 
 
    `noclobber_cssfile` 
        If `cssfile` is given and the specified file exists, the css file will 
        not be overwritten. This allows the use of the `full` option in 
        combination with a user specified css file. Default is ``False``. 
 
        .. versionadded:: 1.1 
 
    `linenos` 
        If set to ``'table'``, output line numbers as a table with two cells, 
        one containing the line numbers, the other the whole code.  This is 
        copy-and-paste-friendly, but may cause alignment problems with some 
        browsers or fonts.  If set to ``'inline'``, the line numbers will be 
        integrated in the ``&lt;pre&gt;`` tag that contains the code (that setting 
        is *new in Pygments 0.8*). 
 
        For compatibility with Pygments 0.7 and earlier, every true value 
        except ``'inline'`` means the same as ``'table'`` (in particular, that 
        means also ``True``). 
 
        The default value is ``False``, which means no line numbers at all. 
 
        **Note:** with the default (&quot;table&quot;) line number mechanism, the line 
        numbers and code can have different line heights in Internet Explorer 
        unless you give the enclosing ``&lt;pre&gt;`` tags an explicit ``line-height`` 
        CSS property (you get the default line spacing with ``line-height: 
        125%``). 
 
    `hl_lines` 
        Specify a list of lines to be highlighted. The line numbers are always 
        relative to the input (i.e. the first line is line 1) and are 
        independent of `linenostart`. 
 
        .. versionadded:: 0.11 
 
    `linenostart` 
        The line number for the first line (default: ``1``). 
 
    `linenostep` 
        If set to a number n &gt; 1, only every nth line number is printed. 
 
    `linenospecial` 
        If set to a number n &gt; 0, every nth line number is given the CSS 
        class ``&quot;special&quot;`` (default: ``0``). 
 
    `nobackground` 
        If set to ``True``, the formatter won't output the background color 
        for the wrapping element (this automatically defaults to ``False`` 
        when there is no wrapping element [eg: no argument for the 
        `get_syntax_defs` method given]) (default: ``False``). 
 
        .. versionadded:: 0.6 
 
    `lineseparator` 
        This string is output between lines of code. It defaults to ``&quot;\n&quot;``, 
        which is enough to break a line inside ``&lt;pre&gt;`` tags, but you can 
        e.g. set it to ``&quot;&lt;br&gt;&quot;`` to get HTML line breaks. 
 
        .. versionadded:: 0.7 
 
    `lineanchors` 
        If set to a nonempty string, e.g. ``foo``, the formatter will wrap each 
        output line in an anchor tag with an ``id`` (and `name`) of ``foo-linenumber``. 
        This allows easy linking to certain lines. 
 
        .. versionadded:: 0.9 
 
    `linespans` 
        If set to a nonempty string, e.g. ``foo``, the formatter will wrap each 
        output line in a span tag with an ``id`` of ``foo-linenumber``. 
        This allows easy access to lines via javascript. 
 
        .. versionadded:: 1.6 
 
    `anchorlinenos` 
        If set to `True`, will wrap line numbers in &lt;a&gt; tags. Used in 
        combination with `linenos` and `lineanchors`. 
 
    `tagsfile` 
        If set to the path of a ctags file, wrap names in anchor tags that 
        link to their definitions. `lineanchors` should be used, and the 
        tags file should specify line numbers (see the `-n` option to ctags). 
 
        .. versionadded:: 1.6 
 
    `tagurlformat` 
        A string formatting pattern used to generate links to ctags definitions. 
        Available variables are `%(path)s`, `%(fname)s` and `%(fext)s`. 
        Defaults to an empty string, resulting in just `#prefix-number` links. 
 
        .. versionadded:: 1.6 
 
    `filename` 
        A string used to generate a filename when rendering ``&lt;pre&gt;`` blocks, 
        for example if displaying source code. If `linenos` is set to 
        ``'table'`` then the filename will be rendered in an initial row 
        containing a single `&lt;th&gt;` which spans both columns. 
 
        .. versionadded:: 2.1 
 
    `wrapcode` 
        Wrap the code inside ``&lt;pre&gt;`` blocks using ``&lt;code&gt;``, as recommended 
        by the HTML5 specification. 
 
        .. versionadded:: 2.4 
 
    `debug_token_types` 
        Add ``title`` attributes to all token ``&lt;span&gt;`` tags that show the 
        name of the token. 
 
        .. versionadded:: 2.10 
 
 
    **Subclassing the HTML formatter** 
 
    .. versionadded:: 0.7 
 
    The HTML formatter is now built in a way that allows easy subclassing, thus 
    customizing the output HTML code. The `format()` method calls 
    `self._format_lines()` which returns a generator that yields tuples of ``(1, 
    line)``, where the ``1`` indicates that the ``line`` is a line of the 
    formatted source code. 
 
    If the `nowrap` option is set, the generator is the iterated over and the 
    resulting HTML is output. 
 
    Otherwise, `format()` calls `self.wrap()`, which wraps the generator with 
    other generators. These may add some HTML code to the one generated by 
    `_format_lines()`, either by modifying the lines generated by the latter, 
    then yielding them again with ``(1, line)``, and/or by yielding other HTML 
    code before or after the lines, with ``(0, html)``. The distinction between 
    source lines and other code makes it possible to wrap the generator multiple 
    times. 
 
    The default `wrap()` implementation adds a ``&lt;div&gt;`` and a ``&lt;pre&gt;`` tag. 
 
    A custom `HtmlFormatter` subclass could look like this: 
 
    .. sourcecode:: python 
 
        class CodeHtmlFormatter(HtmlFormatter): 
 
            def wrap(self, source, *, include_div): 
                return self._wrap_code(source) 
 
            def _wrap_code(self, source): 
                yield 0, '&lt;code&gt;' 
                for i, t in source: 
                    if i == 1: 
                        # it's a line of formatted code 
                        t += '&lt;br&gt;' 
                    yield i, t 
                yield 0, '&lt;/code&gt;' 
 
    This results in wrapping the formatted lines with a ``&lt;code&gt;`` tag, where the 
    source lines are broken using ``&lt;br&gt;`` tags. 
 
    After calling `wrap()`, the `format()` method also adds the &quot;line numbers&quot; 
    and/or &quot;full document&quot; wrappers if the respective options are set. Then, all 
    HTML yielded by the wrapped generator is output. 
    &quot;&quot;&quot;</span>

    <span class="s1">name = </span><span class="s3">'HTML'</span>
    <span class="s1">aliases = [</span><span class="s3">'html'</span><span class="s1">]</span>
    <span class="s1">filenames = [</span><span class="s3">'*.html'</span><span class="s2">, </span><span class="s3">'*.htm'</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">**options):</span>
        <span class="s1">Formatter.__init__(self</span><span class="s2">, </span><span class="s1">**options)</span>
        <span class="s1">self.title = self._decodeifneeded(self.title)</span>
        <span class="s1">self.nowrap = get_bool_opt(options</span><span class="s2">, </span><span class="s3">'nowrap'</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">self.noclasses = get_bool_opt(options</span><span class="s2">, </span><span class="s3">'noclasses'</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">self.classprefix = options.get(</span><span class="s3">'classprefix'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span>
        <span class="s1">self.cssclass = self._decodeifneeded(options.get(</span><span class="s3">'cssclass'</span><span class="s2">, </span><span class="s3">'highlight'</span><span class="s1">))</span>
        <span class="s1">self.cssstyles = self._decodeifneeded(options.get(</span><span class="s3">'cssstyles'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">))</span>
        <span class="s1">self.prestyles = self._decodeifneeded(options.get(</span><span class="s3">'prestyles'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">))</span>
        <span class="s1">self.cssfile = self._decodeifneeded(options.get(</span><span class="s3">'cssfile'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">))</span>
        <span class="s1">self.noclobber_cssfile = get_bool_opt(options</span><span class="s2">, </span><span class="s3">'noclobber_cssfile'</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">self.tagsfile = self._decodeifneeded(options.get(</span><span class="s3">'tagsfile'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">))</span>
        <span class="s1">self.tagurlformat = self._decodeifneeded(options.get(</span><span class="s3">'tagurlformat'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">))</span>
        <span class="s1">self.filename = self._decodeifneeded(options.get(</span><span class="s3">'filename'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">))</span>
        <span class="s1">self.wrapcode = get_bool_opt(options</span><span class="s2">, </span><span class="s3">'wrapcode'</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">self.span_element_openers = {}</span>
        <span class="s1">self.debug_token_types = get_bool_opt(options</span><span class="s2">, </span><span class="s3">'debug_token_types'</span><span class="s2">, False</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self.tagsfile:</span>
            <span class="s2">if not </span><span class="s1">ctags:</span>
                <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">'The &quot;ctags&quot; package must to be installed '</span>
                                   <span class="s3">'to be able to use the &quot;tagsfile&quot; feature.'</span><span class="s1">)</span>
            <span class="s1">self._ctags = ctags.CTags(self.tagsfile)</span>

        <span class="s1">linenos = options.get(</span><span class="s3">'linenos'</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">linenos == </span><span class="s3">'inline'</span><span class="s1">:</span>
            <span class="s1">self.linenos = </span><span class="s4">2</span>
        <span class="s2">elif </span><span class="s1">linenos:</span>
            <span class="s5"># compatibility with &lt;= 0.7</span>
            <span class="s1">self.linenos = </span><span class="s4">1</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.linenos = </span><span class="s4">0</span>
        <span class="s1">self.linenostart = abs(get_int_opt(options</span><span class="s2">, </span><span class="s3">'linenostart'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">self.linenostep = abs(get_int_opt(options</span><span class="s2">, </span><span class="s3">'linenostep'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">self.linenospecial = abs(get_int_opt(options</span><span class="s2">, </span><span class="s3">'linenospecial'</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">self.nobackground = get_bool_opt(options</span><span class="s2">, </span><span class="s3">'nobackground'</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">self.lineseparator = options.get(</span><span class="s3">'lineseparator'</span><span class="s2">, </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span>
        <span class="s1">self.lineanchors = options.get(</span><span class="s3">'lineanchors'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span>
        <span class="s1">self.linespans = options.get(</span><span class="s3">'linespans'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span>
        <span class="s1">self.anchorlinenos = get_bool_opt(options</span><span class="s2">, </span><span class="s3">'anchorlinenos'</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">self.hl_lines = set()</span>
        <span class="s2">for </span><span class="s1">lineno </span><span class="s2">in </span><span class="s1">get_list_opt(options</span><span class="s2">, </span><span class="s3">'hl_lines'</span><span class="s2">, </span><span class="s1">[]):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">self.hl_lines.add(int(lineno))</span>
            <span class="s2">except </span><span class="s1">ValueError:</span>
                <span class="s2">pass</span>

        <span class="s1">self._create_stylesheet()</span>

    <span class="s2">def </span><span class="s1">_get_css_class(self</span><span class="s2">, </span><span class="s1">ttype):</span>
        <span class="s0">&quot;&quot;&quot;Return the css class of this token type prefixed with 
        the classprefix option.&quot;&quot;&quot;</span>
        <span class="s1">ttypeclass = _get_ttype_class(ttype)</span>
        <span class="s2">if </span><span class="s1">ttypeclass:</span>
            <span class="s2">return </span><span class="s1">self.classprefix + ttypeclass</span>
        <span class="s2">return </span><span class="s3">''</span>

    <span class="s2">def </span><span class="s1">_get_css_classes(self</span><span class="s2">, </span><span class="s1">ttype):</span>
        <span class="s0">&quot;&quot;&quot;Return the CSS classes of this token type prefixed with the classprefix option.&quot;&quot;&quot;</span>
        <span class="s1">cls = self._get_css_class(ttype)</span>
        <span class="s2">while </span><span class="s1">ttype </span><span class="s2">not in </span><span class="s1">STANDARD_TYPES:</span>
            <span class="s1">ttype = ttype.parent</span>
            <span class="s1">cls = self._get_css_class(ttype) + </span><span class="s3">' ' </span><span class="s1">+ cls</span>
        <span class="s2">return </span><span class="s1">cls </span><span class="s2">or </span><span class="s3">''</span>

    <span class="s2">def </span><span class="s1">_get_css_inline_styles(self</span><span class="s2">, </span><span class="s1">ttype):</span>
        <span class="s0">&quot;&quot;&quot;Return the inline CSS styles for this token type.&quot;&quot;&quot;</span>
        <span class="s1">cclass = self.ttype2class.get(ttype)</span>
        <span class="s2">while </span><span class="s1">cclass </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">ttype = ttype.parent</span>
            <span class="s1">cclass = self.ttype2class.get(ttype)</span>
        <span class="s2">return </span><span class="s1">cclass </span><span class="s2">or </span><span class="s3">''</span>

    <span class="s2">def </span><span class="s1">_create_stylesheet(self):</span>
        <span class="s1">t2c = self.ttype2class = {Token: </span><span class="s3">''</span><span class="s1">}</span>
        <span class="s1">c2s = self.class2style = {}</span>
        <span class="s2">for </span><span class="s1">ttype</span><span class="s2">, </span><span class="s1">ndef </span><span class="s2">in </span><span class="s1">self.style:</span>
            <span class="s1">name = self._get_css_class(ttype)</span>
            <span class="s1">style = </span><span class="s3">''</span>
            <span class="s2">if </span><span class="s1">ndef[</span><span class="s3">'color'</span><span class="s1">]:</span>
                <span class="s1">style += </span><span class="s3">'color: %s; ' </span><span class="s1">% webify(ndef[</span><span class="s3">'color'</span><span class="s1">])</span>
            <span class="s2">if </span><span class="s1">ndef[</span><span class="s3">'bold'</span><span class="s1">]:</span>
                <span class="s1">style += </span><span class="s3">'font-weight: bold; '</span>
            <span class="s2">if </span><span class="s1">ndef[</span><span class="s3">'italic'</span><span class="s1">]:</span>
                <span class="s1">style += </span><span class="s3">'font-style: italic; '</span>
            <span class="s2">if </span><span class="s1">ndef[</span><span class="s3">'underline'</span><span class="s1">]:</span>
                <span class="s1">style += </span><span class="s3">'text-decoration: underline; '</span>
            <span class="s2">if </span><span class="s1">ndef[</span><span class="s3">'bgcolor'</span><span class="s1">]:</span>
                <span class="s1">style += </span><span class="s3">'background-color: %s; ' </span><span class="s1">% webify(ndef[</span><span class="s3">'bgcolor'</span><span class="s1">])</span>
            <span class="s2">if </span><span class="s1">ndef[</span><span class="s3">'border'</span><span class="s1">]:</span>
                <span class="s1">style += </span><span class="s3">'border: 1px solid %s; ' </span><span class="s1">% webify(ndef[</span><span class="s3">'border'</span><span class="s1">])</span>
            <span class="s2">if </span><span class="s1">style:</span>
                <span class="s1">t2c[ttype] = name</span>
                <span class="s5"># save len(ttype) to enable ordering the styles by</span>
                <span class="s5"># hierarchy (necessary for CSS cascading rules!)</span>
                <span class="s1">c2s[name] = (style[:-</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ttype</span><span class="s2">, </span><span class="s1">len(ttype))</span>

    <span class="s2">def </span><span class="s1">get_style_defs(self</span><span class="s2">, </span><span class="s1">arg=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return CSS style definitions for the classes produced by the current 
        highlighting style. ``arg`` can be a string or list of selectors to 
        insert before the token type classes. 
        &quot;&quot;&quot;</span>
        <span class="s1">style_lines = []</span>

        <span class="s1">style_lines.extend(self.get_linenos_style_defs())</span>
        <span class="s1">style_lines.extend(self.get_background_style_defs(arg))</span>
        <span class="s1">style_lines.extend(self.get_token_style_defs(arg))</span>

        <span class="s2">return </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">.join(style_lines)</span>

    <span class="s2">def </span><span class="s1">get_token_style_defs(self</span><span class="s2">, </span><span class="s1">arg=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">prefix = self.get_css_prefix(arg)</span>

        <span class="s1">styles = [</span>
            <span class="s1">(level</span><span class="s2">, </span><span class="s1">ttype</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">, </span><span class="s1">style)</span>
            <span class="s2">for </span><span class="s1">cls</span><span class="s2">, </span><span class="s1">(style</span><span class="s2">, </span><span class="s1">ttype</span><span class="s2">, </span><span class="s1">level) </span><span class="s2">in </span><span class="s1">self.class2style.items()</span>
            <span class="s2">if </span><span class="s1">cls </span><span class="s2">and </span><span class="s1">style</span>
        <span class="s1">]</span>
        <span class="s1">styles.sort()</span>

        <span class="s1">lines = [</span>
            <span class="s3">'%s { %s } /* %s */' </span><span class="s1">% (prefix(cls)</span><span class="s2">, </span><span class="s1">style</span><span class="s2">, </span><span class="s1">repr(ttype)[</span><span class="s4">6</span><span class="s1">:])</span>
            <span class="s2">for </span><span class="s1">(level</span><span class="s2">, </span><span class="s1">ttype</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">, </span><span class="s1">style) </span><span class="s2">in </span><span class="s1">styles</span>
        <span class="s1">]</span>

        <span class="s2">return </span><span class="s1">lines</span>

    <span class="s2">def </span><span class="s1">get_background_style_defs(self</span><span class="s2">, </span><span class="s1">arg=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">prefix = self.get_css_prefix(arg)</span>
        <span class="s1">bg_color = self.style.background_color</span>
        <span class="s1">hl_color = self.style.highlight_color</span>

        <span class="s1">lines = []</span>

        <span class="s2">if </span><span class="s1">arg </span><span class="s2">and not </span><span class="s1">self.nobackground </span><span class="s2">and </span><span class="s1">bg_color </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">text_style = </span><span class="s3">''</span>
            <span class="s2">if </span><span class="s1">Text </span><span class="s2">in </span><span class="s1">self.ttype2class:</span>
                <span class="s1">text_style = </span><span class="s3">' ' </span><span class="s1">+ self.class2style[self.ttype2class[Text]][</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">lines.insert(</span>
                <span class="s4">0</span><span class="s2">, </span><span class="s3">'%s{ background: %s;%s }' </span><span class="s1">% (</span>
                    <span class="s1">prefix(</span><span class="s3">''</span><span class="s1">)</span><span class="s2">, </span><span class="s1">bg_color</span><span class="s2">, </span><span class="s1">text_style</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">hl_color </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">lines.insert(</span>
                <span class="s4">0</span><span class="s2">, </span><span class="s3">'%s { background-color: %s }' </span><span class="s1">% (prefix(</span><span class="s3">'hll'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">hl_color)</span>
            <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">lines</span>

    <span class="s2">def </span><span class="s1">get_linenos_style_defs(self):</span>
        <span class="s1">lines = [</span>
            <span class="s3">'pre { %s }' </span><span class="s1">% self._pre_style</span><span class="s2">,</span>
            <span class="s3">'td.linenos .normal { %s }' </span><span class="s1">% self._linenos_style</span><span class="s2">,</span>
            <span class="s3">'span.linenos { %s }' </span><span class="s1">% self._linenos_style</span><span class="s2">,</span>
            <span class="s3">'td.linenos .special { %s }' </span><span class="s1">% self._linenos_special_style</span><span class="s2">,</span>
            <span class="s3">'span.linenos.special { %s }' </span><span class="s1">% self._linenos_special_style</span><span class="s2">,</span>
        <span class="s1">]</span>

        <span class="s2">return </span><span class="s1">lines</span>

    <span class="s2">def </span><span class="s1">get_css_prefix(self</span><span class="s2">, </span><span class="s1">arg):</span>
        <span class="s2">if </span><span class="s1">arg </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">arg = (</span><span class="s3">'cssclass' </span><span class="s2">in </span><span class="s1">self.options </span><span class="s2">and </span><span class="s3">'.'</span><span class="s1">+self.cssclass </span><span class="s2">or </span><span class="s3">''</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">isinstance(arg</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">args = [arg]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">args = list(arg)</span>

        <span class="s2">def </span><span class="s1">prefix(cls):</span>
            <span class="s2">if </span><span class="s1">cls:</span>
                <span class="s1">cls = </span><span class="s3">'.' </span><span class="s1">+ cls</span>
            <span class="s1">tmp = []</span>
            <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">args:</span>
                <span class="s1">tmp.append((arg </span><span class="s2">and </span><span class="s1">arg + </span><span class="s3">' ' </span><span class="s2">or </span><span class="s3">''</span><span class="s1">) + cls)</span>
            <span class="s2">return </span><span class="s3">', '</span><span class="s1">.join(tmp)</span>

        <span class="s2">return </span><span class="s1">prefix</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_pre_style(self):</span>
        <span class="s2">return </span><span class="s3">'line-height: 125%;'</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_linenos_style(self):</span>
        <span class="s2">return </span><span class="s3">'color: %s; background-color: %s; padding-left: 5px; padding-right: 5px;' </span><span class="s1">% (</span>
            <span class="s1">self.style.line_number_color</span><span class="s2">,</span>
            <span class="s1">self.style.line_number_background_color</span>
        <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_linenos_special_style(self):</span>
        <span class="s2">return </span><span class="s3">'color: %s; background-color: %s; padding-left: 5px; padding-right: 5px;' </span><span class="s1">% (</span>
            <span class="s1">self.style.line_number_special_color</span><span class="s2">,</span>
            <span class="s1">self.style.line_number_special_background_color</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_decodeifneeded(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s2">if </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">bytes):</span>
            <span class="s2">if </span><span class="s1">self.encoding:</span>
                <span class="s2">return </span><span class="s1">value.decode(self.encoding)</span>
            <span class="s2">return </span><span class="s1">value.decode()</span>
        <span class="s2">return </span><span class="s1">value</span>

    <span class="s2">def </span><span class="s1">_wrap_full(self</span><span class="s2">, </span><span class="s1">inner</span><span class="s2">, </span><span class="s1">outfile):</span>
        <span class="s2">if </span><span class="s1">self.cssfile:</span>
            <span class="s2">if </span><span class="s1">os.path.isabs(self.cssfile):</span>
                <span class="s5"># it's an absolute filename</span>
                <span class="s1">cssfilename = self.cssfile</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">filename = outfile.name</span>
                    <span class="s2">if not </span><span class="s1">filename </span><span class="s2">or </span><span class="s1">filename[</span><span class="s4">0</span><span class="s1">] == </span><span class="s3">'&lt;'</span><span class="s1">:</span>
                        <span class="s5"># pseudo files, e.g. name == '&lt;fdopen&gt;'</span>
                        <span class="s2">raise </span><span class="s1">AttributeError</span>
                    <span class="s1">cssfilename = os.path.join(os.path.dirname(filename)</span><span class="s2">,</span>
                                               <span class="s1">self.cssfile)</span>
                <span class="s2">except </span><span class="s1">AttributeError:</span>
                    <span class="s1">print(</span><span class="s3">'Note: Cannot determine output file name, '</span>
                          <span class="s3">'using current directory as base for the CSS file name'</span><span class="s2">,</span>
                          <span class="s1">file=sys.stderr)</span>
                    <span class="s1">cssfilename = self.cssfile</span>
            <span class="s5"># write CSS file only if noclobber_cssfile isn't given as an option.</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">if not </span><span class="s1">os.path.exists(cssfilename) </span><span class="s2">or not </span><span class="s1">self.noclobber_cssfile:</span>
                    <span class="s2">with </span><span class="s1">open(cssfilename</span><span class="s2">, </span><span class="s3">&quot;w&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">cf:</span>
                        <span class="s1">cf.write(CSSFILE_TEMPLATE %</span>
                                 <span class="s1">{</span><span class="s3">'styledefs'</span><span class="s1">: self.get_style_defs(</span><span class="s3">'body'</span><span class="s1">)})</span>
            <span class="s2">except </span><span class="s1">OSError </span><span class="s2">as </span><span class="s1">err:</span>
                <span class="s1">err.strerror = </span><span class="s3">'Error writing CSS file: ' </span><span class="s1">+ err.strerror</span>
                <span class="s2">raise</span>

            <span class="s2">yield </span><span class="s4">0</span><span class="s2">, </span><span class="s1">(DOC_HEADER_EXTERNALCSS %</span>
                      <span class="s1">dict(title=self.title</span><span class="s2">,</span>
                           <span class="s1">cssfile=self.cssfile</span><span class="s2">,</span>
                           <span class="s1">encoding=self.encoding))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s4">0</span><span class="s2">, </span><span class="s1">(DOC_HEADER %</span>
                      <span class="s1">dict(title=self.title</span><span class="s2">,</span>
                           <span class="s1">styledefs=self.get_style_defs(</span><span class="s3">'body'</span><span class="s1">)</span><span class="s2">,</span>
                           <span class="s1">encoding=self.encoding))</span>

        <span class="s2">yield from </span><span class="s1">inner</span>
        <span class="s2">yield </span><span class="s4">0</span><span class="s2">, </span><span class="s1">DOC_FOOTER</span>

    <span class="s2">def </span><span class="s1">_wrap_tablelinenos(self</span><span class="s2">, </span><span class="s1">inner):</span>
        <span class="s1">dummyoutfile = StringIO()</span>
        <span class="s1">lncount = </span><span class="s4">0</span>
        <span class="s2">for </span><span class="s1">t</span><span class="s2">, </span><span class="s1">line </span><span class="s2">in </span><span class="s1">inner:</span>
            <span class="s2">if </span><span class="s1">t:</span>
                <span class="s1">lncount += </span><span class="s4">1</span>
            <span class="s1">dummyoutfile.write(line)</span>

        <span class="s1">fl = self.linenostart</span>
        <span class="s1">mw = len(str(lncount + fl - </span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">sp = self.linenospecial</span>
        <span class="s1">st = self.linenostep</span>
        <span class="s1">anchor_name = self.lineanchors </span><span class="s2">or </span><span class="s1">self.linespans</span>
        <span class="s1">aln = self.anchorlinenos</span>
        <span class="s1">nocls = self.noclasses</span>

        <span class="s1">lines = []</span>

        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(fl</span><span class="s2">, </span><span class="s1">fl+lncount):</span>
            <span class="s1">print_line = i % st == </span><span class="s4">0</span>
            <span class="s1">special_line = sp </span><span class="s2">and </span><span class="s1">i % sp == </span><span class="s4">0</span>

            <span class="s2">if </span><span class="s1">print_line:</span>
                <span class="s1">line = </span><span class="s3">'%*d' </span><span class="s1">% (mw</span><span class="s2">, </span><span class="s1">i)</span>
                <span class="s2">if </span><span class="s1">aln:</span>
                    <span class="s1">line = </span><span class="s3">'&lt;a href=&quot;#%s-%d&quot;&gt;%s&lt;/a&gt;' </span><span class="s1">% (anchor_name</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">line)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">line = </span><span class="s3">' ' </span><span class="s1">* mw</span>

            <span class="s2">if </span><span class="s1">nocls:</span>
                <span class="s2">if </span><span class="s1">special_line:</span>
                    <span class="s1">style = </span><span class="s3">' style=&quot;%s&quot;' </span><span class="s1">% self._linenos_special_style</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">style = </span><span class="s3">' style=&quot;%s&quot;' </span><span class="s1">% self._linenos_style</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">special_line:</span>
                    <span class="s1">style = </span><span class="s3">' class=&quot;special&quot;'</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">style = </span><span class="s3">' class=&quot;normal&quot;'</span>

            <span class="s2">if </span><span class="s1">style:</span>
                <span class="s1">line = </span><span class="s3">'&lt;span%s&gt;%s&lt;/span&gt;' </span><span class="s1">% (style</span><span class="s2">, </span><span class="s1">line)</span>

            <span class="s1">lines.append(line)</span>

        <span class="s1">ls = </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">.join(lines)</span>

        <span class="s5"># If a filename was specified, we can't put it into the code table as it</span>
        <span class="s5"># would misalign the line numbers. Hence we emit a separate row for it.</span>
        <span class="s1">filename_tr = </span><span class="s3">&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.filename:</span>
            <span class="s1">filename_tr = (</span>
                <span class="s3">'&lt;tr&gt;&lt;th colspan=&quot;2&quot; class=&quot;filename&quot;&gt;'</span>
                <span class="s3">'&lt;span class=&quot;filename&quot;&gt;' </span><span class="s1">+ self.filename + </span><span class="s3">'&lt;/span&gt;'</span>
                <span class="s3">'&lt;/th&gt;&lt;/tr&gt;'</span><span class="s1">)</span>

        <span class="s5"># in case you wonder about the seemingly redundant &lt;div&gt; here: since the</span>
        <span class="s5"># content in the other cell also is wrapped in a div, some browsers in</span>
        <span class="s5"># some configurations seem to mess up the formatting...</span>
        <span class="s2">yield </span><span class="s4">0</span><span class="s2">, </span><span class="s1">(</span><span class="s3">f'&lt;table class=&quot;</span><span class="s2">{</span><span class="s1">self.cssclass</span><span class="s2">}</span><span class="s3">table&quot;&gt;' </span><span class="s1">+ filename_tr +</span>
            <span class="s3">'&lt;tr&gt;&lt;td class=&quot;linenos&quot;&gt;&lt;div class=&quot;linenodiv&quot;&gt;&lt;pre&gt;' </span><span class="s1">+</span>
            <span class="s1">ls + </span><span class="s3">'&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;'</span><span class="s1">)</span>
        <span class="s2">yield </span><span class="s4">0</span><span class="s2">, </span><span class="s3">'&lt;div&gt;'</span>
        <span class="s2">yield </span><span class="s4">0</span><span class="s2">, </span><span class="s1">dummyoutfile.getvalue()</span>
        <span class="s2">yield </span><span class="s4">0</span><span class="s2">, </span><span class="s3">'&lt;/div&gt;'</span>
        <span class="s2">yield </span><span class="s4">0</span><span class="s2">, </span><span class="s3">'&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;'</span>
        

    <span class="s2">def </span><span class="s1">_wrap_inlinelinenos(self</span><span class="s2">, </span><span class="s1">inner):</span>
        <span class="s5"># need a list of lines since we need the width of a single number :(</span>
        <span class="s1">inner_lines = list(inner)</span>
        <span class="s1">sp = self.linenospecial</span>
        <span class="s1">st = self.linenostep</span>
        <span class="s1">num = self.linenostart</span>
        <span class="s1">mw = len(str(len(inner_lines) + num - </span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">anchor_name = self.lineanchors </span><span class="s2">or </span><span class="s1">self.linespans</span>
        <span class="s1">aln = self.anchorlinenos</span>
        <span class="s1">nocls = self.noclasses</span>

        <span class="s2">for </span><span class="s1">_</span><span class="s2">, </span><span class="s1">inner_line </span><span class="s2">in </span><span class="s1">inner_lines:</span>
            <span class="s1">print_line = num % st == </span><span class="s4">0</span>
            <span class="s1">special_line = sp </span><span class="s2">and </span><span class="s1">num % sp == </span><span class="s4">0</span>

            <span class="s2">if </span><span class="s1">print_line:</span>
                <span class="s1">line = </span><span class="s3">'%*d' </span><span class="s1">% (mw</span><span class="s2">, </span><span class="s1">num)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">line = </span><span class="s3">' ' </span><span class="s1">* mw</span>

            <span class="s2">if </span><span class="s1">nocls:</span>
                <span class="s2">if </span><span class="s1">special_line:</span>
                    <span class="s1">style = </span><span class="s3">' style=&quot;%s&quot;' </span><span class="s1">% self._linenos_special_style</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">style = </span><span class="s3">' style=&quot;%s&quot;' </span><span class="s1">% self._linenos_style</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">special_line:</span>
                    <span class="s1">style = </span><span class="s3">' class=&quot;linenos special&quot;'</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">style = </span><span class="s3">' class=&quot;linenos&quot;'</span>

            <span class="s2">if </span><span class="s1">style:</span>
                <span class="s1">linenos = </span><span class="s3">'&lt;span%s&gt;%s&lt;/span&gt;' </span><span class="s1">% (style</span><span class="s2">, </span><span class="s1">line)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">linenos = line</span>

            <span class="s2">if </span><span class="s1">aln:</span>
                <span class="s2">yield </span><span class="s4">1</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'&lt;a href=&quot;#%s-%d&quot;&gt;%s&lt;/a&gt;' </span><span class="s1">% (anchor_name</span><span class="s2">, </span><span class="s1">num</span><span class="s2">, </span><span class="s1">linenos) +</span>
                          <span class="s1">inner_line)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">yield </span><span class="s4">1</span><span class="s2">, </span><span class="s1">linenos + inner_line</span>
            <span class="s1">num += </span><span class="s4">1</span>

    <span class="s2">def </span><span class="s1">_wrap_lineanchors(self</span><span class="s2">, </span><span class="s1">inner):</span>
        <span class="s1">s = self.lineanchors</span>
        <span class="s5"># subtract 1 since we have to increment i *before* yielding</span>
        <span class="s1">i = self.linenostart - </span><span class="s4">1</span>
        <span class="s2">for </span><span class="s1">t</span><span class="s2">, </span><span class="s1">line </span><span class="s2">in </span><span class="s1">inner:</span>
            <span class="s2">if </span><span class="s1">t:</span>
                <span class="s1">i += </span><span class="s4">1</span>
                <span class="s1">href = </span><span class="s3">&quot;&quot; </span><span class="s2">if </span><span class="s1">self.linenos </span><span class="s2">else </span><span class="s3">' href=&quot;#%s-%d&quot;' </span><span class="s1">% (s</span><span class="s2">, </span><span class="s1">i)</span>
                <span class="s2">yield </span><span class="s4">1</span><span class="s2">, </span><span class="s3">'&lt;a id=&quot;%s-%d&quot; name=&quot;%s-%d&quot;%s&gt;&lt;/a&gt;' </span><span class="s1">% (s</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">href) + line</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">yield </span><span class="s4">0</span><span class="s2">, </span><span class="s1">line</span>

    <span class="s2">def </span><span class="s1">_wrap_linespans(self</span><span class="s2">, </span><span class="s1">inner):</span>
        <span class="s1">s = self.linespans</span>
        <span class="s1">i = self.linenostart - </span><span class="s4">1</span>
        <span class="s2">for </span><span class="s1">t</span><span class="s2">, </span><span class="s1">line </span><span class="s2">in </span><span class="s1">inner:</span>
            <span class="s2">if </span><span class="s1">t:</span>
                <span class="s1">i += </span><span class="s4">1</span>
                <span class="s2">yield </span><span class="s4">1</span><span class="s2">, </span><span class="s3">'&lt;span id=&quot;%s-%d&quot;&gt;%s&lt;/span&gt;' </span><span class="s1">% (s</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">line)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">yield </span><span class="s4">0</span><span class="s2">, </span><span class="s1">line</span>

    <span class="s2">def </span><span class="s1">_wrap_div(self</span><span class="s2">, </span><span class="s1">inner):</span>
        <span class="s1">style = []</span>
        <span class="s2">if </span><span class="s1">(self.noclasses </span><span class="s2">and not </span><span class="s1">self.nobackground </span><span class="s2">and</span>
                <span class="s1">self.style.background_color </span><span class="s2">is not None</span><span class="s1">):</span>
            <span class="s1">style.append(</span><span class="s3">'background: %s' </span><span class="s1">% (self.style.background_color</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">self.cssstyles:</span>
            <span class="s1">style.append(self.cssstyles)</span>
        <span class="s1">style = </span><span class="s3">'; '</span><span class="s1">.join(style)</span>

        <span class="s2">yield </span><span class="s4">0</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'&lt;div' </span><span class="s1">+ (self.cssclass </span><span class="s2">and </span><span class="s3">' class=&quot;%s&quot;' </span><span class="s1">% self.cssclass) +</span>
                  <span class="s1">(style </span><span class="s2">and </span><span class="s1">(</span><span class="s3">' style=&quot;%s&quot;' </span><span class="s1">% style)) + </span><span class="s3">'&gt;'</span><span class="s1">)</span>
        <span class="s2">yield from </span><span class="s1">inner</span>
        <span class="s2">yield </span><span class="s4">0</span><span class="s2">, </span><span class="s3">'&lt;/div&gt;</span><span class="s2">\n</span><span class="s3">'</span>

    <span class="s2">def </span><span class="s1">_wrap_pre(self</span><span class="s2">, </span><span class="s1">inner):</span>
        <span class="s1">style = []</span>
        <span class="s2">if </span><span class="s1">self.prestyles:</span>
            <span class="s1">style.append(self.prestyles)</span>
        <span class="s2">if </span><span class="s1">self.noclasses:</span>
            <span class="s1">style.append(self._pre_style)</span>
        <span class="s1">style = </span><span class="s3">'; '</span><span class="s1">.join(style)</span>

        <span class="s2">if </span><span class="s1">self.filename </span><span class="s2">and </span><span class="s1">self.linenos != </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s4">0</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'&lt;span class=&quot;filename&quot;&gt;' </span><span class="s1">+ self.filename + </span><span class="s3">'&lt;/span&gt;'</span><span class="s1">)</span>

        <span class="s5"># the empty span here is to keep leading empty lines from being</span>
        <span class="s5"># ignored by HTML parsers</span>
        <span class="s2">yield </span><span class="s4">0</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'&lt;pre' </span><span class="s1">+ (style </span><span class="s2">and </span><span class="s3">' style=&quot;%s&quot;' </span><span class="s1">% style) + </span><span class="s3">'&gt;&lt;span&gt;&lt;/span&gt;'</span><span class="s1">)</span>
        <span class="s2">yield from </span><span class="s1">inner</span>
        <span class="s2">yield </span><span class="s4">0</span><span class="s2">, </span><span class="s3">'&lt;/pre&gt;'</span>

    <span class="s2">def </span><span class="s1">_wrap_code(self</span><span class="s2">, </span><span class="s1">inner):</span>
        <span class="s2">yield </span><span class="s4">0</span><span class="s2">, </span><span class="s3">'&lt;code&gt;'</span>
        <span class="s2">yield from </span><span class="s1">inner</span>
        <span class="s2">yield </span><span class="s4">0</span><span class="s2">, </span><span class="s3">'&lt;/code&gt;'</span>

    <span class="s1">@functools.lru_cache(maxsize=</span><span class="s4">100</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">_translate_parts(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s0">&quot;&quot;&quot;HTML-escape a value and split it by newlines.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">value.translate(_escape_html_table).split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_format_lines(self</span><span class="s2">, </span><span class="s1">tokensource):</span>
        <span class="s0">&quot;&quot;&quot; 
        Just format the tokens, without any wrapping tags. 
        Yield individual lines. 
        &quot;&quot;&quot;</span>
        <span class="s1">nocls = self.noclasses</span>
        <span class="s1">lsep = self.lineseparator</span>
        <span class="s1">tagsfile = self.tagsfile</span>

        <span class="s1">lspan = </span><span class="s3">''</span>
        <span class="s1">line = []</span>
        <span class="s2">for </span><span class="s1">ttype</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">tokensource:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">cspan = self.span_element_openers[ttype]</span>
            <span class="s2">except </span><span class="s1">KeyError:</span>
                <span class="s1">title = </span><span class="s3">' title=&quot;%s&quot;' </span><span class="s1">% </span><span class="s3">'.'</span><span class="s1">.join(ttype) </span><span class="s2">if </span><span class="s1">self.debug_token_types </span><span class="s2">else </span><span class="s3">''</span>
                <span class="s2">if </span><span class="s1">nocls:</span>
                    <span class="s1">css_style = self._get_css_inline_styles(ttype)</span>
                    <span class="s2">if </span><span class="s1">css_style:</span>
                        <span class="s1">css_style = self.class2style[css_style][</span><span class="s4">0</span><span class="s1">]</span>
                        <span class="s1">cspan = </span><span class="s3">'&lt;span style=&quot;%s&quot;%s&gt;' </span><span class="s1">% (css_style</span><span class="s2">, </span><span class="s1">title)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">cspan = </span><span class="s3">''</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">css_class = self._get_css_classes(ttype)</span>
                    <span class="s2">if </span><span class="s1">css_class:</span>
                        <span class="s1">cspan = </span><span class="s3">'&lt;span class=&quot;%s&quot;%s&gt;' </span><span class="s1">% (css_class</span><span class="s2">, </span><span class="s1">title)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">cspan = </span><span class="s3">''</span>
                <span class="s1">self.span_element_openers[ttype] = cspan</span>

            <span class="s1">parts = self._translate_parts(value)</span>

            <span class="s2">if </span><span class="s1">tagsfile </span><span class="s2">and </span><span class="s1">ttype </span><span class="s2">in </span><span class="s1">Token.Name:</span>
                <span class="s1">filename</span><span class="s2">, </span><span class="s1">linenumber = self._lookup_ctag(value)</span>
                <span class="s2">if </span><span class="s1">linenumber:</span>
                    <span class="s1">base</span><span class="s2">, </span><span class="s1">filename = os.path.split(filename)</span>
                    <span class="s2">if </span><span class="s1">base:</span>
                        <span class="s1">base += </span><span class="s3">'/'</span>
                    <span class="s1">filename</span><span class="s2">, </span><span class="s1">extension = os.path.splitext(filename)</span>
                    <span class="s1">url = self.tagurlformat % {</span><span class="s3">'path'</span><span class="s1">: base</span><span class="s2">, </span><span class="s3">'fname'</span><span class="s1">: filename</span><span class="s2">,</span>
                                               <span class="s3">'fext'</span><span class="s1">: extension}</span>
                    <span class="s1">parts[</span><span class="s4">0</span><span class="s1">] = </span><span class="s3">&quot;&lt;a href=</span><span class="s2">\&quot;</span><span class="s3">%s#%s-%d</span><span class="s2">\&quot;</span><span class="s3">&gt;%s&quot; </span><span class="s1">% \</span>
                        <span class="s1">(url</span><span class="s2">, </span><span class="s1">self.lineanchors</span><span class="s2">, </span><span class="s1">linenumber</span><span class="s2">, </span><span class="s1">parts[</span><span class="s4">0</span><span class="s1">])</span>
                    <span class="s1">parts[-</span><span class="s4">1</span><span class="s1">] = parts[-</span><span class="s4">1</span><span class="s1">] + </span><span class="s3">&quot;&lt;/a&gt;&quot;</span>

            <span class="s5"># for all but the last line</span>
            <span class="s2">for </span><span class="s1">part </span><span class="s2">in </span><span class="s1">parts[:-</span><span class="s4">1</span><span class="s1">]:</span>
                <span class="s2">if </span><span class="s1">line:</span>
                    <span class="s2">if </span><span class="s1">lspan != cspan:</span>
                        <span class="s1">line.extend(((lspan </span><span class="s2">and </span><span class="s3">'&lt;/span&gt;'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">cspan</span><span class="s2">, </span><span class="s1">part</span><span class="s2">,</span>
                                     <span class="s1">(cspan </span><span class="s2">and </span><span class="s3">'&lt;/span&gt;'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">lsep))</span>
                    <span class="s2">else</span><span class="s1">:  </span><span class="s5"># both are the same</span>
                        <span class="s1">line.extend((part</span><span class="s2">, </span><span class="s1">(lspan </span><span class="s2">and </span><span class="s3">'&lt;/span&gt;'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">lsep))</span>
                    <span class="s2">yield </span><span class="s4">1</span><span class="s2">, </span><span class="s3">''</span><span class="s1">.join(line)</span>
                    <span class="s1">line = []</span>
                <span class="s2">elif </span><span class="s1">part:</span>
                    <span class="s2">yield </span><span class="s4">1</span><span class="s2">, </span><span class="s3">''</span><span class="s1">.join((cspan</span><span class="s2">, </span><span class="s1">part</span><span class="s2">, </span><span class="s1">(cspan </span><span class="s2">and </span><span class="s3">'&lt;/span&gt;'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">lsep))</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">yield </span><span class="s4">1</span><span class="s2">, </span><span class="s1">lsep</span>
            <span class="s5"># for the last line</span>
            <span class="s2">if </span><span class="s1">line </span><span class="s2">and </span><span class="s1">parts[-</span><span class="s4">1</span><span class="s1">]:</span>
                <span class="s2">if </span><span class="s1">lspan != cspan:</span>
                    <span class="s1">line.extend(((lspan </span><span class="s2">and </span><span class="s3">'&lt;/span&gt;'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">cspan</span><span class="s2">, </span><span class="s1">parts[-</span><span class="s4">1</span><span class="s1">]))</span>
                    <span class="s1">lspan = cspan</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">line.append(parts[-</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s2">elif </span><span class="s1">parts[-</span><span class="s4">1</span><span class="s1">]:</span>
                <span class="s1">line = [cspan</span><span class="s2">, </span><span class="s1">parts[-</span><span class="s4">1</span><span class="s1">]]</span>
                <span class="s1">lspan = cspan</span>
            <span class="s5"># else we neither have to open a new span nor set lspan</span>

        <span class="s2">if </span><span class="s1">line:</span>
            <span class="s1">line.extend(((lspan </span><span class="s2">and </span><span class="s3">'&lt;/span&gt;'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">lsep))</span>
            <span class="s2">yield </span><span class="s4">1</span><span class="s2">, </span><span class="s3">''</span><span class="s1">.join(line)</span>

    <span class="s2">def </span><span class="s1">_lookup_ctag(self</span><span class="s2">, </span><span class="s1">token):</span>
        <span class="s1">entry = ctags.TagEntry()</span>
        <span class="s2">if </span><span class="s1">self._ctags.find(entry</span><span class="s2">, </span><span class="s1">token.encode()</span><span class="s2">, </span><span class="s4">0</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">entry[</span><span class="s3">'file'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">entry[</span><span class="s3">'lineNumber'</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return None, None</span>

    <span class="s2">def </span><span class="s1">_highlight_lines(self</span><span class="s2">, </span><span class="s1">tokensource):</span>
        <span class="s0">&quot;&quot;&quot; 
        Highlighted the lines specified in the `hl_lines` option by 
        post-processing the token stream coming from `_format_lines`. 
        &quot;&quot;&quot;</span>
        <span class="s1">hls = self.hl_lines</span>

        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">(t</span><span class="s2">, </span><span class="s1">value) </span><span class="s2">in </span><span class="s1">enumerate(tokensource):</span>
            <span class="s2">if </span><span class="s1">t != </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s2">yield </span><span class="s1">t</span><span class="s2">, </span><span class="s1">value</span>
            <span class="s2">if </span><span class="s1">i + </span><span class="s4">1 </span><span class="s2">in </span><span class="s1">hls:  </span><span class="s5"># i + 1 because Python indexes start at 0</span>
                <span class="s2">if </span><span class="s1">self.noclasses:</span>
                    <span class="s1">style = </span><span class="s3">''</span>
                    <span class="s2">if </span><span class="s1">self.style.highlight_color </span><span class="s2">is not None</span><span class="s1">:</span>
                        <span class="s1">style = (</span><span class="s3">' style=&quot;background-color: %s&quot;' </span><span class="s1">%</span>
                                 <span class="s1">(self.style.highlight_color</span><span class="s2">,</span><span class="s1">))</span>
                    <span class="s2">yield </span><span class="s4">1</span><span class="s2">, </span><span class="s3">'&lt;span%s&gt;%s&lt;/span&gt;' </span><span class="s1">% (style</span><span class="s2">, </span><span class="s1">value)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">yield </span><span class="s4">1</span><span class="s2">, </span><span class="s3">'&lt;span class=&quot;hll&quot;&gt;%s&lt;/span&gt;' </span><span class="s1">% value</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">yield </span><span class="s4">1</span><span class="s2">, </span><span class="s1">value</span>

    <span class="s2">def </span><span class="s1">wrap(self</span><span class="s2">, </span><span class="s1">source):</span>
        <span class="s0">&quot;&quot;&quot; 
        Wrap the ``source``, which is a generator yielding 
        individual lines, in custom generators. See docstring 
        for `format`. Can be overridden. 
        &quot;&quot;&quot;</span>

        <span class="s1">output = source</span>
        <span class="s2">if </span><span class="s1">self.wrapcode:</span>
            <span class="s1">output = self._wrap_code(output)</span>
        
        <span class="s1">output = self._wrap_pre(output)</span>
    
        <span class="s2">return </span><span class="s1">output</span>

    <span class="s2">def </span><span class="s1">format_unencoded(self</span><span class="s2">, </span><span class="s1">tokensource</span><span class="s2">, </span><span class="s1">outfile):</span>
        <span class="s0">&quot;&quot;&quot; 
        The formatting process uses several nested generators; which of 
        them are used is determined by the user's options. 
 
        Each generator should take at least one argument, ``inner``, 
        and wrap the pieces of text generated by this. 
 
        Always yield 2-tuples: (code, text). If &quot;code&quot; is 1, the text 
        is part of the original tokensource being highlighted, if it's 
        0, the text is some piece of wrapping. This makes it possible to 
        use several different wrappers that process the original source 
        linewise, e.g. line number generators. 
        &quot;&quot;&quot;</span>
        <span class="s1">source = self._format_lines(tokensource)</span>

        <span class="s5"># As a special case, we wrap line numbers before line highlighting</span>
        <span class="s5"># so the line numbers get wrapped in the highlighting tag.</span>
        <span class="s2">if not </span><span class="s1">self.nowrap </span><span class="s2">and </span><span class="s1">self.linenos == </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s1">source = self._wrap_inlinelinenos(source)</span>

        <span class="s2">if </span><span class="s1">self.hl_lines:</span>
            <span class="s1">source = self._highlight_lines(source)</span>

        <span class="s2">if not </span><span class="s1">self.nowrap:</span>
            <span class="s2">if </span><span class="s1">self.lineanchors:</span>
                <span class="s1">source = self._wrap_lineanchors(source)</span>
            <span class="s2">if </span><span class="s1">self.linespans:</span>
                <span class="s1">source = self._wrap_linespans(source)</span>
            <span class="s1">source = self.wrap(source)</span>
            <span class="s2">if </span><span class="s1">self.linenos == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">source = self._wrap_tablelinenos(source)</span>
            <span class="s1">source = self._wrap_div(source)</span>
            <span class="s2">if </span><span class="s1">self.full:</span>
                <span class="s1">source = self._wrap_full(source</span><span class="s2">, </span><span class="s1">outfile)</span>

        <span class="s2">for </span><span class="s1">t</span><span class="s2">, </span><span class="s1">piece </span><span class="s2">in </span><span class="s1">source:</span>
            <span class="s1">outfile.write(piece)</span>
</pre>
</body>
</html>