<html>
<head>
<title>link.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6a8759;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
link.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">functools</span>
<span class="s0">import </span><span class="s1">itertools</span>
<span class="s0">import </span><span class="s1">logging</span>
<span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">posixpath</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">import </span><span class="s1">urllib.parse</span>
<span class="s0">from </span><span class="s1">dataclasses </span><span class="s0">import </span><span class="s1">dataclass</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s0">,</span>
    <span class="s1">Any</span><span class="s0">,</span>
    <span class="s1">Dict</span><span class="s0">,</span>
    <span class="s1">List</span><span class="s0">,</span>
    <span class="s1">Mapping</span><span class="s0">,</span>
    <span class="s1">NamedTuple</span><span class="s0">,</span>
    <span class="s1">Optional</span><span class="s0">,</span>
    <span class="s1">Tuple</span><span class="s0">,</span>
    <span class="s1">Union</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">from </span><span class="s1">pip._internal.utils.filetypes </span><span class="s0">import </span><span class="s1">WHEEL_EXTENSION</span>
<span class="s0">from </span><span class="s1">pip._internal.utils.hashes </span><span class="s0">import </span><span class="s1">Hashes</span>
<span class="s0">from </span><span class="s1">pip._internal.utils.misc </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">pairwise</span><span class="s0">,</span>
    <span class="s1">redact_auth_from_url</span><span class="s0">,</span>
    <span class="s1">split_auth_from_netloc</span><span class="s0">,</span>
    <span class="s1">splitext</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pip._internal.utils.models </span><span class="s0">import </span><span class="s1">KeyBasedCompareMixin</span>
<span class="s0">from </span><span class="s1">pip._internal.utils.urls </span><span class="s0">import </span><span class="s1">path_to_url</span><span class="s0">, </span><span class="s1">url_to_path</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s0">from </span><span class="s1">pip._internal.index.collector </span><span class="s0">import </span><span class="s1">IndexContent</span>

<span class="s1">logger = logging.getLogger(__name__)</span>


<span class="s2"># Order matters, earlier hashes have a precedence over later hashes for what</span>
<span class="s2"># we will pick to use.</span>
<span class="s1">_SUPPORTED_HASHES = (</span><span class="s3">&quot;sha512&quot;</span><span class="s0">, </span><span class="s3">&quot;sha384&quot;</span><span class="s0">, </span><span class="s3">&quot;sha256&quot;</span><span class="s0">, </span><span class="s3">&quot;sha224&quot;</span><span class="s0">, </span><span class="s3">&quot;sha1&quot;</span><span class="s0">, </span><span class="s3">&quot;md5&quot;</span><span class="s1">)</span>


<span class="s1">@dataclass(frozen=</span><span class="s0">True</span><span class="s1">)</span>
<span class="s0">class </span><span class="s1">LinkHash:</span>
    <span class="s4">&quot;&quot;&quot;Links to content may have embedded hash values. This class parses those. 
 
    `name` must be any member of `_SUPPORTED_HASHES`. 
 
    This class can be converted to and from `ArchiveInfo`. While ArchiveInfo intends to 
    be JSON-serializable to conform to PEP 610, this class contains the logic for 
    parsing a hash name and value for correctness, and then checking whether that hash 
    conforms to a schema with `.is_hash_allowed()`.&quot;&quot;&quot;</span>

    <span class="s1">name: str</span>
    <span class="s1">value: str</span>

    <span class="s1">_hash_re = re.compile(</span>
        <span class="s2"># NB: we do not validate that the second group (.*) is a valid hex</span>
        <span class="s2"># digest. Instead, we simply keep that string in this class, and then check it</span>
        <span class="s2"># against Hashes when hash-checking is needed. This is easier to debug than</span>
        <span class="s2"># proactively discarding an invalid hex digest, as we handle incorrect hashes</span>
        <span class="s2"># and malformed hashes in the same place.</span>
        <span class="s3">r&quot;({choices})=(.*)&quot;</span><span class="s1">.format(</span>
            <span class="s1">choices=</span><span class="s3">&quot;|&quot;</span><span class="s1">.join(re.escape(hash_name) </span><span class="s0">for </span><span class="s1">hash_name </span><span class="s0">in </span><span class="s1">_SUPPORTED_HASHES)</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__post_init__(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">assert </span><span class="s1">self._hash_re.match(</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">self.name</span><span class="s0">}</span><span class="s3">=</span><span class="s0">{</span><span class="s1">self.value</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s1">@functools.lru_cache(maxsize=</span><span class="s0">None</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">split_hash_name_and_value(cls</span><span class="s0">, </span><span class="s1">url: str) -&gt; Optional[</span><span class="s3">&quot;LinkHash&quot;</span><span class="s1">]:</span>
        <span class="s4">&quot;&quot;&quot;Search a string for a checksum algorithm name and encoded output value.&quot;&quot;&quot;</span>
        <span class="s1">match = cls._hash_re.search(url)</span>
        <span class="s0">if </span><span class="s1">match </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return None</span>
        <span class="s1">name</span><span class="s0">, </span><span class="s1">value = match.groups()</span>
        <span class="s0">return </span><span class="s1">cls(name=name</span><span class="s0">, </span><span class="s1">value=value)</span>

    <span class="s0">def </span><span class="s1">as_hashes(self) -&gt; Hashes:</span>
        <span class="s4">&quot;&quot;&quot;Return a Hashes instance which checks only for the current hash.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">Hashes({self.name: [self.value]})</span>

    <span class="s0">def </span><span class="s1">is_hash_allowed(self</span><span class="s0">, </span><span class="s1">hashes: Optional[Hashes]) -&gt; bool:</span>
        <span class="s4">&quot;&quot;&quot; 
        Return True if the current hash is allowed by `hashes`. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">hashes </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return False</span>
        <span class="s0">return </span><span class="s1">hashes.is_hash_allowed(self.name</span><span class="s0">, </span><span class="s1">hex_digest=self.value)</span>


<span class="s0">def </span><span class="s1">_clean_url_path_part(part: str) -&gt; str:</span>
    <span class="s4">&quot;&quot;&quot; 
    Clean a &quot;part&quot; of a URL path (i.e. after splitting on &quot;@&quot; characters). 
    &quot;&quot;&quot;</span>
    <span class="s2"># We unquote prior to quoting to make sure nothing is double quoted.</span>
    <span class="s0">return </span><span class="s1">urllib.parse.quote(urllib.parse.unquote(part))</span>


<span class="s0">def </span><span class="s1">_clean_file_url_path(part: str) -&gt; str:</span>
    <span class="s4">&quot;&quot;&quot; 
    Clean the first part of a URL path that corresponds to a local 
    filesystem path (i.e. the first part after splitting on &quot;@&quot; characters). 
    &quot;&quot;&quot;</span>
    <span class="s2"># We unquote prior to quoting to make sure nothing is double quoted.</span>
    <span class="s2"># Also, on Windows the path part might contain a drive letter which</span>
    <span class="s2"># should not be quoted. On Linux where drive letters do not</span>
    <span class="s2"># exist, the colon should be quoted. We rely on urllib.request</span>
    <span class="s2"># to do the right thing here.</span>
    <span class="s0">return </span><span class="s1">urllib.request.pathname2url(urllib.request.url2pathname(part))</span>


<span class="s2"># percent-encoded:                   /</span>
<span class="s1">_reserved_chars_re = re.compile(</span><span class="s3">&quot;(@|%2F)&quot;</span><span class="s0">, </span><span class="s1">re.IGNORECASE)</span>


<span class="s0">def </span><span class="s1">_clean_url_path(path: str</span><span class="s0">, </span><span class="s1">is_local_path: bool) -&gt; str:</span>
    <span class="s4">&quot;&quot;&quot; 
    Clean the path portion of a URL. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">is_local_path:</span>
        <span class="s1">clean_func = _clean_file_url_path</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">clean_func = _clean_url_path_part</span>

    <span class="s2"># Split on the reserved characters prior to cleaning so that</span>
    <span class="s2"># revision strings in VCS URLs are properly preserved.</span>
    <span class="s1">parts = _reserved_chars_re.split(path)</span>

    <span class="s1">cleaned_parts = []</span>
    <span class="s0">for </span><span class="s1">to_clean</span><span class="s0">, </span><span class="s1">reserved </span><span class="s0">in </span><span class="s1">pairwise(itertools.chain(parts</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;&quot;</span><span class="s1">])):</span>
        <span class="s1">cleaned_parts.append(clean_func(to_clean))</span>
        <span class="s2"># Normalize %xx escapes (e.g. %2f -&gt; %2F)</span>
        <span class="s1">cleaned_parts.append(reserved.upper())</span>

    <span class="s0">return </span><span class="s3">&quot;&quot;</span><span class="s1">.join(cleaned_parts)</span>


<span class="s0">def </span><span class="s1">_ensure_quoted_url(url: str) -&gt; str:</span>
    <span class="s4">&quot;&quot;&quot; 
    Make sure a link is fully quoted. 
    For example, if ' ' occurs in the URL, it will be replaced with &quot;%20&quot;, 
    and without double-quoting other characters. 
    &quot;&quot;&quot;</span>
    <span class="s2"># Split the URL into parts according to the general structure</span>
    <span class="s2"># `scheme://netloc/path;parameters?query#fragment`.</span>
    <span class="s1">result = urllib.parse.urlparse(url)</span>
    <span class="s2"># If the netloc is empty, then the URL refers to a local filesystem path.</span>
    <span class="s1">is_local_path = </span><span class="s0">not </span><span class="s1">result.netloc</span>
    <span class="s1">path = _clean_url_path(result.path</span><span class="s0">, </span><span class="s1">is_local_path=is_local_path)</span>
    <span class="s0">return </span><span class="s1">urllib.parse.urlunparse(result._replace(path=path))</span>


<span class="s0">class </span><span class="s1">Link(KeyBasedCompareMixin):</span>
    <span class="s4">&quot;&quot;&quot;Represents a parsed link from a Package Index's simple URL&quot;&quot;&quot;</span>

    <span class="s1">__slots__ = [</span>
        <span class="s3">&quot;_parsed_url&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;_url&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;_hashes&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;comes_from&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;requires_python&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;yanked_reason&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;dist_info_metadata&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;link_hash&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;cache_link_parsing&quot;</span><span class="s0">,</span>
    <span class="s1">]</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">url: str</span><span class="s0">,</span>
        <span class="s1">comes_from: Optional[Union[str</span><span class="s0">, </span><span class="s3">&quot;IndexContent&quot;</span><span class="s1">]] = </span><span class="s0">None,</span>
        <span class="s1">requires_python: Optional[str] = </span><span class="s0">None,</span>
        <span class="s1">yanked_reason: Optional[str] = </span><span class="s0">None,</span>
        <span class="s1">dist_info_metadata: Optional[str] = </span><span class="s0">None,</span>
        <span class="s1">link_hash: Optional[LinkHash] = </span><span class="s0">None,</span>
        <span class="s1">cache_link_parsing: bool = </span><span class="s0">True,</span>
        <span class="s1">hashes: Optional[Mapping[str</span><span class="s0">, </span><span class="s1">str]] = </span><span class="s0">None,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        :param url: url of the resource pointed to (href of the link) 
        :param comes_from: instance of IndexContent where the link was found, 
            or string. 
        :param requires_python: String containing the `Requires-Python` 
            metadata field, specified in PEP 345. This may be specified by 
            a data-requires-python attribute in the HTML link tag, as 
            described in PEP 503. 
        :param yanked_reason: the reason the file has been yanked, if the 
            file has been yanked, or None if the file hasn't been yanked. 
            This is the value of the &quot;data-yanked&quot; attribute, if present, in 
            a simple repository HTML link. If the file has been yanked but 
            no reason was provided, this should be the empty string. See 
            PEP 592 for more information and the specification. 
        :param dist_info_metadata: the metadata attached to the file, or None if no such 
            metadata is provided. This is the value of the &quot;data-dist-info-metadata&quot; 
            attribute, if present, in a simple repository HTML link. This may be parsed 
            into its own `Link` by `self.metadata_link()`. See PEP 658 for more 
            information and the specification. 
        :param link_hash: a checksum for the content the link points to. If not 
            provided, this will be extracted from the link URL, if the URL has 
            any checksum. 
        :param cache_link_parsing: A flag that is used elsewhere to determine 
                                   whether resources retrieved from this link 
                                   should be cached. PyPI index urls should 
                                   generally have this set to False, for 
                                   example. 
        :param hashes: A mapping of hash names to digests to allow us to 
                       determine the validity of a download. 
        &quot;&quot;&quot;</span>

        <span class="s2"># url can be a UNC windows share</span>
        <span class="s0">if </span><span class="s1">url.startswith(</span><span class="s3">&quot;</span><span class="s0">\\\\</span><span class="s3">&quot;</span><span class="s1">):</span>
            <span class="s1">url = path_to_url(url)</span>

        <span class="s1">self._parsed_url = urllib.parse.urlsplit(url)</span>
        <span class="s2"># Store the url as a private attribute to prevent accidentally</span>
        <span class="s2"># trying to set a new value.</span>
        <span class="s1">self._url = url</span>
        <span class="s1">self._hashes = hashes </span><span class="s0">if </span><span class="s1">hashes </span><span class="s0">is not None else </span><span class="s1">{}</span>

        <span class="s1">self.comes_from = comes_from</span>
        <span class="s1">self.requires_python = requires_python </span><span class="s0">if </span><span class="s1">requires_python </span><span class="s0">else None</span>
        <span class="s1">self.yanked_reason = yanked_reason</span>
        <span class="s1">self.dist_info_metadata = dist_info_metadata</span>
        <span class="s1">self.link_hash = link_hash </span><span class="s0">or </span><span class="s1">LinkHash.split_hash_name_and_value(self._url)</span>

        <span class="s1">super().__init__(key=url</span><span class="s0">, </span><span class="s1">defining_class=Link)</span>

        <span class="s1">self.cache_link_parsing = cache_link_parsing</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_json(</span>
        <span class="s1">cls</span><span class="s0">,</span>
        <span class="s1">file_data: Dict[str</span><span class="s0">, </span><span class="s1">Any]</span><span class="s0">,</span>
        <span class="s1">page_url: str</span><span class="s0">,</span>
    <span class="s1">) -&gt; Optional[</span><span class="s3">&quot;Link&quot;</span><span class="s1">]:</span>
        <span class="s4">&quot;&quot;&quot; 
        Convert an pypi json document from a simple repository page into a Link. 
        &quot;&quot;&quot;</span>
        <span class="s1">file_url = file_data.get(</span><span class="s3">&quot;url&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">file_url </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return None</span>

        <span class="s1">url = _ensure_quoted_url(urllib.parse.urljoin(page_url</span><span class="s0">, </span><span class="s1">file_url))</span>
        <span class="s1">pyrequire = file_data.get(</span><span class="s3">&quot;requires-python&quot;</span><span class="s1">)</span>
        <span class="s1">yanked_reason = file_data.get(</span><span class="s3">&quot;yanked&quot;</span><span class="s1">)</span>
        <span class="s1">dist_info_metadata = file_data.get(</span><span class="s3">&quot;dist-info-metadata&quot;</span><span class="s1">)</span>
        <span class="s1">hashes = file_data.get(</span><span class="s3">&quot;hashes&quot;</span><span class="s0">, </span><span class="s1">{})</span>

        <span class="s2"># The Link.yanked_reason expects an empty string instead of a boolean.</span>
        <span class="s0">if </span><span class="s1">yanked_reason </span><span class="s0">and not </span><span class="s1">isinstance(yanked_reason</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s1">yanked_reason = </span><span class="s3">&quot;&quot;</span>
        <span class="s2"># The Link.yanked_reason expects None instead of False.</span>
        <span class="s0">elif not </span><span class="s1">yanked_reason:</span>
            <span class="s1">yanked_reason = </span><span class="s0">None</span>

        <span class="s0">return </span><span class="s1">cls(</span>
            <span class="s1">url</span><span class="s0">,</span>
            <span class="s1">comes_from=page_url</span><span class="s0">,</span>
            <span class="s1">requires_python=pyrequire</span><span class="s0">,</span>
            <span class="s1">yanked_reason=yanked_reason</span><span class="s0">,</span>
            <span class="s1">hashes=hashes</span><span class="s0">,</span>
            <span class="s1">dist_info_metadata=dist_info_metadata</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_element(</span>
        <span class="s1">cls</span><span class="s0">,</span>
        <span class="s1">anchor_attribs: Dict[str</span><span class="s0">, </span><span class="s1">Optional[str]]</span><span class="s0">,</span>
        <span class="s1">page_url: str</span><span class="s0">,</span>
        <span class="s1">base_url: str</span><span class="s0">,</span>
    <span class="s1">) -&gt; Optional[</span><span class="s3">&quot;Link&quot;</span><span class="s1">]:</span>
        <span class="s4">&quot;&quot;&quot; 
        Convert an anchor element's attributes in a simple repository page to a Link. 
        &quot;&quot;&quot;</span>
        <span class="s1">href = anchor_attribs.get(</span><span class="s3">&quot;href&quot;</span><span class="s1">)</span>
        <span class="s0">if not </span><span class="s1">href:</span>
            <span class="s0">return None</span>

        <span class="s1">url = _ensure_quoted_url(urllib.parse.urljoin(base_url</span><span class="s0">, </span><span class="s1">href))</span>
        <span class="s1">pyrequire = anchor_attribs.get(</span><span class="s3">&quot;data-requires-python&quot;</span><span class="s1">)</span>
        <span class="s1">yanked_reason = anchor_attribs.get(</span><span class="s3">&quot;data-yanked&quot;</span><span class="s1">)</span>
        <span class="s1">dist_info_metadata = anchor_attribs.get(</span><span class="s3">&quot;data-dist-info-metadata&quot;</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s1">cls(</span>
            <span class="s1">url</span><span class="s0">,</span>
            <span class="s1">comes_from=page_url</span><span class="s0">,</span>
            <span class="s1">requires_python=pyrequire</span><span class="s0">,</span>
            <span class="s1">yanked_reason=yanked_reason</span><span class="s0">,</span>
            <span class="s1">dist_info_metadata=dist_info_metadata</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__str__(self) -&gt; str:</span>
        <span class="s0">if </span><span class="s1">self.requires_python:</span>
            <span class="s1">rp = </span><span class="s3">f&quot; (requires-python:</span><span class="s0">{</span><span class="s1">self.requires_python</span><span class="s0">}</span><span class="s3">)&quot;</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">rp = </span><span class="s3">&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.comes_from:</span>
            <span class="s0">return </span><span class="s3">&quot;{} (from {}){}&quot;</span><span class="s1">.format(</span>
                <span class="s1">redact_auth_from_url(self._url)</span><span class="s0">, </span><span class="s1">self.comes_from</span><span class="s0">, </span><span class="s1">rp</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">redact_auth_from_url(str(self._url))</span>

    <span class="s0">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s3">f&quot;&lt;Link </span><span class="s0">{</span><span class="s1">self</span><span class="s0">}</span><span class="s3">&gt;&quot;</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">url(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s1">self._url</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">filename(self) -&gt; str:</span>
        <span class="s1">path = self.path.rstrip(</span><span class="s3">&quot;/&quot;</span><span class="s1">)</span>
        <span class="s1">name = posixpath.basename(path)</span>
        <span class="s0">if not </span><span class="s1">name:</span>
            <span class="s2"># Make sure we don't leak auth information if the netloc</span>
            <span class="s2"># includes a username and password.</span>
            <span class="s1">netloc</span><span class="s0">, </span><span class="s1">user_pass = split_auth_from_netloc(self.netloc)</span>
            <span class="s0">return </span><span class="s1">netloc</span>

        <span class="s1">name = urllib.parse.unquote(name)</span>
        <span class="s0">assert </span><span class="s1">name</span><span class="s0">, </span><span class="s3">f&quot;URL </span><span class="s0">{</span><span class="s1">self._url</span><span class="s0">!r} </span><span class="s3">produced no filename&quot;</span>
        <span class="s0">return </span><span class="s1">name</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">file_path(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s1">url_to_path(self.url)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">scheme(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s1">self._parsed_url.scheme</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">netloc(self) -&gt; str:</span>
        <span class="s4">&quot;&quot;&quot; 
        This can contain auth information. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._parsed_url.netloc</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">path(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s1">urllib.parse.unquote(self._parsed_url.path)</span>

    <span class="s0">def </span><span class="s1">splitext(self) -&gt; Tuple[str</span><span class="s0">, </span><span class="s1">str]:</span>
        <span class="s0">return </span><span class="s1">splitext(posixpath.basename(self.path.rstrip(</span><span class="s3">&quot;/&quot;</span><span class="s1">)))</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">ext(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s1">self.splitext()[</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">url_without_fragment(self) -&gt; str:</span>
        <span class="s1">scheme</span><span class="s0">, </span><span class="s1">netloc</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">query</span><span class="s0">, </span><span class="s1">fragment = self._parsed_url</span>
        <span class="s0">return </span><span class="s1">urllib.parse.urlunsplit((scheme</span><span class="s0">, </span><span class="s1">netloc</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">query</span><span class="s0">, </span><span class="s3">&quot;&quot;</span><span class="s1">))</span>

    <span class="s1">_egg_fragment_re = re.compile(</span><span class="s3">r&quot;[#&amp;]egg=([^&amp;]*)&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">egg_fragment(self) -&gt; Optional[str]:</span>
        <span class="s1">match = self._egg_fragment_re.search(self._url)</span>
        <span class="s0">if not </span><span class="s1">match:</span>
            <span class="s0">return None</span>
        <span class="s0">return </span><span class="s1">match.group(</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s1">_subdirectory_fragment_re = re.compile(</span><span class="s3">r&quot;[#&amp;]subdirectory=([^&amp;]*)&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">subdirectory_fragment(self) -&gt; Optional[str]:</span>
        <span class="s1">match = self._subdirectory_fragment_re.search(self._url)</span>
        <span class="s0">if not </span><span class="s1">match:</span>
            <span class="s0">return None</span>
        <span class="s0">return </span><span class="s1">match.group(</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">metadata_link(self) -&gt; Optional[</span><span class="s3">&quot;Link&quot;</span><span class="s1">]:</span>
        <span class="s4">&quot;&quot;&quot;Implementation of PEP 658 parsing.&quot;&quot;&quot;</span>
        <span class="s2"># Note that Link.from_element() parsing the &quot;data-dist-info-metadata&quot; attribute</span>
        <span class="s2"># from an HTML anchor tag is typically how the Link.dist_info_metadata attribute</span>
        <span class="s2"># gets set.</span>
        <span class="s0">if </span><span class="s1">self.dist_info_metadata </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return None</span>
        <span class="s1">metadata_url = </span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">self.url_without_fragment</span><span class="s0">}</span><span class="s3">.metadata&quot;</span>
        <span class="s1">link_hash: Optional[LinkHash] = </span><span class="s0">None</span>
        <span class="s2"># If data-dist-info-metadata=&quot;true&quot; is set, then the metadata file exists,</span>
        <span class="s2"># but there is no information about its checksum or anything else.</span>
        <span class="s0">if </span><span class="s1">self.dist_info_metadata != </span><span class="s3">&quot;true&quot;</span><span class="s1">:</span>
            <span class="s1">link_hash = LinkHash.split_hash_name_and_value(self.dist_info_metadata)</span>
        <span class="s0">return </span><span class="s1">Link(metadata_url</span><span class="s0">, </span><span class="s1">link_hash=link_hash)</span>

    <span class="s0">def </span><span class="s1">as_hashes(self) -&gt; Optional[Hashes]:</span>
        <span class="s0">if </span><span class="s1">self.link_hash </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.link_hash.as_hashes()</span>
        <span class="s0">return None</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">hash(self) -&gt; Optional[str]:</span>
        <span class="s0">if </span><span class="s1">self.link_hash </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.link_hash.value</span>
        <span class="s0">return None</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">hash_name(self) -&gt; Optional[str]:</span>
        <span class="s0">if </span><span class="s1">self.link_hash </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.link_hash.name</span>
        <span class="s0">return None</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">show_url(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s1">posixpath.basename(self._url.split(</span><span class="s3">&quot;#&quot;</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">].split(</span><span class="s3">&quot;?&quot;</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">])</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">is_file(self) -&gt; bool:</span>
        <span class="s0">return </span><span class="s1">self.scheme == </span><span class="s3">&quot;file&quot;</span>

    <span class="s0">def </span><span class="s1">is_existing_dir(self) -&gt; bool:</span>
        <span class="s0">return </span><span class="s1">self.is_file </span><span class="s0">and </span><span class="s1">os.path.isdir(self.file_path)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">is_wheel(self) -&gt; bool:</span>
        <span class="s0">return </span><span class="s1">self.ext == WHEEL_EXTENSION</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">is_vcs(self) -&gt; bool:</span>
        <span class="s0">from </span><span class="s1">pip._internal.vcs </span><span class="s0">import </span><span class="s1">vcs</span>

        <span class="s0">return </span><span class="s1">self.scheme </span><span class="s0">in </span><span class="s1">vcs.all_schemes</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">is_yanked(self) -&gt; bool:</span>
        <span class="s0">return </span><span class="s1">self.yanked_reason </span><span class="s0">is not None</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">has_hash(self) -&gt; bool:</span>
        <span class="s0">return </span><span class="s1">self.link_hash </span><span class="s0">is not None</span>

    <span class="s0">def </span><span class="s1">is_hash_allowed(self</span><span class="s0">, </span><span class="s1">hashes: Optional[Hashes]) -&gt; bool:</span>
        <span class="s4">&quot;&quot;&quot; 
        Return True if the link has a hash and it is allowed by `hashes`. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.link_hash </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return False</span>
        <span class="s0">return </span><span class="s1">self.link_hash.is_hash_allowed(hashes)</span>


<span class="s0">class </span><span class="s1">_CleanResult(NamedTuple):</span>
    <span class="s4">&quot;&quot;&quot;Convert link for equivalency check. 
 
    This is used in the resolver to check whether two URL-specified requirements 
    likely point to the same distribution and can be considered equivalent. This 
    equivalency logic avoids comparing URLs literally, which can be too strict 
    (e.g. &quot;a=1&amp;b=2&quot; vs &quot;b=2&amp;a=1&quot;) and produce conflicts unexpecting to users. 
 
    Currently this does three things: 
 
    1. Drop the basic auth part. This is technically wrong since a server can 
       serve different content based on auth, but if it does that, it is even 
       impossible to guarantee two URLs without auth are equivalent, since 
       the user can input different auth information when prompted. So the 
       practical solution is to assume the auth doesn't affect the response. 
    2. Parse the query to avoid the ordering issue. Note that ordering under the 
       same key in the query are NOT cleaned; i.e. &quot;a=1&amp;a=2&quot; and &quot;a=2&amp;a=1&quot; are 
       still considered different. 
    3. Explicitly drop most of the fragment part, except ``subdirectory=`` and 
       hash values, since it should have no impact the downloaded content. Note 
       that this drops the &quot;egg=&quot; part historically used to denote the requested 
       project (and extras), which is wrong in the strictest sense, but too many 
       people are supplying it inconsistently to cause superfluous resolution 
       conflicts, so we choose to also ignore them. 
    &quot;&quot;&quot;</span>

    <span class="s1">parsed: urllib.parse.SplitResult</span>
    <span class="s1">query: Dict[str</span><span class="s0">, </span><span class="s1">List[str]]</span>
    <span class="s1">subdirectory: str</span>
    <span class="s1">hashes: Dict[str</span><span class="s0">, </span><span class="s1">str]</span>


<span class="s0">def </span><span class="s1">_clean_link(link: Link) -&gt; _CleanResult:</span>
    <span class="s1">parsed = link._parsed_url</span>
    <span class="s1">netloc = parsed.netloc.rsplit(</span><span class="s3">&quot;@&quot;</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s2"># According to RFC 8089, an empty host in file: means localhost.</span>
    <span class="s0">if </span><span class="s1">parsed.scheme == </span><span class="s3">&quot;file&quot; </span><span class="s0">and not </span><span class="s1">netloc:</span>
        <span class="s1">netloc = </span><span class="s3">&quot;localhost&quot;</span>
    <span class="s1">fragment = urllib.parse.parse_qs(parsed.fragment)</span>
    <span class="s0">if </span><span class="s3">&quot;egg&quot; </span><span class="s0">in </span><span class="s1">fragment:</span>
        <span class="s1">logger.debug(</span><span class="s3">&quot;Ignoring egg= fragment in %s&quot;</span><span class="s0">, </span><span class="s1">link)</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s2"># If there are multiple subdirectory values, use the first one.</span>
        <span class="s2"># This matches the behavior of Link.subdirectory_fragment.</span>
        <span class="s1">subdirectory = fragment[</span><span class="s3">&quot;subdirectory&quot;</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s0">except </span><span class="s1">(IndexError</span><span class="s0">, </span><span class="s1">KeyError):</span>
        <span class="s1">subdirectory = </span><span class="s3">&quot;&quot;</span>
    <span class="s2"># If there are multiple hash values under the same algorithm, use the</span>
    <span class="s2"># first one. This matches the behavior of Link.hash_value.</span>
    <span class="s1">hashes = {k: fragment[k][</span><span class="s5">0</span><span class="s1">] </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">_SUPPORTED_HASHES </span><span class="s0">if </span><span class="s1">k </span><span class="s0">in </span><span class="s1">fragment}</span>
    <span class="s0">return </span><span class="s1">_CleanResult(</span>
        <span class="s1">parsed=parsed._replace(netloc=netloc</span><span class="s0">, </span><span class="s1">query=</span><span class="s3">&quot;&quot;</span><span class="s0">, </span><span class="s1">fragment=</span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">query=urllib.parse.parse_qs(parsed.query)</span><span class="s0">,</span>
        <span class="s1">subdirectory=subdirectory</span><span class="s0">,</span>
        <span class="s1">hashes=hashes</span><span class="s0">,</span>
    <span class="s1">)</span>


<span class="s1">@functools.lru_cache(maxsize=</span><span class="s0">None</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">links_equivalent(link1: Link</span><span class="s0">, </span><span class="s1">link2: Link) -&gt; bool:</span>
    <span class="s0">return </span><span class="s1">_clean_link(link1) == _clean_link(link2)</span>
</pre>
</body>
</html>